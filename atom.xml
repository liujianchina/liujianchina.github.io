<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>树先生的金融风控工程师博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.sofunnyai.com/"/>
  <updated>2020-07-31T07:15:13.097Z</updated>
  <id>https://blog.sofunnyai.com/</id>
  
  <author>
    <name>树先生</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring三级缓存和循环依赖</title>
    <link href="https://blog.sofunnyai.com/article/spring_cache.html"/>
    <id>https://blog.sofunnyai.com/article/spring_cache.html</id>
    <published>2020-07-30T01:07:50.000Z</published>
    <updated>2020-07-31T07:15:13.097Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#shi-me-shi-xun-huan-yi-lai">什么是循环依赖？</a><ul><li><a href="#bei-jing-san-ji-huan-cun-kuai-su-ru-men">背景----三级缓存快速入门</a></li></ul></li><li><a href="#shi-li-hua-guo-cheng">实例化过程</a><ul><li><a href="#bei-jing-mo-ren-beanpostprocessor">背景，默认BeanPostProcessor</a><ul><li><a href="#li-shi-yi-you-bpp-4-ge">历史已有BPP：4个</a></li><li><a href="#yi-ci-zhu-ce">依次注册：</a></li></ul></li><li><a href="#bean-chuang-jian-guo-cheng">Bean创建过程</a></li></ul></li><li><a href="#he-xin-fang-fa-zhai-lu-shuo-ming">核心方法摘录说明</a><ul><li><a href="#dogetbean-fang-fa"><strong>doGetBean</strong>方法</a></li><li><a href="#createbean-shang-mian-lambda-biao-da-shi-lai-chuang-jian-zi-ji-de-he-xin-fang-fa">createBean 上面lambda表达式来创建自己的核心方法</a></li><li><a href="#docreatebean">doCreateBean</a><ul><li><a href="#addsingleton-tian-jia-yi-ji-huan-cun">addSingleton 添加一级缓存</a></li><li><a href="#addsingletonfactory-tian-jia-san-ji-huan-cun">addSingletonFactory添加三级缓存</a></li></ul></li><li><a href="#addsingleton-tian-jia-yi-ji-huan-cun">addSingleton添加一级缓存</a></li><li><a href="#ge-ge-chong-zai-de-getsingleton">各个重载的getSingleton</a><ul><li><a href="#di-yi-ge-getsingleton-beanname-boolean-allowearlyreference-yi-ci-cong-yi-ji-er-ji-san-ji-na-san-ji-de-objectfactory-getobject-sheng-ji-dao-er-ji">第一个getSingleton(beanName, boolean allowEarlyReference) ，依次从一级、二级、三级拿。三级的ObjectFactory.getObject升级到二级。</a></li><li><a href="#di-er-ge-getsingleton-beanname-objectfactory-singletonfactory-chuan-ru-objectfactory-zhe-ge-lambda-biao-da-shi">第二个getSingleton(beanName, ObjectFactory&lt;?&gt; singletonFactory) ,传入ObjectFactory这个lambda表达式</a></li></ul></li><li><a href="#getearlybeanreference-huo-qu-san-ji-huan-cun-zao-qi-dui-xiang">getEarlyBeanReference 获取三级缓存早期对象</a></li></ul></li><li><a href="#aop-shi-xian">AOP实现</a><ul><li><a href="#defaultaopproxyfactory-de-createaopproxy-advisedsupport-config-zhen-zheng-chuang-jian-dai-li">DefaultAopProxyFactory的createAopProxy(AdvisedSupport config) 真正创建代理</a></li></ul></li><li><a href="#qa">QA</a></li></ul><!-- tocstop --></div><h1><span id="shi-me-shi-xun-huan-yi-lai"> 什么是循环依赖？</span><a href="#shi-me-shi-xun-huan-yi-lai" class="header-anchor">#</a></h1><p>当有两个bean，分别用set方法依赖对方。就会造成循环依赖，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法中去获取A对象</span></span><br><span class="line">AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"com.sam"</span>);</span><br><span class="line"> A aaa = ac.getBean(A<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(aaa.getClass());</span><br></pre></td></tr></table></figure><h2><span id="bei-jing-san-ji-huan-cun-kuai-su-ru-men"> 背景----三级缓存快速入门</span><a href="#bei-jing-san-ji-huan-cun-kuai-su-ru-men" class="header-anchor">#</a></h2><p>看一个对象<strong>DefaultSingletonBeanRegistry</strong>,他是<strong>DefaultListableBeanFactory</strong>的父类，里面有三级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一级缓存，存放实例化并初始化完毕的bean</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级缓存，存放实例化但是还未初始化的bean</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三级缓存，存放还未初始化的ObjectFactory，是一个函数式接口。使用getObject进行初始化</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><h1><span id="shi-li-hua-guo-cheng"> 实例化过程</span><a href="#shi-li-hua-guo-cheng" class="header-anchor">#</a></h1><h2><span id="bei-jing-mo-ren-beanpostprocessor"> 背景，默认BeanPostProcessor</span><a href="#bei-jing-mo-ren-beanpostprocessor" class="header-anchor">#</a></h2><p>先来混个脸熟悉，下面过程中会看到他们</p><h3><span id="li-shi-yi-you-bpp-4-ge"> 历史已有BPP：4个</span><a href="#li-shi-yi-you-bpp-4-ge" class="header-anchor">#</a></h3><ul><li>org.springframework.context.support.ApplicationContextAwareProcessor------------给我们注入AC对象、BF、env等各种aware</li><li>org.springframework.boot.web.servlet.context.WebApplicationContextServletContextAwareProcessor---------web环境注入Web的AC对象的</li><li>org.springframework.context.support.PostProcessorRegistrationDelegate$BeanPostProcessorChecker----------</li><li>org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor<ul><li>用于给注解完成配置，如<br>@EnableRedisHttpSession(redisNamespace = “web:session”)，可以</li></ul></li></ul><h3><span id="yi-ci-zhu-ce"> 依次注册：</span><a href="#yi-ci-zhu-ce" class="header-anchor">#</a></h3><p>@PriorityOrdered：</p><ul><li>org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor</li></ul><p>@Ordered</p><ul><li>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator<ul><li>AOP代理生成</li></ul></li><li>org.springframework.boot.web.server.WebServerFactoryCustomizerBeanPostProcessor</li><li>org.springframework.boot.web.server.ErrorPageRegistrarBeanPostProcessor</li><li>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor<ul><li>完成Javax的@Resource等通用注解的metaFata解析，并链式依赖注入</li></ul></li><li>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor<ul><li>完成@Autowired等注解的MetaData  解析，并链式注入</li></ul></li><li>org.springframework.context.support.ApplicationListenerDetector</li></ul><h2><span id="bean-chuang-jian-guo-cheng"> Bean创建过程</span><a href="#bean-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><ul><li>我们的<code>abstractContext</code>里面的refresh方法经过一系列的扫描解析，把<code>BeanDefinition</code>获取到BeanFactory中去。同时执行一大堆<code>BeanDefinitionRegistryPostProcessor</code>，和<code>BeanFactoryPostProcessor</code>去控制我们的BeanDifinition的生成行为。在refresh的<code>registerBeanPostProcessors</code>方法中注册了一堆BeanPostProcessor，然后会来调用此处的<code>beanFactory.preInstantiateSingletons()</code>：</li><li>BF的<code>preInstantiateSingletons</code>方法循环所有的beanName（比如有a,b,c三个bean）：<ul><li>拿出Merged<code>RootBeanDefinition</code>去getBean：</li><li>FactoryBean去创建<code>doGetBean</code>(&amp;beanName)、普通bean去<code>doGetBean</code>(beanName)：<ul><li>先去执行一次第一个<code>getSingleton(beanName);</code>看看有没有之前被放进去过（比如被循环依赖，或者被@DependsOn创建过），正常会返回null</li><li>拿到beanFactory，在set标记为正在创建中，开始继续创建</li><li>拿到beanDefinition，判断里面的@DependsOn，如果有，先<code>getBean</code>递归创建依赖的对象</li><li>调用下面<strong>第二个</strong><code>getSingleton(beanName, () -&gt; {return createBean(beanName, mbd, args);})</code>，传入一个<code>createBean</code>的lambda参数的匿名内部类。：<ul><li>下面第二个<code>getSingleton</code>里面的逻辑：对一级缓存加锁，尝试去拿一下。</li><li>拿不到就先<code>beforeSingletonCreation(beanName);</code>调用一个回调，由子类BF实现</li><li><code>singletonFactory.getObject()</code>调用匿名类的lambda表达式里面的<strong>createBean方法去创建对象</strong>：<ul><li><code>createBean</code>方法先从bd解析出class</li><li>调用BeanPostProcessor，来看看有没有谁能返回一个对象<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>，如果某个BPP返回了对象，就直接丢回去。（<strong>此处明显是创建一个代理对象，AOP在此实现</strong>）</li><li>如果上一步没有哪个BPP返回代理对象，调用<code>doCreateBean(beanName, mbdToUse, args);</code>创建并返回一个bean：<ul><li><strong>doCraeteBean</strong>里面就使用<code>createBeanInstance</code>方法去反射创建对象（<code>FactoryBean</code>是getObject和普通Bean不一样，同时BPP可以决定构造方法），创建的对象是空的，没有设值。-----------------刚刚实例化，还没放到BF中</li><li>然后<code>applyMergedBeanDefinitionPostProcessors</code>执行了<code>MergedBeanDefinitionPostProcessor</code>，比如<code>CommonAnnotationBeanPostProcessor</code>去检测@Resource这种Java.injection的注解生成metadata、<code>AutowiredAnnotationBeanPostProcessor</code>去检测了<code>@Auowired</code>这种Spring的注解，生成他们的metadata，可以去改一次bd的信息。</li><li><code>boolean earlySingletonExposure</code><strong>解决循环依赖第一步：</strong><ul><li>如果true，然后调用了<code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</code>，把<code>getEarlyBeanReference</code>这个<code>ObjectFactory</code>函数式接口放到三级缓存{k:a, v:匿名类}，并把二级缓存删掉（有的话）---------此时bean算是实例化完毕并放到三级缓存中，接下来是初始化过程</li></ul></li><li>调用<code>populateBean(beanName, mbd, instanceWrapper)</code><strong>填充bean</strong>：<ul><li>执行<code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>回调，允许spring填充前改变bean的属性。默认都是null。</li><li>循环依赖，根据注入类型，执行<code>autowireByName(beanName, mbd, bw, newPvs);</code>或者<code>autowireByType(beanName, mbd, bw, newPvs);</code>进行注入，拿到propertyValue</li><li>遍历BPP(此时都是<code>InstantiationAwareBeanPostProcessor</code>)，执行<code>postProcessAfterInstantiation</code>：<ul><li><code>CommonAnnotationBeanPostProcessor</code>会<code>postProcessProperties</code>去解析之前<code>@Resource</code>属性的metadata，调用<code>InjectMedadata.inject</code>、使用<code>doResolveDependency</code>去getBean拿到PropertyValues递归注入</li><li><code>AutowiredAnnotationBeanPostProcessor</code>会<code>postProcessProperties</code>去解析之前<code>@Auowired</code>属性的metadata，<code>doResolveDependency</code>去getBean拿到PropertyValues递归注入</li><li>xml的setter是拿到propertyValue去注入，和上面类似。</li><li>假设A里面是<code>@Autowired B</code> B里面也是<code>@Autowired A</code>，的循环依赖此时正在解析A的时候发现了B，会再去getBean(B) （此时三级a）：<ul><li>B创建完毕放到三级缓存。此时（三级a，b：获取对象的一个匿名内部类）</li><li>B来<code>populateBean</code>的时候到达这里就会需要注入A，到达这里就会再getBean(A)：<ul><li>调用地一个getSingleton方法，会拿到A的匿名类的三级缓存<code>getEarlyBeanReference(beanName, mbd, bean)</code>，从三级缓存里面拿出来实例化还未初始化的A对象a，并把它转移到二级缓存中。（此时二级a，三级b）</li><li>然后给B对象的a属性赋值a的早期对象</li><li>然后B创建完毕放到三级缓存，返回并注册（此时一级b：完全状态实例化和初始化都结束，二级a：创建中，实例化未初始化状态）</li></ul></li></ul></li><li>A设置b，返回注册（此时一级a，b，都是完全状态）</li></ul></li><li>执行<code>afterSingletonCreation(beanName);</code>方法，留给子类BF拓展</li><li><code>addSingleton(beanName, singletonObject);</code></li></ul></li><li><strong>初始化initializeBean</strong>：<code>exposedObject = initializeBean(beanName, exposedObject, mbd);</code>得到一个可以暴露的对象：-----------------AOP<ul><li>如果class是Aware，给他塞BF、ClassLoader：</li><li>1.<code>applyBeanPostProcessorsBeforeInitialization</code>：执行所有BPP的BeforeInit方法：<ul><li>如果实现了Aware，<code>invokeAwareMethods</code>方法<code>ApplicationContextAwareProcessor</code>里面塞各种Aware，如<code>context</code>、<code>env</code></li><li><code>ImportAwareBeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>给我们的Bean塞进去注解上metadata</li></ul></li><li>2.<code>invokeInitMethods</code><ul><li>执行<code>@afterPropertiesSet</code>这个<code>init</code>方法</li></ul></li><li>3.<code>applyBeanPostProcessorsAfterInitialization</code>--------AOP在此实现<ul><li><code>postProcessAfterInitialization</code>执行，其中<code>ApplicationListenerDetector</code>去检查这个类是否是一个监听器，是的话加入到<code>applicationContext</code>里面</li><li><code>AbstractAutoProxyCreator</code>的<code>postProcessAfterInitialization</code>方法调用了<strong>wrapIfNecessary</strong>去创建代理：<ul><li>拿到这个类的切面，有才继续调用<code>createProxy</code>方法创建代理：<ul><li>给bd的<code>origianlTargetClass</code>塞进去代理前的类名，new 一个 <code>ProxyFactory</code></li><li>拿到这个类的接口，遍历每一个，只要找到一个非InitializingBean<code>、</code>Closeable<code>、</code>Aware`等无需代理的接口、就继续</li><li>有接口就加到proxyFactory中，没有的话就设置代理class标识为true（后面判断jdk还是cglib）</li><li><code>buildAdvisors</code>构建切面拦截的列表，添加到<code>proxyFactory</code>中</li><li>提供一个扩展点<code>customizeProxyFactory(proxyFactory);</code></li><li><code>createAopProxy().getProxy(clazzLoader)</code>就创建代理：<ul><li>调用<code>DefaultAopProxyFactory#createAopProxy(AdvisedSupport config)</code>创建动态代理：<ul><li>如果有接口<code>new JdkDynamicAopProxy(config)</code>，创建JDK动态代理，InvocationHandler，拦截invoke方法</li><li>没有接口<code>new ObjenesisCglibAopProxy(config)</code>，创建CGlib动态代理，enhancer增强器塞接口/属性/类、设置callback、method intercepter</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>调用第一个getSingleton(name,false)，只从1、2拿，是null，然后<code>registerDisposableBeanIfNecessary</code>是个空</li><li>结束doCreateBean，得到一个BeanWarper包装类</li></ul></li><li>结束CreateBean，getBean一次去从三级getSingleton缓存拿出来</li><li>发现是新的bean，<code>addSingleton(name,bean)</code>，注册到一级缓存，清除二级三级缓存。</li><li><code>afterSingletonCreation(String beanName)</code>留给子类BF实现拓展</li></ul></li><li>结束getSingleton</li></ul></li><li>结束doGetBean</li></ul></li><li>结束getBean</li></ul></li><li>继续循环创建下一个对象</li></ul><h1><span id="he-xin-fang-fa-zhai-lu-shuo-ming"> 核心方法摘录说明</span><a href="#he-xin-fang-fa-zhai-lu-shuo-ming" class="header-anchor">#</a></h1><h2><span id="dogetbean-fang-fa"> <strong>doGetBean</strong>方法</span><a href="#dogetbean-fang-fa" class="header-anchor">#</a></h2><p><strong>AbstractBeanFactory</strong>是<strong>DefaultSingletonBeanRegistry</strong>的一个子类，中有一个<code>doGetBean</code>方法承接了外面的各种<code>getBean</code>的调用，是每一个单例对象创建的具体实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正创建一个Bean</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// beanName生成，一般和FactoryBean的&amp;有关</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上来先去赶紧检查有没有手动注册上去他（或者在被别的bean依赖的时候已经初始化了，如例子中的B对象），否则会返回null</span></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);  <span class="comment">// 没有被注册过，或则被其他bean以来的时候创建过，这里会返回null</span></span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父容器，不用管</span></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打个标记，放到alreadyCreated中</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拿到parent BeanDefinition和child BeanDefinition的组合</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拿到当前dependsOn的Bean，去getBean处理dependsOn的类列表</span></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);   <span class="comment">// 递归获取dependsOn的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//----------------------开始创建对象-----------------------</span></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 调用下面第二个getSingleton，见其描述，传进去一个lambda表达式，继续往下看，暂时还没执行这个lambda</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);<span class="comment">// 》》》》》》》》》》》》》》》》》》》》》》》》》》》》》看下面书名号的地方回来调用的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="createbean-shang-mian-lambda-biao-da-shi-lai-chuang-jian-zi-ji-de-he-xin-fang-fa"> createBean  上面lambda表达式来创建自己的核心方法</span><a href="#createbean-shang-mian-lambda-biao-da-shi-lai-chuang-jian-zi-ji-de-he-xin-fang-fa" class="header-anchor">#</a></h2><p>这个方法非常简单：</p><ul><li>从beanDefinition拿出Class</li><li>可以允许<code>BeanPostProcessor</code>创建代理对象resolveBeforeInstantiation(beanName, mbdToUse)方法如果返回对象，就丢回去。<ul><li>其实就是拿到所有的<code>InstantiationAwareBeanPostProcessor</code>子类，最主要的AOP类<code>AbstractAutoProxyCreator#postProcessBeforeInstantiation</code>里面进行<code>createProxy</code>方法找到<code>ProxyFactory类</code>，调用<code>AopProxy#createAopProxy</code>方法，有两个实现</li></ul></li><li>否则继续后面的<code>doCreateBean</code>去使用<code>lambda</code>表达式真正创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// 一堆检查，拿出class，别的都不重要</span></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意这里，是使用BeanPostProcessor来创建代理，如果创建了就返回代理，否则下面采取真正调用doCreateBean创建真正的对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用doCreateBean创建真正的对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line"><span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="docreatebean"> doCreateBean</span><a href="#docreatebean" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="addsingleton-tian-jia-yi-ji-huan-cun"> addSingleton 添加一级缓存</span><a href="#addsingleton-tian-jia-yi-ji-huan-cun" class="header-anchor">#</a></h3><p>清空二级三级缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="addsingletonfactory-tian-jia-san-ji-huan-cun"> addSingletonFactory添加三级缓存</span><a href="#addsingletonfactory-tian-jia-san-ji-huan-cun" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="comment">// 锁定一级缓存</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 一级缓存里面没有，把ObjectFactory放到三级缓存，并把二级缓存删掉</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="addsingleton-tian-jia-yi-ji-huan-cun"> addSingleton添加一级缓存</span><a href="#addsingleton-tian-jia-yi-ji-huan-cun" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 锁定一级缓存，放入一级缓存，清理三级、二级缓存，注册对象</span></span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="ge-ge-chong-zai-de-getsingleton"> 各个重载的getSingleton</span><a href="#ge-ge-chong-zai-de-getsingleton" class="header-anchor">#</a></h2><h3><span id="di-yi-ge-getsingleton-beanname-boolean-allowearlyreference-yi-ci-cong-yi-ji-er-ji-san-ji-na-san-ji-de-objectfactory-getobject-sheng-ji-dao-er-ji"> 第一个getSingleton(beanName, boolean allowEarlyReference) ，依次从一级、二级、三级拿。三级的ObjectFactory.getObject升级到二级。</span><a href="#di-yi-ge-getsingleton-beanname-boolean-allowearlyreference-yi-ci-cong-yi-ji-er-ji-san-ji-na-san-ji-de-objectfactory-getobject-sheng-ji-dao-er-ji" class="header-anchor">#</a></h3><p>初次过来这里会返回null，各级缓存都没有，没有则返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回初始化好的bean，或者实例化还未初始化的二级缓存。同时从三级缓存remove</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 一级缓存中去获取</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="comment">// 如果没有的话，检查是否在创建中（一个set中有没有标识）</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 创建中的bean，就加锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">// 从二级缓存里面获取</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="comment">// 如果二级缓存为空，但是允许返回提前引用</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    <span class="comment">// 就从三级缓存里面拿</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 三级缓存不为空，就调用ObjectFactory函数式接口的 getObject方法创建一个二级缓存</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="comment">// 然后吧这个早期的对象放入到二级缓存中暴露</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="comment">// 从三级缓存移除</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="di-er-ge-getsingleton-beanname-objectfactory-lt-gt-singletonfactory-chuan-ru-objectfactory-zhe-ge-lambda-biao-da-shi"> 第二个getSingleton(beanName, ObjectFactory&lt;?&gt; singletonFactory) ,传入ObjectFactory这个lambda表达式</span><a href="#di-er-ge-getsingleton-beanname-objectfactory-lt-gt-singletonfactory-chuan-ru-objectfactory-zhe-ge-lambda-biao-da-shi" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name,</span></span><br><span class="line"><span class="comment"> * creating and registering a new one if none registered yet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonFactory the ObjectFactory to lazily create the singleton</span></span><br><span class="line"><span class="comment"> * with, if necessary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;  </span><br><span class="line">            <span class="comment">// 锁定一级缓存，获取一下</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 一个给子BeanFactory的拓展点，此处为空</span></span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 开始调用lambda函数接口，使用createBean方法真正创建一个对象》》》》》》》》》》》》》》》》》</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="getearlybeanreference-huo-qu-san-ji-huan-cun-zao-qi-dui-xiang"> getEarlyBeanReference 获取三级缓存早期对象</span><a href="#getearlybeanreference-huo-qu-san-ji-huan-cun-zao-qi-dui-xiang" class="header-anchor">#</a></h2><p>如getBean( A) --populate–&gt;getBean( B)–populate—&gt;getBean( A)的时候，去到getSingleton(A)发生循环引用，从三级缓存里面调用过来：</p><p>// getEarlyBeanReference(“a”, bd, a@123对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain a reference for early access to the specified bean,</span></span><br><span class="line"><span class="comment"> * typically for the purpose of resolving a circular reference.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean (for error handling purposes)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object to expose as bean reference</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//  getEarlyBeanReference("a", bd, a@123对象)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;  <span class="comment">// 已经创建还未初始化的a对象</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    <span class="comment">// 给BPP进行操作，默认都没有实现，此时可以AOP！！！！！！！！！！！！！！</span></span><br><span class="line">                    <span class="comment">// AbstractAutoProxyCreator#getEarlyBeanReference，里面wrapIfNecessary进行createProxy创建代理</span></span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="aop-shi-xian"> AOP实现</span><a href="#aop-shi-xian" class="header-anchor">#</a></h1><ul><li><p>我们的<code>@EnableAspectJAutoProxy</code>注解的Config类是一个<code>@Configuration</code>会在refresh的<code>invokeBeanFactoryPostProcessors</code>中被<code>ConfigurationClassPostProcessor</code>识别到。使用import技术扫描加载<code>@Import(AspectJAutoProxyRegistrar.class)</code>。（见spring启动流程文章）</p></li><li><p>使用<code>AspectJAutoProxyRegistrar</code>里面的<code>ImportBeanDefinitionRegistrar</code>实现去拿到beanDifinitionReigistry（其实就是BF），注入了一个<code>AnnotationAwareAspectJAutoProxyCreator</code>这个BeanPostProcessor</p></li><li><p>然后在refresh的实例化bean方法<code>finishBeanFactoryInitialization(beanFactory);</code>中的doCreateBean中先反射创建对象，然后的initBean里面初始化：</p><ul><li>执行BPP的beforePostProcessor方法</li><li>执行init方法（@PostConstruct）</li><li>执行后置处理器去调用上面这个BPP的<code>postProcessorAfterBeanInit</code>完成代理。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 里面有各个BeanPostProcesser的方法实现, 核心就是下面这个在实例化之前调用来决定是否创建代理，创建何种代理的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="defaultaopproxyfactory-de-createaopproxy-advisedsupport-config-zhen-zheng-chuang-jian-dai-li"> DefaultAopProxyFactory的createAopProxy(AdvisedSupport config) 真正创建代理</span><a href="#defaultaopproxyfactory-de-createaopproxy-advisedsupport-config-zhen-zheng-chuang-jian-dai-li" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOP创建代理的实现，没有接口使用CGlib，有接口使用JDK动态代理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);  <span class="comment">// 创建cglib动态代理，enhancer塞接口、类、callback、method intercepter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config); <span class="comment">// 创建JDK动态代理，丢一个InvocationHandler对象，每次执行调用invoke方法拦截处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1><span id="qa"> QA</span><a href="#qa" class="header-anchor">#</a></h1><ul><li>一级缓存能解决么？<ul><li>不行，因为如果只有一级缓存，创建中（实例化还没初始化）的对象和创建结束的对象都在一个map中，可能导致正在创建中的对象被用户提前获取属性为空，导致空指针。此时可以加一个二级缓存来存放还没初始化完毕的对象。</li></ul></li><li>为什么一定要三级缓存？二级不就行了么？<ul><li>三级里面放的是一个匿名内部类，包装了一个刚刚实例化的对象。<code>getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean)</code>，调用了BPP去进行判断，我们的对象是简单对象还是需要进行代理的。</li><li>三级缓存的主要意义：代理。比如<code>AbstractAutoProxyCreator#getEarlyBeanReference，里面wrapIfNecessary进行createProxy创建代理</code>，我们的对象在向三级缓存放置之后，可以在读取的时候通过pambda表达式去执行BPP的方法，给BPP一个机会来判断是否需要进行代理，选择代理方式进行代理。</li><li>生成代理之后我们用户使用都应该是代理对象，如果不放到三级缓存，可能代理之前被获取到原始对象，导致代理失败。放了三级缓存之后，只要有人去拿就会判断是否代理，不会造成代理目标逃逸，代理失败的情况。也就是保证了不管什么时候获取的对象都是代理过的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#shi-me-shi-xun-huan-yi-lai&quot;&gt;什么是循环依赖？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#bei-jing-san-ji-
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://blog.sofunnyai.com/categories/Spring/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="Spring" scheme="https://blog.sofunnyai.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://blog.sofunnyai.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>风控策略相关的一切</title>
    <link href="https://blog.sofunnyai.com/article/strategy.html"/>
    <id>https://blog.sofunnyai.com/article/strategy.html</id>
    <published>2020-04-15T06:37:22.000Z</published>
    <updated>2020-05-26T05:06:31.825Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#feng-kong-ce-lue-gai-yao">风控策略概要</a><ul><li><a href="#shi-me-shi-feng-kong-shen-pi-ce-lue">什么是风控审批策略</a><ul><li><a href="#qi-zhong-duo-wei-du-shu-ju-de-ce-lue-gui-ze-bao-gua">其中多维度数据的<strong>策略规则</strong>包括：</a></li></ul></li><li><a href="#feng-kong-shen-pi-ce-lue-de-mu-de">风控审批策略的目的</a><ul><li><a href="#feng-kong-shen-pi-ce-lue-de-zuo-yong">风控审批策略的作用</a></li><li><a href="#feng-kong-shen-pi-ce-lue-de-lei-bie">风控审批策略的类别</a></li><li><a href="#feng-kong-de-ji-ben-liang-hua-zhi-biao">风控的基本量化指标</a></li><li><a href="#que-ding-mu-biao-bian-liang">确定目标变量</a></li><li><a href="#zhi-ding-feng-kong-shen-pi-ce-lue">制定风控审批策略</a></li><li><a href="#ce-lue-yu-gu">策略预估</a></li><li><a href="#ce-lue-jian-kong">策略监控</a></li><li><a href="#ce-lue-hui-gu">策略回顾</a></li></ul></li></ul></li><li><a href="#feng-kong-ce-lue-fen-xi-shi">风控策略分析师</a><ul><li><a href="#ri-chang-gong-zuo-nei-rong">日常工作内容</a></li><li><a href="#bi-bei-ji-neng">必备技能</a></li><li><a href="#he-xin-zuo-yong">核心作用</a></li><li><a href="#ce-lue-fen-xi-chang-jian-gong-zuo-chang-jing-yu-dui-ying-fen-xi-fang-fa">策略分析常见工作场景与对应分析方法</a></li><li><a href="#san-fang-shu-ju-ce-ping">三方数据测评</a><ul><li><a href="#ju-li-hei-ming-dan-shu-ju-ping-ce">举例—黑名单数据评测</a></li></ul></li><li><a href="#zhun-ru-ce-lue-de-zhi-ding">准入策略的制定</a><ul><li><a href="#nian-ling-zhun-ru-ce-lue"><strong>年龄准入策略</strong></a></li><li><a href="#di-qu-zhun-ru-ce-lue"><strong>地区准入策略</strong></a></li><li><a href="#bai-ming-dan-ce-lue">白名单策略</a></li><li><a href="#hei-ming-dan-ce-lue">黑名单策略</a></li></ul></li></ul></li><li><a href="#gui-ze-yu-zhi-cutoff-ru-he-she-ding"><strong>规则阈值cutoff如何设定</strong></a><ul><li><a href="#bei-jing">背景</a></li><li><a href="#di-yi-bu-tong-guo-ping-fen-zhao-dao-feng-xian-bei-di-gu-de-qu-jian"><em>第一步：通过评分找到风险被低估的区间</em></a></li><li><a href="#di-er-bu-ping-gu-ni-ju-jue-ren-qun-de-shou-yi-feng-xian-bi"><em>第二步，评估拟拒绝人群的收益/风险比</em></a></li></ul></li><li><a href="#tong-guo-lu-xia-jiang-de-ce-lue-diao-zheng">通过率下降的策略调整</a><ul><li><a href="#1-xun-zhao-tong-guo-lu-xia-jiang-de-shi-jian-dian-huo-shi-jian-duan">1.寻找通过率下降的时间点或时间段</a></li><li><a href="#2-pan-duan-ce-lue-jie-dian-zhu-ci-yao-ju-jue-ying-xiang">2.判断策略节点主次要拒绝影响</a></li><li><a href="#3-cong-jie-dian-ju-jiao-dao-jie-dian-gui-ze-ceng-shen-du-fen-xi"><em>3.从节点聚焦到节点规则层深度分析</em></a></li><li><a href="#4-ju-ti-gui-ze-fen-bu-fen-xi"><em>4.具体规则分布分析</em></a></li><li><a href="#5-fen-xi-zhi-dao-jue-ce"><em>5.分析指导决策</em></a></li></ul></li><li><a href="#yu-qi-lu-shang-sheng-de-ce-lue-diao-zheng">逾期率上升的策略调整</a><ul><li><a href="#di-yi-bu-que-ding-cun-liang-huan-shi-xin-zeng-ke-hu-dao-zhi-yu-qi-shang-sheng"><strong>第一步：确定存量还是新增客户导致逾期上升</strong></a></li><li><a href="#di-er-bu-duo-wei-du-fen-xi-zhao-chu-zui-zhu-yao-ying-xiang-gui-ze"><strong>第二步：多维度分析，找出最主要影响规则</strong></a></li><li><a href="#di-san-bu-zhi-ding-ce-lue-diao-zheng-fang-an"><strong>第三步：制定策略调整方案</strong></a></li></ul></li><li><a href="#xin-yong-duo-tou-ce-lue">信用多头策略</a><ul><li><a href="#1-shi-me-shi-duo-tou-jie-dai"><strong>1.什么是多头借贷</strong></a></li><li><a href="#2-duo-tou-jie-dai-shu-ju-de-fen-xi-fang-fa"><strong>2.多头借贷数据的分析方法</strong></a></li><li><a href="#3-duo-tou-jie-dai-shu-ju-wei-he-shao-yong-yu-mo-xing"><strong>3.多头借贷数据为何少用于模型</strong></a></li><li><a href="#4-duo-tou-jie-dai-shu-ju-zai-ce-lue-gui-ze-shang-de-ying-yong"><strong>4.多头借贷数据在策略规则上的应用</strong></a></li></ul></li><li><a href="#ping-fen-de-ce-lue-ying-yong">评分的策略应用</a><ul><li><a href="#ping-fen-qia-mo-xing-de-yun-yong-zhu-yao-shi-wei-liao-jie-jue-liang-da-wen-ti">评分卡模型的运用，主要是为了解决两大问题：</a></li></ul><ul><li><a href="#ping-fen-mo-xing-de-cutoff">评分模型的cutoff</a></li></ul></li><li><a href="#mo-xing-yu-ce-lue-de-guan-xi">模型与策略的关系</a><ul><li><a href="#mo-xing-shi-fou-ke-yi-ti-dai-suo-you-de-ce-lue-gui-ze">模型是否可以替代所有的策略规则?</a><ul><li><a href="#ce-lue-gui-ze-ping-fen-mo-xing">策略规则+评分模型</a></li><li><a href="#ce-lue-gui-ze-mo-xing-gui-ze">策略规则+模型规则</a></li><li><a href="#ce-lue-gui-ze-de-cu-fang-shi-guan-li"><strong>策略规则的粗放式管理</strong></a></li></ul></li><li><a href="#ping-fen-mo-xing-de-chang-jian-san-chong-mang-qu"><strong>评分模型的常见三种盲区</strong></a><ul><li><a href="#jian-mo-shu-ju-ji-yu-shi-ji-dai-kuan-ren-zhi-jian-cun-zai-pian-chai"><strong>建模数据集与实际贷款人之间存在偏差</strong></a></li><li><a href="#mo-xing-shu-ju-ji-lai-zi-li-shi-yu-wei-lai-shi-ji-qing-kuang-cun-zai-pian-chai"><strong>模型数据集来自历史，与未来实际情况存在偏差</strong></a></li><li><a href="#mo-xing-dui-yu-mu-biao-bian-liang-de-jie-ding-yu-shi-ji-shang-ye-mu-biao-cun-zai-pian-chai"><strong>模型对于目标变量的界定与实际商业目标存在偏差</strong></a></li></ul></li></ul></li></ul><!-- tocstop --></div><blockquote><p>精简摘录自微信公众号：金科应用研院</p></blockquote><h1><span id="feng-kong-ce-lue-gai-yao"> 风控策略概要</span><a href="#feng-kong-ce-lue-gai-yao" class="header-anchor">#</a></h1><h2><span id="shi-me-shi-feng-kong-shen-pi-ce-lue"> 什么是风控审批策略</span><a href="#shi-me-shi-feng-kong-shen-pi-ce-lue" class="header-anchor">#</a></h2><p>基于数据分析在申请阶段制定各式各样多维度的<strong>策略和规则</strong>;</p><h3><span id="qi-zhong-duo-wei-du-shu-ju-de-ce-lue-gui-ze-bao-gua"> 其中多维度数据的<strong>策略规则</strong>包括：</span><a href="#qi-zhong-duo-wei-du-shu-ju-de-ce-lue-gui-ze-bao-gua" class="header-anchor">#</a></h3><ol><li>社交及短信维度规则</li><li>移动设备维度规则</li><li>外部数据源（如：征信报告、各种黑名单来源）规则</li><li>多维度评分卡规则</li><li>行为数据(设备信息、注册时间、登陆时间)规则</li></ol><h2><span id="feng-kong-shen-pi-ce-lue-de-mu-de"> 风控审批策略的目的</span><a href="#feng-kong-shen-pi-ce-lue-de-mu-de" class="header-anchor">#</a></h2><p>在贷前审批减少风险事件的发生的各种可能性，挽回风险事件时造成的损失。较大的程度上筛选过滤高风险客户，保留低风险客户予以营销。针对客群分级实行个性化的审批流程，提高审批效率。</p><h3><span id="feng-kong-shen-pi-ce-lue-de-zuo-yong"> 风控审批策略的作用</span><a href="#feng-kong-shen-pi-ce-lue-de-zuo-yong" class="header-anchor">#</a></h3><p>在保证业务量的同时降低业务坏账率、控制逾期风险，最终实现公司盈利。</p><h3><span id="feng-kong-shen-pi-ce-lue-de-lei-bie"> 风控审批策略的类别</span><a href="#feng-kong-shen-pi-ce-lue-de-lei-bie" class="header-anchor">#</a></h3><p>多维度数据分析呈现了借款人的用户画像，制定多维度完善的审批策略规则，具体策略规则包含：</p><ul><li>1）经济能力维度(月收入、工资流水等信息)</li><li>2）app信息维度(贷款APP安装个数、短信命中高风险关键词)</li><li>3）基本信息维度(年龄、性别、工龄等信息)</li><li>4）信用历史(征信贷款信息、还款记录)</li><li>5）行为表现(活动轨迹、登陆时间、注册时间等信息)</li></ul><h3><span id="feng-kong-de-ji-ben-liang-hua-zhi-biao"> 风控的基本量化指标</span><a href="#feng-kong-de-ji-ben-liang-hua-zhi-biao" class="header-anchor">#</a></h3><ul><li><p>FPDx：首期逾期，x对应天数</p></li><li><p>CPDx：当前逾期，x对应天数</p></li></ul><p>逾期时间的长短来定义逾期的等级，C代表正常资产。M3-M6属于不良，M6+属于坏账。</p><p>迁移率、vintage账龄分析、滚动率见<a href="./vintage_rollrate_fpd.html">上一篇博客</a>，这里：<a href="https://blog.sofunnyai.com/article/vintage_rollrate_fpd.html">https://blog.sofunnyai.com/article/vintage_rollrate_fpd.html</a></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525145244445.png" alt="image-20200525145244445"></p><h3><span id="que-ding-mu-biao-bian-liang"> 确定目标变量</span><a href="#que-ding-mu-biao-bian-liang" class="header-anchor">#</a></h3><p>根据催回率及迁徙率确定好坏客户（不过一般还是用滚动率比较多）</p><p>由上表可以看出，M2以上的迁徙率将近90%，所以确定当前逾期31天以上为区分好坏客户的标准，及后续分析的目标变量。</p><h3><span id="zhi-ding-feng-kong-shen-pi-ce-lue"> 制定风控审批策略</span><a href="#zhi-ding-feng-kong-shen-pi-ce-lue" class="header-anchor">#</a></h3><p>如以城市等级为例，城市等级与逾期的关系：城市等级越低，其对应的逾期率越高。</p><h3><span id="ce-lue-yu-gu"> 策略预估</span><a href="#ce-lue-yu-gu" class="header-anchor">#</a></h3><p>预估策略上线对生产运营阶段的影响，基于进件量、放款量、通过率的影响。</p><h3><span id="ce-lue-jian-kong"> 策略监控</span><a href="#ce-lue-jian-kong" class="header-anchor">#</a></h3><p>策略上线后，监控此策略的占比与预计的占比是否发生严重偏差，且在正常运行阶段是否全部执行。</p><h3><span id="ce-lue-hui-gu"> 策略回顾</span><a href="#ce-lue-hui-gu" class="header-anchor">#</a></h3><p>对上线后的策略，在一定时间后。对于有表现的数据进行策略回顾，看策略调整后的进件量、通过率及贷后表现。若是想及时的查看策略上线后的贷后表现可以针对FPD指标分不同的天数去观测，FPD4，FPD10，FPD30等。</p><ul><li><p>若策略是调宽或者是放松时，可以针对性回顾下豁免出来的客户的进件情况、通过率及贷后表现。</p></li><li><p>若策略是调严或者收紧时，可以针对性回顾拒绝阈值边缘维度的贷后表现及拟定拒绝的客户数。</p></li></ul><h1><span id="feng-kong-ce-lue-fen-xi-shi"> 风控策略分析师</span><a href="#feng-kong-ce-lue-fen-xi-shi" class="header-anchor">#</a></h1><p>风控策略分析师是完成上述P1部分所有分析，构架风控策略的人员。</p><h2><span id="ri-chang-gong-zuo-nei-rong"> 日常工作内容</span><a href="#ri-chang-gong-zuo-nei-rong" class="header-anchor">#</a></h2><ul><li>贷前、贷中及贷后各环节的风险策略与流程，制订各项策略规则，具体包括<strong>准入、授信、定价、用信、还款、调额等信贷流程</strong>各阶段的<strong>策略规则</strong></li><li>通过对各类风险指标与报表的分析，关注各类资产和客群的风险变动，对公司全渠道风险政策与策略进行跟踪评价，并及时优化调整相应的风险政策与策略</li></ul><h2><span id="bi-bei-ji-neng"> 必备技能</span><a href="#bi-bei-ji-neng" class="header-anchor">#</a></h2><ul><li>结合内外数据，通过统计分析方法，对不同风险点制定出不同类型的风险规则</li><li>完成整个贷前、贷中和贷后的<strong>风险规则架构</strong>，实现<strong>自动化风控</strong></li><li>可以实现策略规则优化，不限于A、D类调优方法</li><li>规则的部署与监控预警</li><li>临时指标调整的项目经验</li></ul><h2><span id="he-xin-zuo-yong"> 核心作用</span><a href="#he-xin-zuo-yong" class="header-anchor">#</a></h2><p>实现具体规则和流程的设计、开发、部署、监控与优化</p><h2><span id="ce-lue-fen-xi-chang-jian-gong-zuo-chang-jing-yu-dui-ying-fen-xi-fang-fa"> 策略分析常见工作场景与对应分析方法</span><a href="#ce-lue-fen-xi-chang-jian-gong-zuo-chang-jing-yu-dui-ying-fen-xi-fang-fa" class="header-anchor">#</a></h2><h2><span id="san-fang-shu-ju-ce-ping"> 三方数据测评</span><a href="#san-fang-shu-ju-ce-ping" class="header-anchor">#</a></h2><ul><li>案例：现有1000个样本数据，分别测试2家黑名单，2家欺诈名单与2家多头，如何选择合适的第三方数据源？</li></ul><p>首先要专业科普选择第三方数据源重要考察的5大指标计算公式（以黑名单为例）：</p><ol><li>查得率(Search rate)=查得数/样本量</li><li>覆盖率(Cover rate)=查得命中黑名单数/样本中命中黑名单量</li><li>误拒率(Error reject rate)=查得命中黑名单数/样本中通过且为Good量</li><li>有效差异率(Effective difference rate)=查得命中黑名单数/样本中通过且Bad量</li><li>无效差异率(Invalid difference rate)=查得命中黑名单数/样本中其他拒绝量</li></ol><p>其中SR、CR、EDR指标越高越好，ERR越低越好，IDR与EDR结合起来观察，如果IDR和EDR都较高，反应的一种情况是数据源定义黑名单是广撒网式，黑名单质量相对不够精准。</p><p>其中前三个指标是重点考察，如果想更全面的测试第三方数据源，后面两个差异率指标也可以加入考核标准。</p><h3><span id="ju-li-hei-ming-dan-shu-ju-ping-ce"> 举例—黑名单数据评测</span><a href="#ju-li-hei-ming-dan-shu-ju-ping-ce" class="header-anchor">#</a></h3><p>1000个测试样本数据中，审批结果字段表示样本通过和拒绝，其中通过样本中有未逾期和发生逾期的客户样本，拒绝样本中有通过黑名单库拒绝客户，也有其他原因产生拒绝。比如，数据源1（黑名单）代表一家提供黑名单数据的数据供应商A，数据源2（黑名单）代表另一家提供黑名单数据的数据供应商B，以此类推。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525150653791.png" alt="image-20200525150653791"></p><p>对1000条测试数据返回结果进行整理可以总结出如上数据概要，对比看到数据源1的返回结果如下：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525150737830.png" alt="image-20200525150737830"></p><p>按照文章开始介绍的指标分析方法，对比数据源1和数据源2的测试结果可以得出如下结论：</p><ol><li>数据供应商1的查得率、覆盖率高于数据供应商2大约5%、4%；</li><li>数据供应商1的误拒率低于数据供应商2大约0.3%；</li><li>数据供应商1的有效差异率低于数据供应商2大约8%，无效差异率低于数据供应商2大约7%；</li></ol><p>依据五大指标分析标准，SR、CR、EDR指标越高越好，ERR越低越好，IDR与EDR结合起来观察，如果IDR和EDR都较高，反应的一种情况是数据源定义黑名单是广撒网式，黑名单质量相对不够精准！</p><p>最终分析结论：</p><p>数据供应商2虽然覆盖的黑名单比数据供应商1的更广，但其不如数据供应商1精准，更偏向选择数据供应商1的黑名单数据。</p><h2><span id="zhun-ru-ce-lue-de-zhi-ding"> 准入策略的制定</span><a href="#zhun-ru-ce-lue-de-zhi-ding" class="header-anchor">#</a></h2><p>风控准入策略作为金融借贷机构评估一个借款人是否有机会获得授信的第一道门槛，是保卫金融机构的第一道护卫。</p><p>风控准入策略属于贷前风控策略体系的一部分，贷前风控策略包括<strong>基础认证、准入策略，贷前反欺诈策略，黑名单策略，特殊名单策略及信用风险策略</strong>。风控准入策略中的规则更多是由产品政策性规则构成。</p><p>针对不同信贷场景采取更适应业务的准入规则，设定科学的准入策略，对于风险的防范与降维有十分重要意义。合理的风险准入策略，也能对信贷业务的走向与风险倾向产生直接影响，进一步影响金融机构的最终盈亏。</p><p><strong>为什么要设计风控准入策略</strong></p><p>风控准入策略的规则属性全部为强拒绝规则（硬规则），借款人<strong>一旦不满足一条准入规则金融贷款机构都不会给予贷款的授信与发放</strong>；同时，风控准入规则不需要经过复杂的规则衍生，通常可以简单有效的判决借款人是否有资格进入之后的风控流程；最后，风控准入规则的策略理念是验证借款人依法合规未被政策限制。</p><p><strong>风控准入策略模块</strong></p><p>风控基础认证模块:</p><p>基础认证模块主要作用是验证借款此人是本人，也是以风控规则形式出现，规则大多为公允共认的规则。比如身份证信息验证，人脸信息验证、银行卡四要素验证、运营商三要素验证等。</p><p>在验证完借款人基础信息后，风控贷前流程才会进入准入策略模块。</p><p>准入策略模块主要分为<strong>年龄准入、地区准入、行业准入及其他</strong>。这些准入规则的根本设定原则是基于监管和金融机构产品政策性导向。</p><h3><span id="nian-ling-zhun-ru-ce-lue"> <strong>年龄准入策略</strong></span><a href="#nian-ling-zhun-ru-ce-lue" class="header-anchor">#</a></h3><p>对于年龄准入而言，中国银行业监督管理委员会令《个人贷款管理暂行办法》中指出个人贷款申请应具备以下条件：</p><p>（一）借款人为具有完全民事行为能力的中华人民共和国公民或符合国家有关规定的境外自然人；</p><p>（二）贷款用途明确合法；</p><p>（三）贷款申请数额、期限和币种合理；</p><p>（四）借款人具备还款意愿和还款能力；</p><p>（五）借款人信用状况良好，无重大不良信用记录；</p><p>（六）贷款人要求的其他条件。</p><p>其中借款人具有完全民事行为能力的中华人民共和国公民年龄范围在<strong>18-60岁</strong>。所以合规的金融机构信贷产品的借款人年龄准入策略中，年龄规则的设定是：年龄&gt;X &amp;  年龄&lt;X ，X属于18-60。有些贷款产品，则是根据贷款人的性别不同来限制年龄的。比如对于女性申请人的年龄限制是22周岁以上，而男性申请人的年龄限制为20周岁。</p><h3><span id="di-qu-zhun-ru-ce-lue"> <strong>地区准入策略</strong></span><a href="#di-qu-zhun-ru-ce-lue" class="header-anchor">#</a></h3><p>一般金融机构会按照风险热力地图将一些重灾风险区进行隔离或者进行“象征性”政策贷款发放。</p><p>地区准入规则的初始设定一般是风险集中度比较高、社会稳定性比较弱、地区经济GDP比较低，亦或是难催收的地区，比如<strong>新疆、东北</strong>等个别地域。</p><p>在之后随着信贷业务的开展，也会根据贷款回收率对地区准入规则进行一些策略调整，比如一些地区的贷款回收率长期观测较低，金融机构企业内部信贷战略调整后，可以将这些地区加入限制性地区里。</p><p>上图事例1中展示的是M1阶段的回收率热力分布地图，可以发现灰色区域的M1贷款回收率低于60%。如果需要进行地区准入策略的调整，还可以将M1回收率0-60%的区间划分的更细，比如0-15%的M1回收率，也可以将省维度拆成市级维度进行限制。</p><p>此处需要提醒，<strong>一旦加入到地区准入规则后的地域在之后将无法进行信贷业务，同时也会失去观测业务数据</strong>，所以此类的策略调整<strong>要谨慎设计</strong>。</p><p>地区准入策略的常用规则如<strong>户籍地址</strong> in（x,x,x），<strong>单位地址</strong> in （x,x,x）,<strong>家庭地址</strong> in （x,x,x）等。</p><p><strong>行业准入策略</strong></p><p>行业准入策略的基础原则是对一些行业工作不稳定或无业的借款人禁止提供信贷业务。如禁止：</p><p>金融属性行业如投资、担保、理财、典当；政策性敏感娱乐行业如KTV、按摩院、会所等；无业和自由职业、学生、媒体工作者，检察院。</p><h3><span id="bai-ming-dan-ce-lue"> 白名单策略</span><a href="#bai-ming-dan-ce-lue" class="header-anchor">#</a></h3><p>白名以下两种业务场景：</p><p>A.在存在自有存量数据的前提下，金融机构想开展信贷业务，前期需要通过白名单控制入口，此类场景多存在于<strong>业务初期，或者是内部员工贷</strong>的业务场景。(风控模型不完善的条件下，先把业务开展起来。同时，在这个展业的过程中，可以逐渐组建适合金融机构业务的风控策略和模型。)</p><p>B.在业务开展中期，需要<strong>部分进件客户走特殊贷前审批流程</strong>，满足特殊审批的要求，此类场景多存在于较大的金融公司。(有着较好的信用、较好的资产亦或是较好的“背景”，通过一些特殊审批流程进行贷款的审核，最终满足“VIP”的借贷需求。)</p><p>综合来讲，白名单可以定义为，通过金融机构内部现有数据判断的“好客户”，或者经过一系列规则挖掘分析得出的“好客户”，由他们组成的借贷优质名单。</p><p><strong>如何筛选出白名单</strong></p><ul><li><p>联合建模：<br>金融机构在有<strong>存量数据的前提下，自有数据是不缺乏X特征变量，主要缺乏相应业务场景有表现特征的目标Y变量。<strong>在这个时候可以通过引进一些外部机构进行</strong>联合建模，用以补充一些Y变量。</strong></p><p>通过与外部机构<strong>联合建模得出评分，不论是将其用于内部客户分层，还是将评分分数直接做规则</strong>，都对筛选白名单有很好的帮助。</p></li><li><p>内部数据探索：</p><p>我们在筛选白名单的时候，除了通过联合建模弥补相应业务场景下目标变量的缺失，还可以通过内部数据探索，寻找分析一些对逾期违约表现相关性较强的一些特征规则，逐渐设定出白名单规则。这里面分为两种规则设定方式。</p><p>第一种是寻找与新开展业务相似模式和场景的已有产品，参照已有产品的风控策略规则对新业务场景数据进行比对分析，参照已有产品的策略规则制定出新业务场景的风控白名单规则。</p><p>另外一种方式是在更“艰苦”的环境下，没有任何可对比参照的已有产品，这个时候设定的白名单规则相对更严谨，同时对风控策略工作者的业务经验要求更高，可以认为是一种专家经验规则。</p></li><li><p>引入外部数据匹配：</p></li></ul><p>工作单位、学历、社保缴费单位、公积金缴费单位、缴费基数等信息去筛选优质客户。</p><p><strong>白名单的作用：</strong></p><ul><li>控制放量节奏：初期的时候用于控制节奏，整体调控。</li><li>降低风险</li><li>提高过审率</li><li>协助调整贷前策略：白名单筛选的过程就是贷前策略的一部分。</li></ul><h3><span id="hei-ming-dan-ce-lue"> 黑名单策略</span><a href="#hei-ming-dan-ce-lue" class="header-anchor">#</a></h3><p>黑名单：性质极其恶劣的坏客户。无论是其还款能力，还款意愿，借款目的等都不能满足正常客户的标准。</p><p>有自建和外部引用两种。对于业务初期的金融机构通常调用三方数据接口查询行内黑名单客户，同时在自家展业过程中，通过贷后管理逐渐补充、完善自家黑名单库。</p><h4><span id="hei-ming-dan-de-shi-yong"> 黑名单的使用：</span><a href="#hei-ming-dan-de-shi-yong" class="header-anchor">#</a></h4><ul><li>一般来说金融机构一旦触碰到黑名单规则，金融机构通常会全部拒绝。（全部拒绝黑名单前，会随机放过5%或者10%的触碰黑名单的客户，去测试黑名单数据有“多黑”，测试该黑名单客群是否适用于该机构。）</li><li>导流助贷机构可能会选择性放入一部分客群，结合客户评分，多头等数据综合判断，或者随机放过。（反正不是他兜底）</li></ul><h4><span id="chang-kou-ce-suan"> 敞口测算</span><a href="#chang-kou-ce-suan" class="header-anchor">#</a></h4><p>假设一个场景：如果有一万块钱，借款一年，不考虑其他，综合年化36%的信贷产品，因为一个黑名单客户导致本金全部损失，那么实际上需要大约3个好客户才能弥补1个坏客户的损失。</p><p>如果我们加上资金的运营成本，人力成本，引流成本，实际成本等。 假设需要的综合年化是15%，那么实际上 ，也就是5个好客户才能覆盖一个坏客户的本金损失，同时还需要覆盖上述的各种成本 ，也就是说金融机构大约要用6个完全的好人才能替代一个完整的坏人。</p><p>如果是3期、6期产品，同时也包含资金占有率问题，实际上需要的用更多的好人去覆盖坏客户带来的损失。</p><ul><li>假设5000  6期  36%，每个好人收益是5000×0.36/2 = 900，不算其他成本也需要5.5个人才能cover一个欺诈。（此时坏账率：1/6.5=15.4%）</li><li>实际同上假设人力、引流、IT，使得实际年华15%，每个好人收益是5000×0.15/2 = 375，需要13.3人才能cover。（坏账率1/14.3=6.99%）</li><li>PS：助贷导流客户平均成本一般不会超过5毛钱，金融机构开展信贷业务所需风控数据成本也不会超过10元。</li></ul><p>所以黑名单很重要，坏账很难搞。。。</p><h4><span id="zi-jian-hei-ming-dan"> 自建黑名单</span><a href="#zi-jian-hei-ming-dan" class="header-anchor">#</a></h4><p>黑名单一般的自建维度有<strong>参照回款表现、渠道、利率、各种公布失信类客户</strong>以及通过爬虫获得的一系列坏客户，黑名单的设定不一定仅限客户本身，也可以拓展为<strong>身份证、手机号、邮箱、银行卡、ip地址</strong>等，都可作为自建黑名单的参考维度。</p><p>和通讯记录、电话簿、二度通讯记录等联系起来。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200526130546511.png" alt="image-20200526130546511"></p><p>自建黑名单命中率通常不会太高（相同客户再次注册的概率较低），且自建黑名单库需要长期的业务积累过程，因此金融信贷机构常常需要借助三方金融科技公司的黑名单库服务（特指三方数据供应商商以及其他金融信贷机构）。</p><p>大量p2p以及小贷机构接入百行征信，但我想要说明的是：滞后性和成本的增加使得黑名单需要更多的共享，只有共享才能更全面了解我们金融机构所接触的客群。</p><h1><span id="gui-ze-yu-zhi-cutoff-ru-he-she-ding"> <strong>规则阈值cutoff如何设定</strong></span><a href="#gui-ze-yu-zhi-cutoff-ru-he-she-ding" class="header-anchor">#</a></h1><p>风险策略拒绝线的设定，背后有严谨的分析逻辑，本文就以评分分数区间和年龄规则为例，为大家讲解审批策略拒绝线的内在分析方法。</p><h2><span id="bei-jing"> 背景</span><a href="#bei-jing" class="header-anchor">#</a></h2><p>评分模型，尤其是主流基于线性Logistic算法的评分模型，<strong>对于一些边际评分区间的风险，其实常常无法精准的预估到，势必会造成一些区间风险被低估的现象。如果不通过一些规则维度的拒绝补充，容易因为模型风险发生不必要的利益损失。</strong></p><p>假设我们已经对评分模型分数分为T1-T5组，T1风险最低T5风险最大。年龄规则也使用单变量树模型初步分为5组区间。我们希望结合评分分数找到年龄规则这个核心策略维度的合理拒绝线。</p><h2><span id="di-yi-bu-tong-guo-ping-fen-zhao-dao-feng-xian-bei-di-gu-de-qu-jian"> <em>第一步：通过评分找到风险被低估的区间</em></span><a href="#di-yi-bu-tong-guo-ping-fen-zhao-dao-feng-xian-bei-di-gu-de-qu-jian" class="header-anchor">#</a></h2><p>本例中，首先将年龄与评分卡进行交叉矩阵分析，观测不同交叉区间里的用户违约概率。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525160850020.png" alt="image-20200525160850020"></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525160913346.png" alt="image-20200525160913346"></p><p>一般策略规则多数组之间的趋势线是紧密相近的。从图示数据走线可以发现，年龄组[35,47)和[47,53)这两个年龄组的违约概率走线脱离了其他分组，尤其是年龄组[35,47)，其走线脱离其他“群体”过多。通过分析初步定位年龄组[35,47)和[47,53)可以是待确定的规则拒绝线。</p><h2><span id="di-er-bu-ping-gu-ni-ju-jue-ren-qun-de-shou-yi-feng-xian-bi"> <em>第二步，评估拟拒绝人群的收益/风险比</em></span><a href="#di-er-bu-ping-gu-ni-ju-jue-ren-qun-de-shou-yi-feng-xian-bi" class="header-anchor">#</a></h2><p>虽然经过评分与年龄的交叉对比，发现年龄规则的两个待确定高风险拒绝区间。但是实际拒绝线的划分要结合年龄分组区间人群的实际收益与风险进一步考虑。<strong>如果高风险的人群可以带来高收益，对于策略来讲也是可以接受的。</strong></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525161216545.png" alt="image-20200525161216545"></p><p>将年龄分组区间按照上图示例2横轴所示指标进行统计，假设年龄分组[35,47)的收益/风险大于[47,53)且为正，即表明虽然[35,47)年龄分组的人群违约率最高，但其收益同样也是最大。反而[47,53)年龄区间的人群为公司带来负收益。</p><p>本着收益覆盖风险的商业理念，此时对于年龄这一维度的策略最佳拒绝线，应该划分在[47,53)这一分组区间。</p><h1><span id="tong-guo-lu-xia-jiang-de-ce-lue-diao-zheng"> 通过率下降的策略调整</span><a href="#tong-guo-lu-xia-jiang-de-ce-lue-diao-zheng" class="header-anchor">#</a></h1><p><strong>审批通过率</strong>和<strong>不良率</strong>是一对<strong>权衡指标</strong>，在新业务<strong>上线初期，维持一个较低的通过率可以保证最好的客群进去。<strong>随着业务规模</strong>做大和风控样本积累，此时需要在风险容忍度可接受范围内提升通过率，以保持收益的最大化。</strong></p><p>如果某一天风控通过率忽然降低，这种情况下策略分析人员应该如何应对？</p><h2><span id="1-xun-zhao-tong-guo-lu-xia-jiang-de-shi-jian-dian-huo-shi-jian-duan"> 1.寻找通过率下降的时间点或时间段</span><a href="#1-xun-zhao-tong-guo-lu-xia-jiang-de-shi-jian-dian-huo-shi-jian-duan" class="header-anchor">#</a></h2><p>在风控策略稳定之后，审批通过率一般稳定在某一小范围内波动，当监控每日通过率指标时发现，T-1、T-2时点的通过率明显下降，我们应该先通过监控报表迅速定位到具体时间点或时间段。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525161544954.png" alt="image-20200525161544954"></p><p>2019.6.23和6.24授信通过率下降。</p><p>Tip：上图示例通过率下降到6.9%、7.0%可以直接用肉眼分辨数据，但实际业务一般建议以通过率趋势图和PSI指标监控通过率下降。</p><h2><span id="2-pan-duan-ce-lue-jie-dian-zhu-ci-yao-ju-jue-ying-xiang"> 2.判断策略节点主次要拒绝影响</span><a href="#2-pan-duan-ce-lue-jie-dian-zhu-ci-yao-ju-jue-ying-xiang" class="header-anchor">#</a></h2><p>发现通过率下降的时间点或时间段之后，下一步先聚焦到策略节点。本文为FALers举例两个策略节点A（准入）和B（规则）。以6月23日为时间节点划分，对比数据分析，寻找拒绝率的波动差。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525162143545.png" alt="image-20200525162143545"></p><p>上图示例2中波动差按照B段A节点拒绝率-A段A节点拒绝率计算出来，以此类推。此时计算波动差仍然可以考虑加入PSI=(B-A)*LN(B/A)测算波动差,A节点的PSI为0.77%，B节点的PSI为0.01%。</p><p>按照波动差确定通过率的下降主要因为A节点的拒绝率上升引起，从而将通过率下降的影响因素从策略A和B两个节点问题进一步聚焦到A节点上。</p><h2><span id="3-cong-jie-dian-ju-jiao-dao-jie-dian-gui-ze-ceng-shen-du-fen-xi"> <em>3.从节点聚焦到节点规则层深度分析</em></span><a href="#3-cong-jie-dian-ju-jiao-dao-jie-dian-gui-ze-ceng-shen-du-fen-xi" class="header-anchor">#</a></h2><p>完成节点的聚焦分析，定位到引起通过率下降的主要原因节点A，接下来需要进一步分析节点A内包含的所有规则拒绝情况。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525162807285.png" alt="image-20200525162807285"></p><p>与节点聚焦分析一致，寻找引起拒绝率上升的主次要拒绝规则。在规则层确定主次要影响因子时，分析方法不仅结合数据同时也参考业务场景。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163158091.png" alt="image-20200525163158091"></p><p>从上图示例4可以发现，按照波动差分析得出年龄准入拒绝和X3_准入拒绝是主要引起通过率下降的规则。</p><h2><span id="4-ju-ti-gui-ze-fen-bu-fen-xi"> <em>4.具体规则分布分析</em></span><a href="#4-ju-ti-gui-ze-fen-bu-fen-xi" class="header-anchor">#</a></h2><p>从步骤3确定出年龄准入拒绝是第一位引起通过率下降的规则后，第四步就从规则层聚焦到具体策略规则的分布上。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163345465.png" alt="image-20200525163345465"></p><p>通过分析具体策略规则分布的波动差定位具体策略规则的某一分布，找出引起通过率下降的主要策略分布。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525162923974.png" alt="image-20200525162923974"></p><p>从上图示例6可以发现，年龄准入拒绝这一策略规则中，18-25岁的分布拒绝率在时间A段和时间B段的波动差最大，这个年龄分布的拒绝率上升可能是引起整个审批通过率下降的主要规则分布。</p><p>造成以上18-25岁年龄分布拒绝增加的原因，很常见的一种是进件客群发生了变化，针对客群发生突然变化的情况，如何将分析结果指导决策执行，是策略分析最后且最重要的一步。</p><h2><span id="5-fen-xi-zhi-dao-jue-ce"> <em>5.分析指导决策</em></span><a href="#5-fen-xi-zhi-dao-jue-ce" class="header-anchor">#</a></h2><p>仍以上述案例为例，通过一系列聚焦分析发现，18-25岁的进件客群变化是引起整体通过率下降的核心因素。实际业务场景中，并不会因为此时通过率突降就进行策略规则的调整，更多的是通过聚焦分析后，结果进一步细分两个参照要素：进件渠道的进件量分布和最大进件渠道的年龄准入拒绝分布。</p><p><em>5.1.进件渠道分布分析</em></p><p>既然是客群的变化引起了整体审批通过率的下降，从进件的所有渠道数据中进行分布排序，定位到渠道进件量A段和B段都最大的一个进件渠道C。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163500790.png" alt="image-20200525163500790"></p><p><em>5.2.最大进件渠道的年龄准入拒绝分布</em></p><p>通过进件渠道进件量分析，从众多进件渠道中定位到最大进件渠道C。此时分析主要拒绝规则-年龄准入拒绝的渠道C的分布情况，是否满足条件：B段与A段年龄18-25岁的波动变高。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163605116.png" alt="image-20200525163605116"></p><p>从上图示例8中分析发现，渠道C年龄在18-25岁的客群进件量在B段比A段上升明显，即从渠道进件前段业务确定出引起通过率降低的主要进件渠道C。至此，可以进行策略分析决策建议。</p><p><em>5.3.决策建议</em></p><p>将策略分析结果应用于前段业务指导和决策，提醒前端业务人员在渠道C可以适当缩紧18-25岁客群的进件需求，以此共同维护金融公司整体风控通过率，这才是风控策略分析工作者最终的使命和义务。</p><h1><span id="yu-qi-lu-shang-sheng-de-ce-lue-diao-zheng"> 逾期率上升的策略调整</span><a href="#yu-qi-lu-shang-sheng-de-ce-lue-diao-zheng" class="header-anchor">#</a></h1><p>当逾期升高时，如何进行策略调优。</p><p>真实案例背景（数据已脱敏）：</p><p>通过PQR监控报表发现，某XX贷产品的MOB报表自2019年5月开始，后续放款月资产逾期呈上升趋势，既DPD30+逐月上升，且上升速度逐步增快（MOB期数逐渐缩短）。在2019年11月放款的客户里，MOB=4的DPD30+等于2.49%。如下图1所示。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163737375.png" alt="image-20200525163737375"></p><p>通过将MOB制作成Vintage报表，可以观测到某XX贷产品的风险自2019年5月到11月的DPD30+平均值位于6%的水平，如下图2所示。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525163801595.png" alt="image-20200525163801595"></p><p>往期DPD30+表现出的风险水平逐月快速上升现象，意味着如果不做相应的策略调整，之后的放款月风险将会更快的暴露。</p><p><strong>针对此时逾期快速上升的背景下，如何分析策略，进行策略调整呢？</strong><br><strong>策略分析方法</strong></p><h2><span id="di-yi-bu-que-ding-cun-liang-huan-shi-xin-zeng-ke-hu-dao-zhi-yu-qi-shang-sheng"> <strong>第一步：确定存量还是新增客户导致逾期上升</strong></span><a href="#di-yi-bu-que-ding-cun-liang-huan-shi-xin-zeng-ke-hu-dao-zhi-yu-qi-shang-sheng" class="header-anchor">#</a></h2><p>信贷业务每个月发生授信和放款的客户可以分成新增客户和存量客户。从上图示例2中Vintage报表展现的数据，反映出资产逾期呈上升趋势。那我们首先需要将2019年5月到2019年11月（可观测到DPD30+）的Vintage分成新增客户的Vintage1和存量客户的Vintage2，如下图3。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525164330196.png" alt="image-20200525164330196"></p><p>从上图3的Vintage1（新客户）和Vintage2（存量客户）标注的红色椭圆框可以观测到，新客户的DPD30+平均处于6%，存量客户的DPD30+平均处于5%。与图示1对比可以分析出，导致资产逾期上升的主要原因是新增客户资产变差的影响。</p><p>至此阶段的分析结论：我们可以确定出需要调整的策略规则是贷前规则。</p><p>解释如下：往期放款月中，新客户是由贷前规则通过后，给予授信并放款的，存量客户的复借是由贷中规则决定。通过Vintage1和2的分析比对，引起资产逾期上升的主要原因是新客户的逾期上升。</p><h2><span id="di-er-bu-duo-wei-du-fen-xi-zhao-chu-zui-zhu-yao-ying-xiang-gui-ze"> <strong>第二步：多维度分析，找出最主要影响规则</strong></span><a href="#di-er-bu-duo-wei-du-fen-xi-zhao-chu-zui-zhu-yao-ying-xiang-gui-ze" class="header-anchor">#</a></h2><p>通过第一步的分析确定出核心要调整的是贷前策略后，我们接下来要通过分析不同的规则变量，找出对目标变量（DPD30+）影响最大的维度变量。</p><p>这里提供分析主要影响变量的两个思路，具体实践过程就不在这里多讲，文末推荐阅读有链接。</p><p>思路一：自上而下地按照A类策略调优方法，从贷前策略节点到节点里的规则集，再细分到具体规则，逐步分析出影响较大的规则变量（文末推荐阅读给出具体分析的往期文链接）</p><p>思路二：自下而上地将所有规则变量与目标变量拟合分析，通过IV的降序排序，找出影响较大的规则变量。</p><p>分析得出，城市等级是影响逾期目标上升的主要变量。通过分析2019年5月至11月的城市等级Vintage曲线，可以发现“其他城市”较“一线城市”、“二线城市”、“三线城市“对逾期的影响较大，如下图。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525165245788.png" alt="image-20200525165245788"></p><h2><span id="di-san-bu-zhi-ding-ce-lue-diao-zheng-fang-an"> <strong>第三步：制定策略调整方案</strong></span><a href="#di-san-bu-zhi-ding-ce-lue-diao-zheng-fang-an" class="header-anchor">#</a></h2><p>通过上述数据分析，发现贷前风控规则里的“城市等级”规则”其他城市“是导致逾期升高的主要原因。此时容易出现的一个错误决策是拒绝“其他城市”的进件。</p><p>原因很简单：这种决策会导致大量的申请被拒绝，对通过率的影响比较大。</p><p>最优的策略调整方案思路是：从“坏客户”中挑选出“最坏”的一批客户，且这批客户的占比较少，然后加以拒绝。</p><p>按照上述思路，我们可以制定出如下的策略优化方案：</p><p>1、进一步分析“其他城市”里，哪一些的城市逾期较高；</p><p>2、挑选部分逾期较高的城市做贷前准入规则。</p><p>以上，就是逾期升高情况下，策略调优的分析方法。</p><h1><span id="xin-yong-duo-tou-ce-lue"> 信用多头策略</span><a href="#xin-yong-duo-tou-ce-lue" class="header-anchor">#</a></h1><p>金融风险管理中，对于一个借款人还款能力的评估十分重视。如果一个人的资产负债比过大，一旦发生资不抵债的现象，金融机构继续对其发放贷款发生违约的风险是极大的。</p><p>在体现借款人甚至借款企业还款能力的众多指标中，多头借贷是一项核心指标。</p><h2><span id="1-shi-me-shi-duo-tou-jie-dai"> <strong>1.什么是多头借贷</strong></span><a href="#1-shi-me-shi-duo-tou-jie-dai" class="header-anchor">#</a></h2><p>多头借贷是指单个借款人向2家或2家以上的金融机构提出借贷需求的行为。多头借贷数据一般至少会粗分成银行类多头借贷、非银类多头借贷。按时间跨度可以分为近7天、近15天、近1个月、近3个月、近6个月、近12个月。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170055587.png" alt="image-20200525170055587"></p><p>多头借贷除了会统计申请次数，还会统计申请机构数、申请最大间隔天数、申请最小间隔天数、申请记录月份、平均每月申请次数(有申请月份平均)、最大月申请次数、最小月申请次数等。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170130273.png" alt="image-20200525170130273"></p><p>由于单个用户的偿还能力是有限的，向多方借贷必然蕴含着较高的风险。一般来说，当借贷人出现了多头借贷的情况，说明该借贷人资金出现了较大困难，有理由怀疑其还款能力。</p><h2><span id="2-duo-tou-jie-dai-shu-ju-de-fen-xi-fang-fa"> <strong>2.多头借贷数据的分析方法</strong></span><a href="#2-duo-tou-jie-dai-shu-ju-de-fen-xi-fang-fa" class="header-anchor">#</a></h2><p>由于多头借贷可以比较有效的反应借款人的还款能力，所以在对借款人信用风险、欺诈风险评估上，基本都有使用多头借贷数据。</p><p>多头借贷作为一个衡量借款人的维度特征，可以结合一些逾期指标进行分析。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170208464.png" alt="image-20200525170208464"></p><p>上图示例1中，对近7天非银机构申请机构平台数进行分析，对申请不同平台数的客户，分别统计客群的分布占比、FPD30%、FPD30-DPD90+%、通过单量、FPD30单量、DPD90+单量以及DPD90+%。通过统计后的数据，分析近7天申请N平台数的客户，其不同逾期指标的变化趋势，如上图示例1中FPD30%的增幅，进一步用于寻找策略切点或者豁免客群的回顾分析。</p><h2><span id="3-duo-tou-jie-dai-shu-ju-wei-he-shao-yong-yu-mo-xing"> <strong>3.多头借贷数据为何少用于模型</strong></span><a href="#3-duo-tou-jie-dai-shu-ju-wei-he-shao-yong-yu-mo-xing" class="header-anchor">#</a></h2><p>多头借贷少出现在模型变量中，主要有两个方面原因。</p><p>第一，多头借贷数据往往被策略同事应用于规则中。</p><p>数据建模的目的是从金融弱变量中通过特征工程方法，提炼出有效区分变量，构建评分模型。所以对于多头借贷数据，既然已经运用在策略规则中，实在没必要加入到模型变量。如果读者朋友们看到提交的评分模型报告中有多头借贷变量，那么建模的同事要么没有事先了解已上线运行的策略规则集，要么就是为了模型表现指标（如KS、AR、AUC）好看强行使用。</p><p>第二，多头借贷数据往往覆盖度不全。</p><p>多头借贷虽然是一个与风险强关联的维度，但其查得率一直被人所诟病。</p><p>举一个例子，借款人一个月内在多家机构贷款，作为一个特征，很有可能出现某个人虽然频繁贷款，但并没有被多头供应商捕捉到。一旦这个特征作为模型变量，那么这个变量的噪声就很大了。反而如果做成反欺诈策略，就不需要担心噪声问题，直接选取拒绝线进行截断，最大的影响，也就是没有拒绝掉足够多的用户，而这个影响我们还可以用噪声较小的模型进行弥补。</p><h2><span id="4-duo-tou-jie-dai-shu-ju-zai-ce-lue-gui-ze-shang-de-ying-yong"> <strong>4.多头借贷数据在策略规则上的应用</strong></span><a href="#4-duo-tou-jie-dai-shu-ju-zai-ce-lue-gui-ze-shang-de-ying-yong" class="header-anchor">#</a></h2><p>多头借贷在策略上一般作为一条策略规则，一个拒绝维度参与到整个风控流程中。不同机构，不同信贷产品，不同场景，对于多头借贷的拒绝线划分都是不一样的。如何找到当下最适合的多头借贷拒绝线，对于风控策略分析人员，是风控工作的核心任务。</p><p>仍以上图示例1为例，假设当前对于7天多平台数规则的拒绝线划分在6，即如果7天多平台数&gt;=7则拒绝。如果我们现在希望通过7天多平台数规则豁免一部分客群提升整体通过率，此时的拒绝线cutoff应该划分在哪里呢？</p><p>如果不是应对紧急调整通过率的情况，我们可以事先豁免7天多平台数7-10的客户，作为测试样本，用以产生7-10客群通过单量的分布，之后将拒绝线调回6。既可以生成如下统计分析表：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170257437.png" alt="image-20200525170257437"></p><p>上图示例2中的桔色部分都是通过分析预测出来，比如通过上图示例1中不同多平台数FPD30%的平均增幅0.7%，预测出7-10的FPD30%。</p><p>预估计算公式8FPD30%=7FPD30%+0.7%。进一步计算出FPD30量、DPD90量等其他指标。</p><p>提醒读者朋友们，因为我们对于资产风险管控最关心的逾期指标还是不良率，所以我们通过FPD30-DPD90+%的迁徙率预测出不同7天多平台数的DPD90+%。对于7-10的FPD30-DPD90+%预估，可以采用MAX(0-6的FPD30-DPD90+%)的预估方法。</p><p>在这之后，我们对于不同7天多平台数测算出拒绝线Cutoff的FPD%和DPD%，如下图所示：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170317997.png" alt="image-20200525170317997"></p><p>对比示例图1和图3的Cutoff_DPD%可以发现，规则拒绝线设定在&gt;=7时DPD%=3.0%，设定在&gt;=8时DPD%=3.0%，设定在&gt;=9时DPD%=3.3%。规则拒绝线设定在&gt;=8的DPD%并没有增加。此时可以尝试建议将7天多平台数的拒绝线调整到7。</p><p>当然，这种策略分析方法仍有一些纰漏，比如此方法需要有测试样本进行观测，无法满足快速调整通过率的需求；7天多平台数的FPD30%的增幅实际情况并非线性增长，有经验的策略分析师知道，FPD30%一定会在某一个节点指数级增长。</p><p>但正是因为策略分析师通过不断地按照上述方法进行样本测试对照，根据实际情况回顾分析结果，才能不断的积累策略调整经验，才会对规则分布具有一定敏感性。</p><h1><span id="ping-fen-de-ce-lue-ying-yong"> 评分的策略应用</span><a href="#ping-fen-de-ce-lue-ying-yong" class="header-anchor">#</a></h1><h3><span id="ping-fen-qia-mo-xing-de-yun-yong-zhu-yao-shi-wei-liao-jie-jue-liang-da-wen-ti"> 评分卡模型的运用，主要是为了解决两大问题：</span><a href="#ping-fen-qia-mo-xing-de-yun-yong-zhu-yao-shi-wei-liao-jie-jue-liang-da-wen-ti" class="header-anchor">#</a></h3><p>1、线上借贷业务量逐渐增加的情景下，<strong>策略规则已经无法满足更细的切分需求</strong>；</p><p>2、对于策略无法有效识别的<strong>大量灰色客群，需要使用评分卡进行风险判断</strong>；</p><p>现如今业界使用评分卡模型，更多的是为了解决第二个问题。</p><p>从金融机构自身业务发展历程来看，评分卡模型介入风险管理流程常常取决于两个重要的时机：</p><p>1、业务快速发展阶段</p><p>在金融机构业务发展的早期阶段，因为业务量小、样本少、风险控制严格等一些主客观原因，使用风控策略规则足以开展业务，所以在业务发展早期评分模型基本没有任何用武之地。</p><p>但随着信贷产品的测试期结束，金融机构要加快业务发展，此时不论是大量的客群样本、逾期表现的积累，还是风险控制的政策放松，都因为风险策略无法精准细分的局限性，而需要评分模型的介入，评分卡的应用场景更适用于人工分流。</p><p>此阶段的评分模型，常常表现不稳定，比如<strong>KS波动较大，Lift下降较快，PSI时常过0.1</strong>。此阶段评分模型的优化更多在于分析波动原因，快速重新开发迭代。</p><p>2、业务发展稳定阶段</p><p>一旦金融机构度过了新产品的早期和发展期，此时产品市场表现已经趋向稳定，反应在客群分析上，表现出稳定层级的客户画像，此阶段是评分模型介入2.0阶段。</p><p>在这个阶段评分模型会在风控流程节点上进行一些调整，比如<strong>申请卡模型会进一步的前置，担当部分客群豁免的功能。同时，此时评分模型介入2.0阶段也会降低一些外部征信数据调用成本，控制因三方数据有误而引起的误杀。</strong></p><p>此阶段的评分模型，表现较为<strong>稳定，KS、Lift、PSI等指标波动较小，对于评分卡的迭代开发需求降低</strong>，评分卡的应用更加与业务需求、金融政策以及企业发展战略相关，在保证评分模型稳定性及相对精准度的前提下，使用模型调整系数进行全局模型的调整是此阶段的主要优化办法。</p><h2><span id="ping-fen-mo-xing-de-cutoff"> 评分模型的cutoff</span><a href="#ping-fen-mo-xing-de-cutoff" class="header-anchor">#</a></h2><p>评分卡分数转换出来，在不同业务发展阶段如何合理的制定评分的cutoff，是评分应用重要的一步。</p><p>一般将评分等分后，会有两种方式对评分进行cutoff：一种是参照KS和Cum % bad rate,另一种根据等分后的累计净收益。</p><p>第一种参照Max KS和累积bad rate理论上是可以尽可能的将坏客户剔除，对好客群进行授信，但无法根据业务发展需要保证收益最大化。参照不同业务发展阶段的需求，根据评分对收益损失预估，最终确定评分cutoff，我认为这才是精细化的评分应用策略。</p><p>第二种制定评分的cutoff，需要联动分析以下图示的一些指标</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525170640285.png" alt="image-20200525170640285"></p><p>通过逆向累计净收入指标的分析，结合当下风控政策，综合评定评分的cutoff，将之应用在风控策略上，这样才是更接近业务的评分cutoff。</p><h1><span id="mo-xing-yu-ce-lue-de-guan-xi"> 模型与策略的关系</span><a href="#mo-xing-yu-ce-lue-de-guan-xi" class="header-anchor">#</a></h1><p>评分模型在金融信贷风控领域的应用非常广泛，模型的开发、监控也趋于标准化。</p><p><strong>评分模型可以为每一位观测对象打出一个评分分数</strong>，理论上实现风险与定价的绝对对等，实现<strong>个体差异化的风险管理，在这点上，风险策略规则是远不可及的。</strong></p><h2><span id="mo-xing-shi-fou-ke-yi-ti-dai-suo-you-de-ce-lue-gui-ze"> 模型是否可以替代所有的策略规则?</span><a href="#mo-xing-shi-fou-ke-yi-ti-dai-suo-you-de-ce-lue-gui-ze" class="header-anchor">#</a></h2><p>此时就有了风险策略与模型之间的争议：<strong>模型是否可以替代所有的策略规则？（排除政策准入规则）</strong></p><p>想要回答上述的争议，首先需要了解目前策略规则与模型在风控决策体系里的应用架构。目前我所见到有两种主流的风控决策应用架构：<strong>策略规则+评分模型 &amp; 策略规则+模型规则。</strong></p><h3><span id="ce-lue-gui-ze-ping-fen-mo-xing"> 策略规则+评分模型</span><a href="#ce-lue-gui-ze-ping-fen-mo-xing" class="header-anchor">#</a></h3><p>前者策略规则和评分模型是分开的，一般风控流程是先进行策略规则的风险判断，再进入评分模型的风险识别；</p><h3><span id="ce-lue-gui-ze-mo-xing-gui-ze"> 策略规则+模型规则</span><a href="#ce-lue-gui-ze-mo-xing-gui-ze" class="header-anchor">#</a></h3><p>后者是将评分模型的预测概率（或分数）转变为一个策略规则，与其他策略规则融合在一起进行风险决策。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525171048451.png" alt="image-20200525171048451"></p><h3><span id="ce-lue-gui-ze-de-cu-fang-shi-guan-li"> <strong>策略规则的粗放式管理</strong></span><a href="#ce-lue-gui-ze-de-cu-fang-shi-guan-li" class="header-anchor">#</a></h3><p>策略规则作为一种风险识别的方法，其自身具有直观、易用等特性。对于新产品上线前的风险决策，因为没有数据样本的原因，策略规则在<strong>风险决策初期起到不可替代作用</strong>。但也因为策略规则的设定原理，其自身<strong>很难做到风险决策的精细化管理。</strong></p><p>以上图风险决策B为例，可以看出策略规则都是XXXX&gt;xxx，这种单维度的风险判断是存在一定的取舍。比如某金融机构的一条多头借贷策略规则设定为：<strong>多头借贷平台数&gt;5则执行拒绝，那多头借贷=6的申请客户，就一定会违约吗？</strong></p><p>说到这里可能会有读者朋友质疑：我可以设定一些策略规则组合起来判断。没错，这也是风险决策体系下策略规则应用的一种方式，但不论多少维度的组合判断，都必然会对单一维度策略规则进行True or False判断。比如上例中的策略规则变为：多头借贷&gt;5 或 多头借贷&gt;6且性别为男性，则执行拒绝。此时对于多头借贷=6的女性不会拒绝，但对于多头借贷=7且有一定储蓄的男性，就一定会违约吗？</p><p>可以看出，如果希望通过策略规则的组合实现精细化的风险管理，就会不断地增加策略规则，最终导致策略规则的复杂和冗余，对于策略优化、回顾并没有正向的影响，这与策略规则的易用、直观等特性产生了矛盾。</p><h2><span id="ping-fen-mo-xing-de-chang-jian-san-chong-mang-qu"> <strong>评分模型的常见三种盲区</strong></span><a href="#ping-fen-mo-xing-de-chang-jian-san-chong-mang-qu" class="header-anchor">#</a></h2><p>由于策略规则的先天性缺陷，评分模型的出现可以恰当的弥补策略规则的不足，但并不意味着评分模型可以完全替代所有的策略规则。其原因有风控流程的考虑、业务发展的考虑等，在本文我为大家从模型自身的盲区为大家作解释。</p><h3><span id="jian-mo-shu-ju-ji-yu-shi-ji-dai-kuan-ren-zhi-jian-cun-zai-pian-chai"> <strong>建模数据集与实际贷款人之间存在偏差</strong></span><a href="#jian-mo-shu-ju-ji-yu-shi-ji-dai-kuan-ren-zhi-jian-cun-zai-pian-chai" class="header-anchor">#</a></h3><p>在中国因为征信体系的不完善，金融机构的模型一般以实际贷款人作为模型数据集，而申请人母集到贷款人子集往往发生较大变化（就算是大家熟知的拒绝推断也只能尽量弥补但不能完全拒绝这方面的误差），模型的判断就会出现一些偏差，此时需要根据策略维度的一些拒绝线，对模型进行一些矫正和保护。</p><h3><span id="mo-xing-shu-ju-ji-lai-zi-li-shi-yu-wei-lai-shi-ji-qing-kuang-cun-zai-pian-chai"> <strong>模型数据集来自历史，与未来实际情况存在偏差</strong></span><a href="#mo-xing-shu-ju-ji-lai-zi-li-shi-yu-wei-lai-shi-ji-qing-kuang-cun-zai-pian-chai" class="header-anchor">#</a></h3><p>模型是基于历史数据找到数据之间的逻辑规律后，对未来事件进行预测。对于具有周期性的金融行业，如果用处于上升期的数据模型预测金融衰退期的事件，必然会与实际情况发生偏差。</p><p>举个例子，比如在经济上升或者繁荣期，消费者不仅有工作的单一收入，消费者可以从一些兼职等渠道获取额外的收入来源，此时即使有较高负债收入比的客群仍然可以维持较好的信用表现；但当经济开始进入下滑时期，未来消费者很难继续从其他渠道获取资金，即使历史数据告诉模型、模型告诉决策人，此时的借贷申请人有还款能力和意愿，但商业风险决策者应考虑收紧对于较高负债收入比人群的贷款。</p><h3><span id="mo-xing-dui-yu-mu-biao-bian-liang-de-jie-ding-yu-shi-ji-shang-ye-mu-biao-cun-zai-pian-chai"> <strong>模型对于目标变量的界定与实际商业目标存在偏差</strong></span><a href="#mo-xing-dui-yu-mu-biao-bian-liang-de-jie-ding-yu-shi-ji-shang-ye-mu-biao-cun-zai-pian-chai" class="header-anchor">#</a></h3><p>模型为了权衡观察期的代表性和表现期的时效性，在建模时为了囊括最近的贷款数据，在界定“坏账”定义时，仅考虑前12个月的还款表现（有时仅考虑前6个月），此时对于一些中额长期的信贷产品（比如24个月、36个月），模型目标变量的界定与实际商业目标就发生了偏差。</p><p>综上，从反面辩证性的角度分析模型与策略，二者缺一不可，谁也不可能完全替代对方。通过科学地搭配，共同构架起严谨的风险决策体系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#feng-kong-ce-lue-gai-yao&quot;&gt;风控策略概要&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#shi-me-shi-feng-kong
      
    
    </summary>
    
    
      <category term="risk" scheme="https://blog.sofunnyai.com/categories/risk/"/>
    
    
      <category term="risk" scheme="https://blog.sofunnyai.com/tags/risk/"/>
    
      <category term="strategy" scheme="https://blog.sofunnyai.com/tags/strategy/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件03---Hystrix实践</title>
    <link href="https://blog.sofunnyai.com/article/springcloud-H-03-hystrix.html"/>
    <id>https://blog.sofunnyai.com/article/springcloud-H-03-hystrix.html</id>
    <published>2020-03-23T09:34:41.000Z</published>
    <updated>2020-06-15T03:13:17.201Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#rxjava-kuai-su-ru-men">RxJava快速入门</a><ul><li><a href="#ji-ben-gai-nian">基本概念</a></li><li><a href="#chuang-jian-liu-cheng">创建流程</a><ul><li><a href="#observer-guan-cha-zhe">Observer观察者</a></li><li><a href="#observable-bei-guan-cha-zhe-shi-jian-yuan">Observable 被观察者(事件源)</a></li></ul></li></ul></li><li><a href="#jian-jie">简介</a></li><li><a href="#gai-nian">概念</a><ul><li><a href="#fu-wu-rong-duan">服务熔断</a></li><li><a href="#fu-wu-jiang-ji">服务降级</a><ul><li><a href="#rong-duan-jiang-ji-de-guan-xi">熔断、降级的关系</a></li><li><a href="#jiang-ji-fang-shi">降级方式</a></li></ul></li><li><a href="#fu-wu-xian-liu">服务限流</a></li><li><a href="#ru-he-shi-xian-de">如何实现的：</a><ul><li><a href="#shang-tu-de-bu-zou">上图的步骤</a></li></ul></li><li><a href="#ge-chi-de-shi-xian">隔离的实现</a><ul><li><a href="#xian-cheng-chi-ge-chi-mo-shi">线程池隔离模式：</a></li><li><a href="#xin-hao-liang-ge-chi-mo-shi">信号量隔离模式：</a></li></ul></li><li><a href="#rong-duan">熔断</a></li></ul></li><li><a href="#hystrix-yuan-ma">Hystrix源码</a><ul><li><a href="#hystrixcommand-lei-tu">HystrixCommand类图</a></li><li><a href="#hystrixobservablecommand-lei-tu">HystrixObservableCommand类图</a><ul><li><a href="#hystrixcommand-he-hystrixobservablecommand">HystrixCommand和HystrixObservableCommand</a></li></ul></li><li><a href="#duan-lu-qi-hystrixcircuitbreaker">断路器HystrixCircuitBreaker</a></li><li><a href="#ge-chi">隔离</a></li></ul></li><li><a href="#pei-zhi-can-shu">配置参数</a></li></ul><!-- tocstop --></div><p>因为Hystrix大量使用到观察者模式和RxJava，所以需要补充相关知识。</p><p>观察者模式可以看这里：《》</p><p>下面是RxJava的快速入门</p><h1><span id="rxjava-kuai-su-ru-men"> RxJava快速入门</span><a href="#rxjava-kuai-su-ru-men" class="header-anchor">#</a></h1><h2><span id="ji-ben-gai-nian"> 基本概念</span><a href="#ji-ben-gai-nian" class="header-anchor">#</a></h2><p>RxJava 有四个基本概念：</p><ul><li><p><code>Observable</code> (可观察者，即<strong>被观察者</strong>)、 <code>Observer</code> (观察者)、 <code>subscribe</code> (订阅)、<code>Event</code>事件。<code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。这里的事件就是对依赖的服务进行调用。</p></li><li><p>一个Observable可以发出多个事件，直到结束或者发生异常。</p></li><li><p><code>Observable</code>每次发出一个事件就会调用<code>Subscriber</code>对象的<code>onNext()</code>方法。</p></li><li><p>每一个Observable的执行，最后都会通过调用一个<code>Subscriber.onComplete()</code>或者<code>Subscriber.onError()</code>结束事件的操作流。</p></li><li><p>RxJava 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 <code>onClick()</code> / <code>onEvent()</code>）之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p></li><li><p><code>onCompleted()</code>: <strong>事件队列完结</strong>。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为标志。</p></li><li><p><code>onError()</code>: <strong>事件队列异常</strong>。在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。</p></li><li><p>在一个正确运行的事件序列中, <code>onCompleted()</code> 和 <code>onError()</code> <strong>有且只有一个</strong>，并且<strong>是事件序列中的最后一个</strong>。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是<strong>互斥</strong>的，即在队列中调用了其中一个，就不应该再调用另一个。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200603184440919.png" alt="image-20200603184440919"></p></li></ul><h2><span id="chuang-jian-liu-cheng"> 创建流程</span><a href="#chuang-jian-liu-cheng" class="header-anchor">#</a></h2><h3><span id="observer-guan-cha-zhe"> Observer观察者</span><a href="#observer-guan-cha-zhe" class="header-anchor">#</a></h3><p>观察者，它决定事件触发的时候将<strong>有怎样的行为</strong>。有两种方式，直接创建<code>Observer</code>接口，或者从抽象类<code>Subscriber</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Subscriber</code>和上面的<code>Observer</code>二者只是抽象类提供了更多的拓展方法（<code>onStart</code>和<code>unsubscribe</code>）而已，创建过程是一样的。</p><h3><span id="observable-bei-guan-cha-zhe-shi-jian-yuan"> Observable 被观察者(事件源)</span><a href="#observable-bei-guan-cha-zhe-shi-jian-yuan" class="header-anchor">#</a></h3><p>决定<strong>什么时候触发事件</strong>以及<strong>触发怎样的事件</strong>。 RxJava 使用 <code>create()</code> 方法来创建一个 Observable ，并为它定义事件触发规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表:</p><ul><li><p><strong>当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用</strong></p></li><li><p>事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。</p></li><li><p>这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p></li></ul><blockquote><p>这里只是最简单的一个例子，事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。</p></blockquote><h1><span id="jian-jie"> 简介</span><a href="#jian-jie" class="header-anchor">#</a></h1><p>官网</p><blockquote><p><a href="https://github.com/Netflix/hystrix" target="_blank" rel="noopener">https://github.com/Netflix/hystrix</a></p></blockquote><p>因为调用链路越来越长，当某个微服务挂了，可能造成整个调用链路的请求拥挤和挂起，导致更多服务down掉，最终形成服务雪崩。</p><p>Hystrix是用于处理分布式系统的<strong>延迟</strong>和<strong>容错</strong>开源库，在超时、异常等场景下，Hystrix保证在一个依赖出问题的情况下，不会导致整体集群集体失败、避免级联故障、提高分布式系统的弹性</p><p>断路器是一种开关装置。实现快速失败，<strong>服务失败后，通过服务的故障监控，向调用方发送一个预期的、可处理的备选FallBack反馈，而不是长时间挂起或者抛出异常。</strong></p><p>这样保证了服务调用方的线程不会长时间挂起、不必要的等待，避免了故障的蔓延和雪崩。</p><p>造成雪崩原因可以归结为以下三个：</p><ul><li>服务提供者不可用（硬件故障，程序Bug，缓存击穿，用户大量请求）</li><li>重试加大流量（用户重试，代码逻辑重试）</li><li>服务调用者不可用（同步等待造成的资源耗尽）</li></ul><p>最终的结果就是一个服务不可用导致一系列服务的不可用，而往往这种后果往往无法预料的。</p><h1><span id="gai-nian"> 概念</span><a href="#gai-nian" class="header-anchor">#</a></h1><h2><span id="fu-wu-rong-duan"> 服务熔断</span><a href="#fu-wu-rong-duan" class="header-anchor">#</a></h2><p>一般是指软件系统中，<strong>由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施</strong>，所以很多地方把熔断亦称为过载保护。</p><h2><span id="fu-wu-jiang-ji"> 服务降级</span><a href="#fu-wu-jiang-ji" class="header-anchor">#</a></h2><p>划分优先级，忍痛割爱。整体资源快不够了，忍痛将某些服务先关掉，待渡过难关，再开启回来。对方不可用的时候，给一个可预期的备选兜底FallBack。</p><p>什么时候会降级：<strong>程序异常/超时/熔断触发/线程池、信号量打满</strong></p><p>要在<strong>调用方做降级</strong>（不然那个微服务都down掉了再做降级也没什么意义了） 比如说我们 user 调用payment 那么就在user 做降级.</p><h3><span id="rong-duan-jiang-ji-de-guan-xi"> 熔断、降级的关系</span><a href="#rong-duan-jiang-ji-de-guan-xi" class="header-anchor">#</a></h3><p>二者的目标是一致的，目的都是保证上游服务的稳定性。但其关注的重点并不一样，融断对下层依赖的服务并不级（或者说孰轻孰重），一旦产生故障就断掉；而降级需要对下层依赖的业务分级，把产生故障的丢了，换一个轻量级的方案，是一种退而求其次的方法。<br>根据业务场景的不同，一般采用以下两种模式：</p><h3><span id="jiang-ji-fang-shi"> 降级方式</span><a href="#jiang-ji-fang-shi" class="header-anchor">#</a></h3><p>第一种（最常用）如果服务失败，则我们通过fallback进行降级，返回静态值。</p><ul><li>fallback进行降级，返回静态值：</li></ul><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200602153749926.png" alt="image-20200602153749926"></p><ul><li>级联方式降级：</li></ul><p>如果第一个服务失败，则调用备用服务，例如失败重试或者访问缓存失败再去取数据库。</p><p>服务级联的目的则是尽最大努力保证返回数据的成功性，但如果考虑不充分，则有可能导致级联的服务崩溃（比如，缓存失败了，把全部流量打到数据库，瞬间导致数据库挂掉）。</p><p>因此级联模式，也要慎用，增加了管理的难度。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602153858394.png" alt="image-20200602153858394"></p><p>Hystrix执行以下操作：</p><ul><li>提供保护并控制通过第三方客户端库访问（通常是通过网络）的依赖项带来的延迟和失败。</li><li>停止复杂的分布式系统中的级联故障。</li><li>快速失败并快速恢复。</li><li>FallBack回退并在可能的情况下正常降级。</li><li>启用近乎实时的监视，警报和操作控制。</li></ul><p>Hystrix的工作原理：</p><ul><li>防止任何单个依赖项耗尽所有容器（例如Tomcat）用户线程。</li><li>减少负载并快速失败，而不是排队。</li><li>在可行的情况下提供备用，以保护用户免受故障的影响。</li><li>隔离：例如隔板bulkhead，泳道swimlane和断路器模式circuit breaker patterns，（线程池隔离和信号量隔离）限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。</li><li>降级机制：超时降级、资源不足时(线程或信号量)降级，降级后可以配合降级接口返回托底数据。</li><li>融断：当失败率达到阀值自动触发降级(如因网络故障/超时造成的失败率高)，熔断器触发的快速失败会进行快速恢复。</li><li>缓存：提供了请求缓存、请求合并实现。</li><li>通过近实时监控指标，警报优化</li></ul><h2><span id="fu-wu-xian-liu"> 服务限流</span><a href="#fu-wu-xian-liu" class="header-anchor">#</a></h2><p>秒杀等高并发场景，严禁一窝蜂，需要排队，一秒钟只能N个有序运行。</p><h2><span id="ru-he-shi-xian-de"> 如何实现的：</span><a href="#ru-he-shi-xian-de" class="header-anchor">#</a></h2><ul><li><p>将对外部系统（或“依赖项”）的所有调用包装在通常在单独线程中执行的HystrixCommand或HystrixObservableCommand对象中（这是命令模式的示例）。</p></li><li><p>超时调用时间阈值。 有默认值，但可以自定义为超过99.5％的调用时间。</p></li><li><p>为每个依赖项维护一个小的线程池（或信号量）； 如果已满，发往该依赖项的请求将立即被拒绝，而不是排队。</p></li><li><p>测量成功，失败（客户端抛出的异常），超时和线程拒绝。</p></li><li><p>如果某个服务的错误百分比超过阈值，则使断路器跳闸，以在一段时间内手动或自动停止所有对特定服务的请求。</p></li><li><p>当请求失败，被拒绝，超时或短路时执行回退逻辑。</p></li><li><p>几乎实时监控指标和配置更改。</p><p>更多见：</p></li></ul><blockquote><p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#flow1" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/How-it-Works#flow1</a></p></blockquote><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602151354011.png" alt="image-20200602151354011"></p><h3><span id="shang-tu-de-bu-zou"> 上图的步骤</span><a href="#shang-tu-de-bu-zou" class="header-anchor">#</a></h3><ol><li><p>构造一个<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象</p></li><li><p>执行命令，有四种方式。分别可以返回单个和多个返回。<code>HystrixObservableCommand</code>两个方法分别获取Hot和Cold的Observable。</p></li><li><p>响应是否已缓存：如果为此命令启用了请求缓存，并且如果对请求的响应在缓存中可用，则该缓存的响应将立即以的形式返回<code>Observable</code>。</p></li><li><p>断路器是否开启：当执行该命令时，Hystrix会检查断路器，以查看断路器是否断开。</p><p>如果断开（或“跳闸”），那么Hystrix将不执行命令，而是将流路由到（8）获取回退。如果电路是闭合的，则流程进行到（5），以检查是否有足够的容量来运行该命令。</p></li><li><p>线程池/队列/信号量是否已满：如果与该命令关联的线程池和队列（或信号量，如果未在线程中运行）已满，则Hystrix将不执行该命令，但会立即将流路由到（8）获取回退。</p></li><li><p><code>HystrixObservableCommand.construct()</code>或<code>HystrixCommand.run()</code>，run返回单个响应或引发异常。construct返回一个Observable，它发出响应或发送<code>onError</code>通知。</p></li><li><p>计算电路健康度：Hystrix向断路器报告成功，失败，拒绝和超时，断路器保持滚动的一组计算统计信息的计数器。它使用这些统计信息来确定电路何时应“跳闸”，在此点它会将随后的所有请求短路，直到经过恢复期为止，在此之后，在首先检查某些运行状况检查之后，它将再次闭合电路。</p></li><li><p>获取后备：<a href="#%E4%B8%A4%E4%B8%AA%E5%A4%84%E7%90%86%E9%99%8D%E7%BA%A7%E7%9A%84%E7%B1%BB%E5%8C%BA%E5%88%AB%EF%BC%9A">两个处理降级的类区别：</a></p><ol><li><p>construct或者run引发异常</p></li><li><p>断路器断开</p></li><li><p>线程池或者信号量满了</p></li><li><p>命令时间超时</p><p><code>HystrixCommand.getFallback()</code>或者<code>HystrixObservableCommand.resumeWithFallback()</code>进行后备实现，最终的后备应该不依赖网络静态，否则会级联失败。</p><p>如果没准备后备，缺省抛出异常，会到OnError通知，非常糟糕要避免。</p></li></ol></li><li><p>获取成功后的响应：参见 <a href="#%E4%B8%A4%E4%B8%AA%E5%A4%84%E7%90%86%E9%99%8D%E7%BA%A7%E7%9A%84%E7%B1%BB%E5%8C%BA%E5%88%AB%EF%BC%9A">HystrixCommand和HystrixObservableCommand两个处理降级的类区别</a></p></li></ol><blockquote><p>这里有一个关联源码的动态序列图   <a href="https://design.codelytics.io/hystrix/how-it-works" target="_blank" rel="noopener">https://design.codelytics.io/hystrix/how-it-works</a></p></blockquote><p>降级出现的场景：</p><ul><li>上图4，命令处于“熔断、短路”状态的时候</li><li>上图5，当前命令的线程池、请求队列或者信号量被占满的时候。</li><li>上图6，当<code>HystrixObservableCommand.construct()</code>或者<code>HystrixCommand.run()</code>发生异常的时候。</li></ul><h2><span id="ge-chi-de-shi-xian"> 隔离的实现</span><a href="#ge-chi-de-shi-xian" class="header-anchor">#</a></h2><h3><span id="xian-cheng-chi-ge-chi-mo-shi"> 线程池隔离模式：</span><a href="#xian-cheng-chi-ge-chi-mo-shi" class="header-anchor">#</a></h3><p>使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）</p><h3><span id="xin-hao-liang-ge-chi-mo-shi"> 信号量隔离模式：</span><a href="#xin-hao-liang-ge-chi-mo-shi" class="header-anchor">#</a></h3><p>使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）</p><p>区别（两种隔离方式只能选其一）：</p><table><thead><tr><th></th><th>线程池隔离</th><th>信号量隔离</th></tr></thead><tbody><tr><td>线程</td><td>与调用线程非相同线程</td><td>与调用线程相同（jetty线程）</td></tr><tr><td>开销</td><td>排队、调度、上下文开销等</td><td>无线程切换，开销低</td></tr><tr><td>异步</td><td>支持</td><td>不支持</td></tr><tr><td>并发支持</td><td>支持（最大线程池大小）</td><td>支持（最大信号量上限）</td></tr></tbody></table><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602153259821.png" alt="image-20200602153259821"></p><h2><span id="rong-duan"> 熔断</span><a href="#rong-duan" class="header-anchor">#</a></h2><p>正常状态下，电路处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态;</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602153404090.png" alt="image-20200602153404090"></p><p>HystrixCircuitBreaker（断路器的具体实现），下图是官网How-it-works里面的：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/4115139-5443e70eedb3c6ef.png" alt="img"></p><p>详细的工作流程：</p><blockquote><p><a href="http://hot66hot.iteye.com/blog/2155036" target="_blank" rel="noopener">http://hot66hot.iteye.com/blog/2155036</a></p></blockquote><h1><span id="hystrix-yuan-ma"> Hystrix源码</span><a href="#hystrix-yuan-ma" class="header-anchor">#</a></h1><h2><span id="hystrixcommand-lei-tu"> HystrixCommand类图</span><a href="#hystrixcommand-lei-tu" class="header-anchor">#</a></h2><p>用于返回一个操作结果</p><p>类图，抽象类<code>HystrixCommand</code>继承了<code>AbstractCommand</code>，实现了三个核心接口<code>HystrixExecutable</code>、<code>HystrixInvokableInfo</code>、<code>HystrixObservable</code></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200603115730422.png" alt="image-20200603115730422"></p><h2><span id="hystrixobservablecommand-lei-tu"> HystrixObservableCommand类图</span><a href="#hystrixobservablecommand-lei-tu" class="header-anchor">#</a></h2><p>用于返回多个操作结果对象</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200603160553985.png" alt="image-20200603160553985"></p><ul><li><code>HystrixInvokableInfo</code>是一个空接口，只是一个标记。</li><li><code>HystrixInvokable</code>也一样，空接口是一个标记。</li></ul><h3><span id="hystrixcommand-he-hystrixobservablecommand"> HystrixCommand和HystrixObservableCommand</span><a href="#hystrixcommand-he-hystrixobservablecommand" class="header-anchor">#</a></h3><h4><span id="liang-ge-chu-li-jiang-ji-de-lei-qu-bie"> 两个处理降级的类区别：</span><a href="#liang-ge-chu-li-jiang-ji-de-lei-qu-bie" class="header-anchor">#</a></h4><ul><li><p><code>HystrixCommand</code>有2个方法：</p><ul><li><code>public R execute()</code>： 用于同步执行命令。其实是用queue()返回的Future.get()实现同步。会等待任务执行完毕。</li><li><code>public Future&lt;R&gt; queue()</code>：用于异步执行命令。底层是通过 <code>toObservable()</code>拿到一个ColdObservable对象，通过toBlocking()转换为BlockingObservable，它可以把数据通过阻塞的方式发射出去。但是这里使用toFuture()转换成了一个Future返回，不会阻塞。使得消费者可以异步操作。这种转换要求只能发出一个数据，所以execute和queue都只能返回单一结果。</li></ul></li><li><p><code>HystrixObservableCommand</code>又提供了2个方法：</p><ul><li><code>public Observable&lt;R&gt; observe()</code>：返回<code>Observable</code>对象，eagerly的。代表了操作的多个结果。订阅<code>Observable</code>，可用于通过回调异步执行命令。返回的是一个<code>Hot Observable</code>（不管是否有订阅者都会触发事件，每一个订阅者都可能是中途开始的，只看到整个操作的局部）</li><li><code>public Observable&lt;R&gt; toObservable()</code>：返回的也是<code>Observable</code>对象，lazily的。代表了操作的多个结果。返回的是一个<code>Cold Observable</code>（会等待，直到有订阅者才开始发布事件，对订阅者保证都是从一开始都看到整个操作的全程。）</li><li>Observable可以发送过个数据，获取多个结果。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200604002958416.png" alt="image-20200604002958416"></p></li></ul><h4><span id="er-zhe-jiang-ji-de-fang-fa-ye-bu-tong"> 二者降级的方法也不同：</span><a href="#er-zhe-jiang-ji-de-fang-fa-ye-bu-tong" class="header-anchor">#</a></h4><ul><li><code>HystrixCommand</code>：通过<code>R getFallback()</code>完成降级，直接返回业务R对象。</li><li><code>HystrixObservableCommand</code>：通过<code>Observable&lt;R&gt; resumeWithFallback()</code>完成降级，返回Observable对象来发射一个或者多个降级结果。</li><li>如果我们没有为命令实现降级方法，缺省实现是抛异常。或者降级失败也会抛异常，最终会进入到<code>onError()</code>方法中因其命令失败，要避免。</li></ul><p>在服务降级的逻辑中，我们需要一个通用的结果。通常是静态或从缓存中获取的兜底数据，而不是依赖于网络。如果一定要依赖网络，那么依赖的服务也必须放到Hystrix的命令中，级联降级。最终最后兜底的那个一定是一个不依赖于网络的，否则可能降级失败。</p><h2><span id="duan-lu-qi-hystrixcircuitbreaker"> 断路器HystrixCircuitBreaker</span><a href="#duan-lu-qi-hystrixcircuitbreaker" class="header-anchor">#</a></h2><p>**关键词：**统计值、状态位、CAS、SingleTest、SleepWindow</p><p><code>HystrixCircuitBreaker</code>是一个接口，接口文件中有两个实现类<code>HystrixCircuitBreakerImpl</code>和<code>NoOpCircuitBreaker</code>，以及一个Factory。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200604093738685.png" alt="image-20200604093738685"></p><ul><li><p>Factory没啥意思，就是一个CurrentHashMap使用命令的key来缓存和实例化断路器。</p></li><li><p>来看一下缺省断路器实现类<code>HystrixCircuitBreakerImpl</code>就能搞定它的原理了，先大概描述一下再上代码：</p><ul><li>有四个核心方法：</li><li><code>allowRequest()</code>：是否允许访问，主要判断超参数开关。参数设定强制断开、联通的话不回去判断断路器。否则才判断断路器isOpen或者singleTest。没啥意思。</li><li><code>isOpen()</code>: true=断开，断开的立刻返回失败。没断开的判断窗口内是否超量(缺省10秒20)，没超量也返回ok。超量的看错误率(缺省50%)超标则标记失败状态(<strong>CAS标识和失败时间</strong>)并返回，否则返回ok。</li><li><code>allowSingleTest()</code>：是否允许测一把，在上面isOpen里面如果错误量超标，会CAS标记断开，同时记录断开时间。然后<code>当前请求时间&gt;断开时间+sleepWindow(缺省5秒)</code>后属于<code>半开</code>状态，此时的请求只允许测试一次，成功就恢复，没成功继续修改断开时间。【<strong>也是CAS修改时间戳，保证只会发起一次测试</strong>】</li><li><code>markSuccess()</code>：请求成功后就标记成功并清空计数器（<strong>CAS标记成功防止重复清空</strong>）。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerImpl</span> <span class="keyword">implements</span> <span class="title">HystrixCircuitBreaker</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandProperties properties;    <span class="comment">//实例化的时候带进来的，一大堆配置参数和开关</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HystrixCommandMetrics metrics;  <span class="comment">//实例化的时候带进来的，一堆指标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* track whether this circuit is open/closed at any given point in time (default to false==closed) */</span></span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean circuitOpen = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);  <span class="comment">// true的时候就是open，也就是断路器断开了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* when the circuit was marked open or was last allowed to try a 'singleTest' */</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong circuitOpenedOrLastTestedTime = <span class="keyword">new</span> AtomicLong();   <span class="comment">// 一个时间戳</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">HystrixCircuitBreakerImpl</span><span class="params">(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, HystrixCommandProperties properties, HystrixCommandMetrics metrics)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.properties = properties;</span><br><span class="line">            <span class="keyword">this</span>.metrics = metrics;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记成功</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (circuitOpen.get()) &#123; <span class="comment">//true=open=断开</span></span><br><span class="line">                <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;   <span class="comment">// 注意使用了CAS避免并发问题，恢复断路器。</span></span><br><span class="line">                    <span class="comment">//win the thread race to reset metrics  // CAS拿到了执行权</span></span><br><span class="line">                    <span class="comment">//Unsubscribe from the current stream to reset the health counts stream.  This only affects the health counts view,  //退订当前流以重置运行状况计数流。这只会影响健康计数相关的信息</span></span><br><span class="line">                    <span class="comment">//and all other metric consumers are unaffected by the reset  //并且所有其他指标使用者均不受重置的影响</span></span><br><span class="line">                    metrics.resetStream();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (properties.circuitBreakerForceOpen().get()) &#123;  <span class="comment">// 参数里面看看是不是强制断开的，是的话拒绝。</span></span><br><span class="line">                <span class="comment">// properties have asked us to force the circuit open so we will allow NO requests</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (properties.circuitBreakerForceClosed().get()) &#123;    <span class="comment">// 参数里面是不是强制关闭的，是的话允许。</span></span><br><span class="line">                <span class="comment">// we still want to allow isOpen() to perform it's calculations so we simulate normal behavior  // 计数</span></span><br><span class="line">                isOpen();</span><br><span class="line">                <span class="comment">// properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !isOpen() || allowSingleTest();    <span class="comment">// 否则看是否闭合，或者是否允许单一测试（单一测试是挂了很久了，再来一个请求允许试一把看看恢复了没）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  挂了很久，测一把看看是否恢复了。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allowSingleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> timeCircuitOpenedOrWasLastTested = circuitOpenedOrLastTestedTime.get();  <span class="comment">// 从Atomic时间戳了拿出来上次失败时间</span></span><br><span class="line">            <span class="comment">// 1) if the circuit is open   // 断路器断开了，而且已经断开了很久，超过了参数配置的睡眠窗口时间。就会允许测试一把</span></span><br><span class="line">            <span class="comment">// 2) and it's been longer than 'sleepWindow' since we opened the circuit</span></span><br><span class="line">            <span class="keyword">if</span> (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;</span><br><span class="line">                <span class="comment">// 如果测试成功，就会把断路器合上，恢复服务。否则把失败时间往后赋值，再等下一次时间窗口后进行singleTest</span></span><br><span class="line">                <span class="comment">// We push the 'circuitOpenedTime' ahead by 'sleepWindow' since we have allowed one request to try.</span></span><br><span class="line">                <span class="comment">// If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the 'sleepWindow'.</span></span><br><span class="line">                <span class="keyword">if</span> (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;</span><br><span class="line">                    <span class="comment">// if this returns true that means we set the time so we'll return true to allow the singleTest</span></span><br><span class="line">                    <span class="comment">// if it returned false it means another thread raced us and allowed the singleTest before we did</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 允许</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 另一个线程已经测试了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 断路器是否闭合</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (circuitOpen.get()) &#123;</span><br><span class="line">                <span class="comment">// 如果是断开的(true)，我们会立即返回true断开，而不必费心尝试“关闭”自己，因为这允许allowSingleTest和随后的成功测试关闭</span></span><br><span class="line">                <span class="comment">// if we're open we immediately return true and don't bother attempting to 'close' ourself as that is left to allowSingleTest and a subsequent successful test to close</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 如果我们是闭合的，看一眼是否有错误使我们跳闸，以便使电路断开</span></span><br><span class="line">            <span class="comment">// we're closed, so let's see if errors have made us so we should trip the circuit open</span></span><br><span class="line">            HealthCounts health = metrics.getHealthCounts();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否超过总统计量的阈值参数，没有超过总量就立即返回false（没断开），不用计算别的</span></span><br><span class="line">            <span class="comment">// check if we are past the statisticalWindowVolumeThreshold</span></span><br><span class="line">            <span class="keyword">if</span> (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">                <span class="comment">// we are not past the minimum volume threshold for the statisticalWindow so we'll return false immediately and not calculate anything</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果超过了总量，再来计算错误比例</span></span><br><span class="line">            <span class="keyword">if</span> (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 错误比例没超标，直接返回ok的，没断开</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// our failure rate is too high, trip the circuit</span></span><br><span class="line">                <span class="keyword">if</span> (circuitOpen.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;    <span class="comment">// 错误率太高，CAS把断路器关闭掉。CAS成功的话</span></span><br><span class="line">                    <span class="comment">// if the previousValue was false then we want to set the currentTime</span></span><br><span class="line">                    circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());    <span class="comment">// 设置断路时间</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">// 返回断路了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span></span><br><span class="line">                    <span class="comment">// caused another thread to set it to true already even though we were in the process of doing the same</span></span><br><span class="line">                    <span class="comment">// In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">// 这里是被别的CAS抢占了，但是也要告诉当前的调用者这次是断开的。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="ge-chi"> 隔离</span><a href="#ge-chi" class="header-anchor">#</a></h2><h1><span id="pei-zhi-can-shu"> 配置参数</span><a href="#pei-zhi-can-shu" class="header-anchor">#</a></h1><p>很多参数，去这里查：</p><blockquote><p><a href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/Configuration</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/e07661b9bae8" target="_blank" rel="noopener">https://www.jianshu.com/p/e07661b9bae8</a></p><p><a href="https://www.jianshu.com/p/3e11ac385c73uyi" target="_blank" rel="noopener">https://www.jianshu.com/p/3e11ac385c73uyi</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rxjava-kuai-su-ru-men&quot;&gt;RxJava快速入门&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ji-ben-gai-nian&quot;&gt;基本
      
    
    </summary>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件02---OpenFeign实践</title>
    <link href="https://blog.sofunnyai.com/article/springcloud-H-02-open-feign.html"/>
    <id>https://blog.sofunnyai.com/article/springcloud-H-02-open-feign.html</id>
    <published>2020-03-22T04:22:51.000Z</published>
    <updated>2020-06-02T06:37:51.174Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#openfeign-jian-jie">OpenFeign简介</a><ul><li><a href="#ribbon-he-feign-de-qu-bie">Ribbon和Feign的区别</a><ul><li><a href="#ribbon">Ribbon</a></li><li><a href="#feign">Feign</a></li><li><a href="#openfeign">OpenFeign</a></li></ul></li></ul></li><li><a href="#shi-jian-an-li">实践案例</a><ul><li><a href="#server-duan">Server端：</a></li><li><a href="#ti-gong-fang">提供方</a></li><li><a href="#feign-chang-jian-pei-zhi">feign常见配置</a></li><li><a href="#chao-shi-kong-zhi">超时控制</a></li><li><a href="#feign-ri-zhi-kong-zhi">Feign日志控制</a></li><li><a href="#feign-geng-duo">Feign更多</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="openfeign-jian-jie"> OpenFeign简介</span><a href="#openfeign-jian-jie" class="header-anchor">#</a></h1><p>Feign已经不再更新，进入维护状态。SpringCloud版本 OpenFeign作为后起之秀接替他。</p><blockquote><p>Feign是声明性Web服务客户端。 它使编写Web服务客户端更加容易。 要使用Feign，请创建一个接口并对其进行注释。 它具有可插入的注释支持，包括Feign注释和JAX-RS注释。 Feign还支持可插拔编码器和解码器。 Spring Cloud添加了对Spring MVC注释的支持，并支持使用Spring Web中默认使用的相同HttpMessageConverters。 Spring Cloud集成了Ribbon和Eureka以及Spring Cloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。</p></blockquote><blockquote><p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p><a href="https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/</a></p></blockquote><h2><span id="ribbon-he-feign-de-qu-bie"> Ribbon和Feign的区别</span><a href="#ribbon-he-feign-de-qu-bie" class="header-anchor">#</a></h2><h3><span id="ribbon"> Ribbon</span><a href="#ribbon" class="header-anchor">#</a></h3><p>是一个基于 HTTP 和 TCP 客户端 的负载均衡的工具。主启动类上使用<code>@RibbonClient</code>开启<br>它可以 在客户端 配置 RibbonServerList（服务端列表），使用 HttpClient 或 RestTemplate 模拟http请求，步骤相当繁琐。</p><p>Ribbon 可以用来做<strong>客户端负载均衡</strong>，调用注册中心的服务</p><p>Ribbon的使用需要代码里<strong>手动调用目标服务</strong>，请参考官方示例：<a href="https://github.com/Netflix/ribbon" target="_blank" rel="noopener">https://github.com/Netflix/ribbon</a></p><h3><span id="feign"> Feign</span><a href="#feign" class="header-anchor">#</a></h3><p>Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端。</p><p>采用接口的方式， 只需要创建一个接口，然后在上面添加注解即可 ，就能完成对服务方的接口绑定。只需要将需要调用的其他服务的方法定义成抽象方法即可， 不需要自己构建http请求。</p><p>然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写 客户端变得非常容易。Feign自动封装底层Http请求。</p><p>Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端</p><p>Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。</p><p>Feign支持的注解和用法请参考官方文档：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p>Feign本身不支持Spring MVC的注解，它有一套自己的注解</p><h3><span id="openfeign"> OpenFeign</span><a href="#openfeign" class="header-anchor">#</a></h3><p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602124753981.png" alt="image-20200602124753981"></p><h1><span id="shi-jian-an-li"> 实践案例</span><a href="#shi-jian-an-li" class="header-anchor">#</a></h1><ul><li>主启动类开启<code>@EnableFeignClients</code></li><li>写服务接口，对应提供方的Controller，接口上<code>@FeignClient(服务名)</code>和<code>@Component</code>实例化。</li><li>把这个service接口注入到业务中即可使用。（这个Service会有springcloud动态代理生成实现并实例化）</li></ul><h2><span id="server-duan"> Server端：</span><a href="#server-duan" class="header-anchor">#</a></h2><p>pom新增open-feign支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--open feign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--上面的eureka-client会自动引入ribbon--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--业务common类，引用当前项目的版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sam.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--MVC--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--TEST--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--DEV-TOOLS--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>   <span class="comment">// 开启feign功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerOpenFeign8084</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖Eureka7001\7002，Peyment服务方8001\8002四个服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CustomerOpenFeign8084<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用OpenFeign调用Server只用一个接口，Feign会使用代理模式给我们生成一个实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"CLOUD-PAYMENT-SERVICE"</span>) <span class="comment">// server端的服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymengFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value=<span class="string">"/payment/add"</span>)  <span class="comment">// server端的服务地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">addPayment</span><span class="params">(@RequestBody Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/payment/get/&#123;id&#125;"</span>) <span class="comment">// server端的服务地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602132939630.png" alt="image-20200602132939630"></p><h2><span id="ti-gong-fang"> 提供方</span><a href="#ti-gong-fang" class="header-anchor">#</a></h2><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/payment"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为是接受调用的server，这里使用<span class="doctag">@RequestBody</span>接受json，否则字段会丢失</span></span><br><span class="line"><span class="comment">     * http://localhost:8002/payment/add</span></span><br><span class="line"><span class="comment">     * &#123;"serial":"lalala"&#125;  content-type: application/json才行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> payment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value=<span class="string">"/add"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">addPayment</span><span class="params">(@RequestBody Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.add(payment);</span><br><span class="line">        log.info(<span class="string">"---------插入:"</span>+result);</span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(<span class="string">"插入payment成功！serverPort="</span>+serverPort);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.businessFail(<span class="string">"插入payment失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">        Payment payment = paymentService.getById(id);</span><br><span class="line">        <span class="keyword">if</span>(payment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.success(<span class="string">"ok,serverPort="</span>+serverPort, payment);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult.businessFail(<span class="string">"查询失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="feign-chang-jian-pei-zhi"> feign常见配置</span><a href="#feign-chang-jian-pei-zhi" class="header-anchor">#</a></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">feignName:</span> <span class="comment"># 这里是可变的，如default</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">        <span class="attr">errorDecoder:</span> <span class="string">com.example.SimpleErrorDecoder</span></span><br><span class="line">        <span class="attr">retryer:</span> <span class="string">com.example.SimpleRetryer</span></span><br><span class="line">        <span class="attr">requestInterceptors:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.example.FooRequestInterceptor</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.example.BarRequestInterceptor</span></span><br><span class="line">        <span class="attr">decode404:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">encoder:</span> <span class="string">com.example.SimpleEncoder</span></span><br><span class="line">        <span class="attr">decoder:</span> <span class="string">com.example.SimpleDecoder</span></span><br><span class="line">        <span class="attr">contract:</span> <span class="string">com.example.SimpleContract</span></span><br></pre></td></tr></table></figure><h2><span id="chao-shi-kong-zhi"> 超时控制</span><a href="#chao-shi-kong-zhi" class="header-anchor">#</a></h2><p>因为feign底层是使用的ribbon，调用方的<code>application.yml</code>中配置ribbon的超时时间：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时配置，以下二选一</span></span><br><span class="line"><span class="comment">#ribbon:</span></span><br><span class="line"><span class="comment">#  ReadTimeout: 5000  # 连接建立后请求数据的时间</span></span><br><span class="line"><span class="comment">#  ConnectTimeout: 5000  # 建立连接的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用feign原生配置，https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 可变的name</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure><h2><span id="feign-ri-zhi-kong-zhi"> Feign日志控制</span><a href="#feign-ri-zhi-kong-zhi" class="header-anchor">#</a></h2><p>yml对应包打开日志</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.sam.springcloud.service.PaymengFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>feign配置日志级别，使用上面的yml配置文件控制，或者下面人肉注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可选，设置Feign的日志级别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="feign-geng-duo"> Feign更多</span><a href="#feign-geng-duo" class="header-anchor">#</a></h2><p>Encoder、Decoder、和Hystyix结合，消息压缩，见</p><blockquote><p><a href="https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/#spring-cloud-feign-hystrix" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/#spring-cloud-feign-hystrix</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#openfeign-jian-jie&quot;&gt;OpenFeign简介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ribbon-he-feign-de-qu
      
    
    </summary>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>互联网金融资产质量评估指标---fpd、vintage、rollrate和迁移率等等</title>
    <link href="https://blog.sofunnyai.com/article/vintage_rollrate_fpd.html"/>
    <id>https://blog.sofunnyai.com/article/vintage_rollrate_fpd.html</id>
    <published>2020-03-21T17:25:33.000Z</published>
    <updated>2020-05-25T06:57:03.990Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="mu-lu"> 目录</span><a href="#mu-lu" class="header-anchor">#</a></h1><!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#gai-shu"><strong>概述</strong></a></li><li><a href="#ji-chu-gai-nian"><strong>基础概念</strong></a><ul><li><a href="#feng-xian-fen-xi-you-chang-jian-de-5-yao-su">风险分析有常见的5要素：</a></li><li><a href="#qi-ta-de-xiang-guan-gai-nian">其他的相关概念</a></li></ul><ul><li><a href="#yan-zhi-lu">延滞率</a><ul><li><a href="#ji-qi-zhi-biao-coincidental"><strong>即期指标（coincidental）：</strong></a></li><li><a href="#di-yan-zhi-biao-lagged"><strong>递延指标（lagged）：</strong></a></li></ul></li><li><a href="#zhang-ling-month-of-book-mob">账龄(Month of Book，MOB)</a></li><li><a href="#fpd-shou-yu-lu-fan-qi-zha-xiang-guan">FPD 首逾率（反欺诈相关）</a></li><li><a href="#ru-cui-lu">入催率</a></li><li><a href="#yu-qi-shi-jian">逾期时间</a></li></ul></li><li><a href="#vintage-cheng-shou-qi"><strong>vintage 成熟期</strong></a><ul><li><a href="#guan-cha-dian-yu-biao-xian-qi">观察点与表现期：</a></li><li><a href="#vintage-ju-li">vintage举例</a></li></ul></li><li><a href="#roll-rate-gun-dong-lu"><strong>roll rate滚动率</strong></a><ul><li><a href="#gun-dong-lu-ding-yi-zhuang-tai-bian-hua">滚动率定义—状态变化</a></li></ul></li><li><a href="#ru-he-que-ding-bad-he-good-biao-qian-de-zhang-ling"><strong>如何确定bad和good标签的账龄</strong></a><ul><li><a href="#vintage-he-roll-rate-de-qu-bie">vintage和roll rate的区别：</a><ul><li><a href="#roll-rate-yi-jing-que-ding-liao-bad-wei-shi-me-huan-xu-yao-tong-guo-vintage-fen-xi-lai-que-ding-biao-xian-qi">roll rate已经确定了bad为什么还需要通过Vintage分析来确定表现期？</a></li><li><a href="#vintage-li-suo-you-de-zhang-hu-wo-men-de-mu-de-shi-zhua-zhu-jin-ke-neng-duo-de-pi-ke-hu">Vintage里所有的账户，我们的目的是抓住尽可能多的坏客户。</a></li></ul></li></ul></li><li><a href="#flow-rate-qian-yi-lu"><strong>Flow Rate迁移率</strong></a></li><li><a href="#pi-zhang-zhun-bei-jin"><strong>坏账准备金</strong></a><ul><li><a href="#pi-zhang-zhun-bei-jin-de-gai-nian-ge-qi-yu-qi-yu-e-cheng-yi-ge-zi-zhun-bei-jin-lu">坏账准备金的概念----各期逾期余额乘以各自准备金率</a></li><li><a href="#zhun-bei-jin-bi-li">准备金比例</a></li></ul></li><li><a href="#zi-chan-zu-he-guan-li-xiang-guan">资产组合管理相关</a></li><li><a href="#can-kao-wen-zhang-lian-jie">参考文章链接：</a></li></ul><!-- tocstop --></div><h1><span id="gai-shu"> <strong>概述</strong></span><a href="#gai-shu" class="header-anchor">#</a></h1><p>想写一个vintage和roll rate的文章，查到求是汪大佬写的非常详细，图文并茂。直接偷懒摘录了一个脱水版，想看原文的在<a href="https://zhuanlan.zhihu.com/p/81027037/" target="_blank" rel="noopener">这里</a>。下面开始干货。</p><p>本文主要讲述账龄vantage、滚动率roll rate、迁移率flow rate三个指标的关系。</p><ul><li>账龄分析（Vintage Analysis）：用以分析账户成熟期、变化规律等。</li><li>滚动率分析（Roll Rate Analysis）：用以定义账户好坏程度。</li><li>迁移率分析（Flow Rate Analysis）：用以分析不同逾期状态之间的转化率。</li></ul><h1><span id="ji-chu-gai-nian"> <strong>基础概念</strong></span><a href="#ji-chu-gai-nian" class="header-anchor">#</a></h1><h3><span id="feng-xian-fen-xi-you-chang-jian-de-5-yao-su"> 风险分析有常见的5要素：</span><a href="#feng-xian-fen-xi-you-chang-jian-de-5-yao-su" class="header-anchor">#</a></h3><ol><li>下单月：</li><li>观察月：</li><li>放款额（GMV）：就是零售业说的“流水”，成交总额包括销售额、取消订单金额、拒收订单 金额和退货订单金额。</li><li>在贷余额（Balance）/ ENR：至某时点借款人尚未偿还的本金</li><li>逾期天数（DPD）</li></ol><h3><span id="qi-ta-de-xiang-guan-gai-nian"> 其他的相关概念</span><a href="#qi-ta-de-xiang-guan-gai-nian" class="header-anchor">#</a></h3><ol><li>C,M1,M2,M3…的贷款余额：根据逾期期数(C,M1,M2,M3…)，计算每条借款的当时的贷款余额。（<strong>贷款余额 = 放款时合同额 –已还本金</strong>）</li><li>核销金额: 贷款逾期M7+（坏账）后经审核进行销帐，核销金额即在核销日期当天的贷款余额。</li><li>回收金额 Recovery：来自历史所有已核销合同的全部实收金额。（核销后又回收的部分）</li><li>净坏账 NCL：当月新增核销金额 – 当月回收金额（坏账减去回收）</li></ol><h2><span id="yan-zhi-lu"> 延滞率</span><a href="#yan-zhi-lu" class="header-anchor">#</a></h2><p>延滞率（delinquent%）的计算可分为coincidental以及lagged两种方式，除了各bucket延滞率之外，也会观察特定bucket以上的延滞率，如M2+lagged%以及M4+lagged%等指标，以M2+lagged%为例，分母为两个月前应收账款，分子为本月M2（含）以上尚未转呆账的逾期金额。</p><p>在消费金融风险管理上，M2以及M4为两个重要的观测点，原因是客户可能因为一时忙碌或疏忽造成账款逾期，但若经过M1催收仍旧落入M2以上，几乎可以确认为无力缴款或者蓄意拖欠。另外依据经验，客户一旦落入M4，事后转呆账几率非常高。</p><p>下面部分来自知乎<a href="https://www.zhihu.com/question/51583052/answer/194923434" target="_blank" rel="noopener">京东白条</a>的回复：</p><p>逾期率有两种方法：<strong>即期逾期率指标</strong>Coin(X)%和<strong>递延逾期率指标</strong>Lagged(X)%</p><p>这个指标分子 = 时点逾期余额，分母 = 时点透支余额。逾期率最直观，但也最容易被“操控”：</p><p>分子会受到统计粒度的影响（以客户/账户/贷款单/贷款分期单哪个粒度来计算差异很大，尤其是偏重分期的产品），也会受到核销等资产处置的影响（是否有核销处理、统计时是否包含）。</p><p>分母会受到当期时点规模的影响，季末/年末冲量或特殊的营销时点上，都会导致规模的激增，人为拉低时点的逾期率。</p><p>在产品高速发展时期，规模增长迅速，而风险滞后释放，导致对风险的低估和滞后判断；而在产品成熟和衰退期，导致对风险的高估，容易误导风险策略的制定。</p><p>由于上述原因的存在，一般逾期率只能说明累积的整体风险水平如何。如果根据时点的不良率判断近期风险水平，存在高估/低估的可能。-------------逾期率只能是整体一个粗略的观察，具体来说逾期的结构更重要。</p><p>如果一定要用时点余额来判断近期的风险，建议使用延滞率或逾期的净生成率：</p><p>Mi延滞率=当期Mi/i月前的M0</p><p>Mi净生成率=(当期Mi-i月前的Mi)/i月前的透支余额</p><p>这两个指标至少能在一定程度上排除当期时点规模、历史存量的影响，能更真实反映近期的风险水平。</p><h4><span id="xin-zeng-ke-hu-zi-chan-de-feng-xian-shui-ping-ru-he"> 新增客户/资产的风险水平如何？</span><a href="#xin-zeng-ke-hu-zi-chan-de-feng-xian-shui-ping-ru-he" class="header-anchor">#</a></h4><p>整体的逾期率并不一定能回答或甄别近期客户/资产的风险水平。需要通过VINTAGE拆解客户和资产，观察相同的表现期后不同客群/资产的逾期占比，例如激活或放款后1~24个月各月月末时点的0+/30+/90+贷款户数和金额或余额的占比。</p><p>通过对比不同激活月或放款月在相同的表现窗口后的逾期水平，能观察不同激活月/放款月（对应了不同的策略或人群）的风险走势，更合理评价不同时点人群/资产的情况和策略的效果。</p><p>如果运营是针对的客户的，按照激活时间划分客群统计VINTAGE更通用一些；如果是针对资产进行运营，按照贷款的放款月划分资产统计VINTAGE更通用一些。</p><h4><span id="cun-liang-zi-chan-de-qian-yi-qing-kuang"> 存量资产的迁移情况？</span><a href="#cun-liang-zi-chan-de-qian-yi-qing-kuang" class="header-anchor">#</a></h4><p>除了需要时刻关注新增的风险外，也需要掌握已经逾期资产的迁移/退出情况，也就是滚动率(或者迁徙率、迁移率)。</p><p>滚动率一方面体现了客群和资产的质量，也能反映催收运营的状况。</p><p>常见的滚动率一般是当期账龄余额与上一期上一账龄余额的比值，用百分比表示。账龄越高，滚动率越高，表示资产回收的可能性越低，进入下一期高账龄的概率越高。</p><p>滚动率也可以进一步细分为向上/向下滚动，一般默认的滚动率都是向上滚动，即从低账龄滚到高账龄。向上/向下滚动需要锁定月末时点某一账龄的客户/资产，在下月底观察锁定的这部分客户或资产，统计向上/向下滚动的占比，能排除统计粒度和分期带来的降期影响。</p><p>另外，滚动率与产品、前中后的运营等诸多因素有关，短期容易波动，可以计算复合滚动率，例如M0-&gt;M4的滚动率，能从长周期来观察资产质量和运营的稳定水平。</p><h3><span id="ji-qi-zhi-biao-coincidental"> <strong>即期指标（coincidental）：</strong></span><a href="#ji-qi-zhi-biao-coincidental" class="header-anchor">#</a></h3><p>计算延滞率时常用的两种方法之一，以当期各bucket延滞金额÷应收账款（AR）。</p><p>如逾期率Coin©%、Coin(M1)%、Coin(M2)%、Coin(M3)%等等：</p><p><strong>当月不同逾期期数的贷款余额/当月底总贷款余额</strong></p><p>例：</p><p>Coin©%=当月C贷款余额/当月底贷款余额(C-M6)-------------------正常用户余额占所有贷款余额</p><p><strong>Coin(M1)%=当月M1贷款余额/当月底贷款余额(C-M6)</strong></p><p>Coin(M1+)%=当月M1−M6贷款余额/当月底贷款余额(C-M6)------------------逾期M1以上的用户余额占所有贷款余额</p><h3><span id="di-yan-zhi-biao-lagged"> <strong>递延指标（lagged）：</strong></span><a href="#di-yan-zhi-biao-lagged" class="header-anchor">#</a></h3><p>计算延滞率时常用的两种方法之一，<strong>延滞金额÷上月应收账款</strong>。若单纯想了解各月资产质量结构，可使用coindental，但若想<strong>精准溯及逾放源头的话，建议采用lagged。</strong></p><p>与coincident相同也是计算延滞率的一个指标，区别是<strong>lagged的分母为产生逾期金额的那一期的应收账款。Lagged观察的是放贷当期所产生的逾期比率，所以不受本期应收账款的起伏所影响。</strong></p><p>逾期率Lagged(M1)%、Lagged(M2)%、Lagged(M3)%、Lagged(M4)%、Lagged(M5)%、Lagged(M6)%</p><p><strong>Lagged DPD30+   =    当前逾期&gt;=30天的客户的本金余额  /  30天前的累计放款本金</strong></p><p><strong>当月不同逾期期数的贷款余额/往前推N个月的总贷款余额</strong>可以提出当前时点的影响。</p><p>例:</p><p><strong>Lagged(M1)%=当月M1的贷款余额/上个月底时点的贷款余额</strong>  -----------------其实就是平台当月M1/1月前的M0</p><p>Lagged(M4)%=当月M4的贷款余额/往前推四期的总贷款余额</p><p>Lagged(M4+)%=当月M4的贷款余额/往前推四期的总贷款余额 + 当月M5的贷款余额/往前推五期的总贷款余额 + 当月M6的贷款余额/往前推六期的总贷款余额</p><h4><span id="yu-qi-jie-suan"> 逾期结算</span><a href="#yu-qi-jie-suan" class="header-anchor">#</a></h4><p>实际风险有两种结算方式：</p><p><strong>Month end</strong>：月底结算 （常用方式，主要以自然月月底的逾期指标为主）</p><p><strong>Cycle end</strong>：期末结算（单个借款人还款日时间不同，在月底结算的数据不准确，所以一般设置20日还款，留出10天给催收部门）</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525095234158.png" alt="image-20200525095234158"></p><p>早期逾期多数为借款人忘记还款，或短时间资金周转不周，这是<strong>与策略密切相关的。通过借款人债偿能力评估识别出借款人有足够资金，可以不做提醒，以获取滞纳金，对于借款人资产表现不好的，可以设置提前10天提醒还款。</strong></p><p>逾期天数90-119天，为资产M4阶段。<strong>M4-M6的阶段都称之为不良</strong>。M4是一个重要的节点，因为消金公司，上报给银监会，或上市公司披露财务数据、风险数据时，都会选择披露不良率。如果有些公司要在审计认可这个方法论时，会对M4做一些调整。</p><p>通常<strong>180天以上都作为坏账处理</strong>，坏账也是被披露的数据之一，还包含一些特别的计提。</p><h2><span id="zhang-ling-month-of-book-mob"> 账龄(Month of Book，MOB)</span><a href="#zhang-ling-month-of-book-mob" class="header-anchor">#</a></h2><p>指<strong>资产放款月份</strong>。放款日截止观察点的月数。如：</p><ul><li>MOB0：放款日至当月月底</li><li>MOB1：放款后第二个完整的月份</li><li>MOB2：放款后第三个完整的月份</li></ul><h2><span id="fpd-shou-yu-lu-fan-qi-zha-xiang-guan"> FPD 首逾率（反欺诈相关）</span><a href="#fpd-shou-yu-lu-fan-qi-zha-xiang-guan" class="header-anchor">#</a></h2><p>FPD是指首期逾期率，是说在某一个还款日，仅第一期到期的客户中有多少没有按时还款。与入催率的差别在于，入催率包含了第一期、第二期、第三期等等所有到期的M0。FPD一般用来做反欺诈，因为欺诈用户他第一期是根本不会还款的。</p><p>用户授信通过后，首笔需要还款的账单，在最后还款日后7天内未还款且未办理延期的客户比例即为FPD 7，分子为观察周期里下单且已发生7日以上逾期的用户数，分母为当期所有首笔下单且满足还款日后7天，在观察周期里的用户数。常用的FPD指标还有FPD 30。<br>举例：</p><p>假设用户在10.1日授信通过，在10.5日通过分期借款产生了首笔分3期的借款，且设置每月8日为还款日。则11.08是第一笔账单的还款日，出账日后，还款日结束前还款则不算逾期。如11.16仍未还款，则算入10.1-10.30周期的FPD7的分子内。通常逾期几天的用户可能是忘了还款或一时手头紧张，但FPD 7 指标可以用户来评价授信人群的信用风险，对未来资产的健康度进行预估。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525134714438.png" alt="image-20200525134714438"></p><p>与FPD 7 类似，FPD 30也是对用户首笔待还账单逾期情况进行观察的指标。对于逾期30天内的用户，可以通过加大催收力度挽回一些损失，对于逾期30天以上的用户，催收回款的几率就大幅下降了，可能进行委外催收。如果一段时间内的用户FPD 7较高，且较少催收回款大多落入了FPD 30 内，则证明这批用户群的non-starter比例高，借款时压根就没想还，反之则说明用户群的信用风险更严重。</p><h2><span id="ru-cui-lu"> 入催率</span><a href="#ru-cui-lu" class="header-anchor">#</a></h2><p>有了前面的铺垫，入催率就比较简单了。它指的是在某一个还款日，客户从M0变成M1的比例。比如说，今天，有N个M0客户到了还款日，里面有M个客户按时还款了，那么今天的入催率就是（N-M）/N。它与上面的FPD是有区别的。</p><h2><span id="yu-qi-shi-jian"> 逾期时间</span><a href="#yu-qi-shi-jian" class="header-anchor">#</a></h2><p>DPD、M0（未逾期）、M1（逾期一个月类）、M2（逾期两个月内）。。。</p><p>一般M3+就要委外了，M6+(180天以上)就要记为坏账了。</p><h1><span id="vintage-cheng-shou-qi"> <strong>vintage 成熟期</strong></span><a href="#vintage-cheng-shou-qi" class="header-anchor">#</a></h1><p>其实就是<code>逾期率</code>随着<code>账龄</code>变化的趋势图。常见的作用有：</p><ul><li><code>逾期率</code>：vintage的纵轴随着横轴账龄的增大肯定是变大的，最终的平稳后的逾期率（最大值）就是<code>逾期率</code>。（有资产逾期率、账户逾期率两种口径）</li><li><code>欺诈</code>：如果前两期逾期率陡增，短期风险没处理好，是欺诈（特别是第一期就违约的）</li><li><code>信用风险</code>：如果一直上升、很久不拐，说明信用风险控制不太好。</li><li><code>成熟期</code>：</li><li><code>因素判断</code>：风险策略变化、客群变化、市场环境、政策法规变化时，资产质量的变化。（看vintage曲线的波动）</li></ul><h2><span id="guan-cha-dian-yu-biao-xian-qi"> 观察点与表现期：</span><a href="#guan-cha-dian-yu-biao-xian-qi" class="header-anchor">#</a></h2><ul><li><p><code>观察点、观察期、表现期</code>：通常是在整个MOB中选取一个月份作为观察点，前面的期限是<code>观察期</code>，后面的期限是<code>表现期</code>。也就是在时间轴上选取一个点，这个点是观察点。前面的是观察期，后面的是表现期。</p></li><li><p>表现期越长，信用风险暴露将越彻底，但意味着观察期离当前越远，用以提取样本特征的历史<strong>数据将越陈旧</strong>，建模<strong>样本和未来样本的差异也越大</strong>。(模型PSI高)</p></li><li><p>反之，表现期越短，风险还<strong>未暴露完全，但好处是能用到更近的样本</strong>。（模型PSI低）</p></li></ul><h2><span id="vintage-ju-li"> vintage举例</span><a href="#vintage-ju-li" class="header-anchor">#</a></h2><p>下面是求是汪大佬的一个例子：</p><p>对于一个12期分期还款的信贷产品，理论上当用户在<strong>12期结束，并还清所有的钱后</strong>，我们才能定义为绝对的<strong>好客户</strong>；反之，我们只能说<strong>到目前为止是一个好客户</strong>，但并不能知道未来几期用户会不会逾期不还钱。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/v2-855513c1db679f5602e7a189fb9f6b0a_r.jpg" alt="preview"></p><p>汪大佬的这个图中可以看到：</p><ol><li>账龄最长为12个月，代表<strong>产品期限为12期</strong>。</li><li>根据2018年5月放贷的订单完全走完账龄生命周期，而2018年6月却没走完，说明<strong>数据统计时间为2019年6月初</strong>。</li><li>账龄MOB1、MOB2、MOB3的逾期率都为0，说明<strong>逾期指标为M4+（逾期超过90天）风险。</strong></li><li>由放贷月份从2018年1月～12月的账户的最终逾期率都在降低，说明<strong>资产质量在不断提升</strong>，可能是因为风控水平在不断提升。</li><li>2018年5月相对于2018年1～4月的逾期率大幅度下降，说明该阶段风控策略提升明显。</li><li>不同月份放款的M4+在经过9个MOB后开始趋于稳定（后面违约率不再大幅上升），说明<strong>账户成熟期是9个月</strong>。</li></ol><h1><span id="roll-rate-gun-dong-lu"> <strong>roll rate滚动率</strong></span><a href="#roll-rate-gun-dong-lu" class="header-anchor">#</a></h1><h2><span id="gun-dong-lu-ding-yi-zhuang-tai-bian-hua"> 滚动率定义—状态变化</span><a href="#gun-dong-lu-ding-yi-zhuang-tai-bian-hua" class="header-anchor">#</a></h2><p>滚动率：就是从某个观察点之前的一段时间**（观察期）<strong>的</strong>最坏<strong>的状态，向观察点之后的一段时间</strong>（表现期）<strong>的</strong>最坏的**状态的发展变化情况。（就是说从上一状态向下一状态发展的一个度量，说最坏是因为可能用户逾期多笔）</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200524234256482.png" alt="image-20200524234256482"></p><p>滚动率分析的具体操作步骤为：</p><ul><li><p><strong>step 1.</strong> 确定数据源。一般利用客户还款计划表（repayment schedule）。</p></li><li><p><strong>step 2.</strong> 选择观察点，以观察点为截止时间，统计客户在观察期（如过去6个月）的<strong>最长逾期期数</strong>，按最坏逾期状态将用户分为几个层次，如C（未逾期）、M1、M2、M3、M4+。</p></li><li><p><strong>step 3.</strong> 以观察点为起始时间，统计客户在表现期（如未来6个月）的最长逾期期数，按最坏逾期状态将用户分为几个层次，如C、M1、M2、M3、M4+。</p></li><li><p><strong>step 4.</strong> 交叉统计每个格子里的客户数，如图6中表1所示。</p></li><li><p><strong>step 5.</strong> 统计每个格子里的客户占比，如图6中表2所示。</p></li><li><p><strong>step 6.</strong> 为了排除观察点选择时的随机影响，一般会选择多个观察点。重复step1 ～5。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200524234716564.png" alt="image-20200524234716564"></p></li></ul><p>上面的图说明：</p><ol><li>逾期状态为M0的客户，在未来6个月里，有96%会继续保持正常状态，4%会恶化为M1和M2；</li><li>逾期状态为M1的客户，未来有81%会回到正常状态，即从良率为81%，有7%会恶化，13%会保持M1状态；</li><li>逾期状态为M2的客户，从良率为23%，有39%会恶化为M3和M4+；</li><li>逾期状态为M3的客户，从良率为14.7%，有60.7%会恶化为M4+；</li><li>逾期状态为M4+的客户，从良率仅为4%，有80%会继续保持此状态。</li><li>因此，我们认为历史逾期状态为M4+的客户已经坏透了，几乎不会从良。<strong>为了让风控模型有更好的区分能力，需要将客户好坏界限尽可能清晰</strong>(也就是从良率最剧烈减少的点开始)，可以定义：</li></ol>坏用户（bad）= 逾期状态为M4+（即逾期超过90天）<h1><span id="ru-he-que-ding-bad-he-good-biao-qian-de-zhang-ling"> <strong>如何确定bad和good标签的账龄</strong></span><a href="#ru-he-que-ding-bad-he-good-biao-qian-de-zhang-ling" class="header-anchor">#</a></h1><h2><span id="vintage-he-roll-rate-de-qu-bie"> vintage和roll rate的区别：</span><a href="#vintage-he-roll-rate-de-qu-bie" class="header-anchor">#</a></h2><ul><li>滚动率分析用于定义客户的<strong>好坏程度</strong>。(定义标签bad和good)</li><li>Vintage分析用于确定合适的<strong>表现期</strong>。（找到一个合适的观测点，前面的该逾期的已经逾期了，充分暴露了）</li></ul><p>定义目标客户到底是good还是bad的具体操作步骤为：</p><ul><li><strong>step 1.</strong> 利用滚动率分析定义坏客户（找到不会再从良的那个账龄点），例如上文案例中定义：<strong>M4+为坏客户</strong>。（先找到bad和good）</li><li><strong>step 2.</strong> 以M4+作为资产质量指标（上一步找到定义了bad还是good），统计Vintage数据表，绘制Vintage曲线。目的是<strong>分析账户成熟期</strong>（逾期率不再明显增加），例如上文案例确定：<strong>账户成熟期是9个月。</strong></li></ul><p>也有根据迁徙率确定bad还是good的，下面是FAL提到的一个例子：</p><p>由下表可以看出，M2以上的迁徙率将近90%，所以确定当前逾期31天以上为区分好坏客户的标准，及后续分析的目标变量。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525145244445.png" alt="image-20200525145244445"></p><h3><span id="roll-rate-yi-jing-que-ding-liao-bad-wei-shi-me-huan-xu-yao-tong-guo-vintage-fen-xi-lai-que-ding-biao-xian-qi"> roll rate已经确定了bad为什么还需要通过Vintage分析来确定表现期？</span><a href="#roll-rate-yi-jing-que-ding-liao-bad-wei-shi-me-huan-xu-yao-tong-guo-vintage-fen-xi-lai-que-ding-biao-xian-qi" class="header-anchor">#</a></h3><p>这是因为：虽然滚动率分析确定了M4+作为坏的程度（从良率最低），但是对于12期的产品，有些账户是在前4期MOB（也就是MOB1 ~ MOB4，经过4个表现期）就达到M4+，有些是在（观测点前）后几期才达到M4+。而这很重要。</p><h3><span id="vintage-li-suo-you-de-zhang-hu-wo-men-de-mu-de-shi-zhua-zhu-jin-ke-neng-duo-de-pi-ke-hu"> Vintage里所有的账户，我们的目的是抓住尽可能多的坏客户。</span><a href="#vintage-li-suo-you-de-zhang-hu-wo-men-de-mu-de-shi-zhua-zhu-jin-ke-neng-duo-de-pi-ke-hu" class="header-anchor">#</a></h3><p>现在进一步补充Vintage曲线的绘制过程：如图8所示，对于这10,000个账户，以MOB1为起点，把前N个MOB作为一个窗口，滑窗统计坏客户率，得到图5-表1中的Vintage数据，并绘制Vintage曲线。我们可以发现：经过9期，我们几乎能够抓住所有的坏客户。（也就是前9期该逾期的都逾期了，充分暴露了）</p><p>下图是每个用户逾期的不同起止情况举例：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525004119132.png" alt="image-20200525004119132"></p><p>因此，我们将两者结合起来，定义：</p><ul><li>Bad = 账户经过9期表现期后，逾期状态为M4+（逾期超过90天）。此时 <strong>Y=1</strong>。</li><li>Good = 经过9期表现期，但未达到M4+逾期状态。此时<strong>Y=0</strong>。</li><li>Intermediate = 未进入9期表现期，账户还未成熟，无法定义好坏，也就是不定样本。</li></ul><p><strong>有时候也考虑到这么干的话，bad用户会太少，会往上移动到M3,同时因为前面的good用户要和bad做一个截断。比如M1以内的都是good，m3+的都是bad，m2的忽略截断。</strong></p><h1><span id="flow-rate-qian-yi-lu"> <strong>Flow Rate迁移率</strong></span><a href="#flow-rate-qian-yi-lu" class="header-anchor">#</a></h1><p>展示客户贷款账户在整个生命周期中的变化轨迹，也是<strong>预测未来坏账损失</strong>的最常用的方法。</p><p>其<strong>核心假设</strong>为：处于某一逾期状态（如M2）的账户，一个月后，要么从良为M0账户，要么恶化为更坏的下一个逾期状态（如M3）。</p>迁移率 = 前一期逾期金额到下一期逾期金额的转化率<p>一般缩写为M0-M1、M4-M5等形式，例如：</p><ul><li>M0-M1 = 当月进入M1的贷款余额 / 上月末M0的贷款余额</li><li>M2-M3 = 当月进入M3的贷款余额 / 上月末M2的贷款余额</li></ul><p>迁移率分析的具体操作步骤为：</p><ul><li><strong>step 1.</strong> 定义逾期状态，如前文所述的M0、M1、M2等。</li><li><strong>step 2.</strong> 计算各逾期状态之间的迁移率，如M0-M1、M2-M3等。</li><li><strong>step 3.</strong> 计算不同月份（也可称为Vintage）的<strong>平均迁移率</strong>。目的是对本平台在不同时期的资产的迁移率有整体的认知。</li><li><strong>step 4.</strong> 根据<strong>平均迁移率</strong>和<strong>不良资产回收率</strong>，计算<strong>净坏账损失率</strong>。</li></ul><p>接下来，我们以数值案例（非真实业务数据）展示上述过程。</p><p>下面表1，每一列代表<strong>截止当月</strong>放款的总额M0一直到M6的情况，每一行代表1-7月的各个月对应周期的违约率,所以斜线是前后时间序列关系：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525005348841.png" alt="image-20200525005348841"></p><p>上图表2中，2月份的逾期M1资产只能从1月份的正常M0资产滚动而来（斜线迁移），因此从逾期M0资产向M1的转化率为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>2</mn><mn>3</mn><mn>7</mn><mn>3</mn><mn>3</mn><mn>8</mn></mrow><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mn>7</mn><mn>8</mn><mn>4</mn><mn>4</mn></mrow></mfrac><mo>=</mo><mn>2</mn><mn>3</mn><mi mathvariant="normal">.</mi><mn>5</mn><mn>5</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\frac{237338}{1007844}=23.55\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">7</span><span class="mord mathrm">8</span><span class="mord mathrm">4</span><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord mathrm">7</span><span class="mord mathrm">3</span><span class="mord mathrm">3</span><span class="mord mathrm">8</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">5</span><span class="mord mathrm">5</span><span class="mord mathrm">%</span></span></span></span></span></p><ul><li>截止1月末，正常M0资产为 1007844 元，这是起点。</li><li>截止2月末，1月末的正常M0资产中有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>2</mn><mn>3</mn><mn>7</mn><mn>3</mn><mn>3</mn><mn>8</mn></mrow><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mn>7</mn><mn>8</mn><mn>4</mn><mn>4</mn></mrow></mfrac><mo>=</mo><mn>2</mn><mn>3</mn><mi mathvariant="normal">.</mi><mn>5</mn><mn>5</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\frac{237338}{1007844}=23.55\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base textstyle uncramped"><span class="mord reset-textstyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.345em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">7</span><span class="mord mathrm">8</span><span class="mord mathrm">4</span><span class="mord mathrm">4</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.394em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord mathrm">7</span><span class="mord mathrm">3</span><span class="mord mathrm">3</span><span class="mord mathrm">8</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">5</span><span class="mord mathrm">5</span><span class="mord mathrm">%</span></span></span></span> 恶化为逾期M1资产。【较低，因为有不小心逾期的】</li><li>截止3月末，2月末的逾期M1资产中有 \frac{55362}{237338}=23.33%恶化为逾期M2资产。【较低，因为有不小心逾期的】</li><li>截止4月末，3月末的逾期M2资产中有 \frac{25144}{55362}=45.32% 恶化为逾期M3资产。【翻倍上升了】</li><li>截止5月末，4月末的逾期M4资产中有83.38%恶化为逾期M5资产。此时已过催收黄金期（90天以内）。【大幅上升！】</li><li>截止6月末，5月末的逾期M5资产中有49.37% 恶化为逾期M6资产。这可能采用了<strong>委外催收、司法手段</strong>等催收策略，效果显著。【从80+%下降到49%】</li><li>截止7月末，6月末的逾期M5资产中有82.7% 恶化为逾期M7资产。此时将视为不良资产，打包转卖给第三方公司，这样就能回收部分不良资产，减少损失【没救了】</li></ul><p>我们从横向比较每个月的迁移率，发现不完全一样。这是因为随着<strong>时间推移、外在宏观经济环境、用户渠道、内部政策、资产质量</strong>等变化而产生一定的波动。我们可以利用这些数据：</p><ol><li>观察迁移率的发展轨迹，<strong>监控坏账的发展倾向和催收效果。</strong></li><li>通过对多个月份的迁移率计算平均值，从而使迁移率更加稳定。</li></ol><h1><span id="pi-zhang-zhun-bei-jin"> <strong>坏账准备金</strong></span><a href="#pi-zhang-zhun-bei-jin" class="header-anchor">#</a></h1><h2><span id="pi-zhang-zhun-bei-jin-de-gai-nian-ge-qi-yu-qi-yu-e-cheng-yi-ge-zi-zhun-bei-jin-lu"> 坏账准备金的概念----各期逾期余额乘以各自准备金率</span><a href="#pi-zhang-zhun-bei-jin-de-gai-nian-ge-qi-yu-qi-yu-e-cheng-yi-ge-zi-zhun-bei-jin-lu" class="header-anchor">#</a></h2><p>呆帐风险是信贷机构必须面对的风险，主要来源于信用风险和欺诈风险等。为了应对未来呆帐的可能，信贷机构一般都会设定一个储备资金，这就是**坏账准备金（Bad Debt Reserve）。**那么我们该如何计算坏账准备金？</p><p>一般做法是，把未清偿贷款余额乘以一定的**准备金比例（Reserve Ratio）**所得。可以理解，<strong>资产逾期等级越高（越差），准备金比例也应该越高</strong>，因为恶化为呆帐的可能性也更高。如图10所示，正常M0资产恶化为呆帐的可能性最低，因此我们预留的准备金比例也就最少。</p><p>我们总结下计算坏账准备金的步骤为：</p><ul><li><strong>step 1.</strong> 统计未清偿贷款金额的分布，也就是<strong>M0~M6状态分别对应的资产余额</strong>。</li><li><strong>step 2.</strong> 为每个逾期状态的资产分配一个<strong>准备金比例</strong>。</li><li><strong>step 3.</strong> 每个子项目的准备金金额 = 未清偿贷款余额 x 准备金比例。</li><li><strong>step 4.</strong> 每个子项目的准备金金额相加，得到最终的准备金。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525011045787.png" alt="image-20200525011045787"></p><h2><span id="zhun-bei-jin-bi-li"> 准备金比例</span><a href="#zhun-bei-jin-bi-li" class="header-anchor">#</a></h2><p>准备金比例是如何给出的？</p><p>由于坏账准备金是用来覆盖预期的未来呆帐损失的，<strong>准备金比例必须等于处于各个逾期状态的资产未来演变为呆帐的比例</strong>。</p><p>回到上一节的迁移率分析中，我们发现从正常M0资产迁移至逾期M7资产（呆帐）需经过7次迁移，如图11所示。那么，我们只要把各个状态之间的转化率相乘，不就得到准备金比例了？</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525011316858.png" alt="image-20200525011316858"></p><p>因此，我们定义<strong>正常M0资产对应的毛坏账损失率，<strong>也就是迁移到呆帐的转化率为</strong>：</strong></p>毛坏账损失率 = (M0-M1)×(M1-M2)×(M2-M3)...×(M6-M7)<p>也就是从M0一直到M7的平均迁移率的乘积。</p><p>在本案例中，正常M0资产对应的毛坏账损失率为上上图表2最左侧截止M6-M7的平均迁移率88.03%上面所有的乘起来：0.60%</p><p>在实际中，信贷机构会将不良资产打包转卖给第三方公司，这样就能回收部分不良资产，减少损失。因此，我们定义净坏账损失率为：</p><blockquote><p>净坏账损失率 = 毛坏账损失率 - 不良资产外卖回收率</p></blockquote><p>由于M7不良资产的平均回收率为 <strong>10.79%</strong>，则可计算<strong>净坏账损失率</strong>为：</p><blockquote><p>0.60%×(1-10.79%)=0.54%</p></blockquote><p>同理，我们可以计算正常资产到不同逾期状态资产的毛损失率和净损失率如下：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525012050344.png" alt="image-20200525012050344"></p><p>根据图12所示的损失率表，我们定义：</p><ul><li>当月应计拨备额 = SUM(净坏账损失率 * 月末应收账款余额)</li><li>拨备率 = 当月应计拨备额 / 总资产金额</li></ul><p>其中，拨备率是用来预防不良资产的发生而准备的金额的比例。拨备率应越低越好。<strong>拨备率越高说明风险越大，损失越大，利润越小。</strong></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525012132819.png" alt="image-20200525012132819"></p><p>在本案例中，当月应计拨备额为65421元，如图13所示。拨备率为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>6</mn><mn>5</mn><mn>4</mn><mn>2</mn><mn>1</mn></mrow><mrow><mn>2</mn><mn>6</mn><mn>2</mn><mn>5</mn><mn>0</mn><mn>9</mn><mn>1</mn></mrow></mfrac><mo>=</mo><mn>2</mn><mi mathvariant="normal">.</mi><mn>4</mn><mn>9</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\frac{65421}{2625091}=2.49\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mord mathrm">0</span><span class="mord mathrm">9</span><span class="mord mathrm">1</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">5</span><span class="mord mathrm">4</span><span class="mord mathrm">2</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">.</span><span class="mord mathrm">4</span><span class="mord mathrm">9</span><span class="mord mathrm">%</span></span></span></span></span></p><h1><span id="zi-chan-zu-he-guan-li-xiang-guan"> 资产组合管理相关</span><a href="#zi-chan-zu-he-guan-li-xiang-guan" class="header-anchor">#</a></h1><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200525100003972.png" alt="image-20200525100003972"></p><p>根据风控成因分类：信用风险、欺诈风险。信用风险主要是用户因为各种原因导致逾期而存在的风险，欺诈风险就是黑产欺诈团队的攻击对公司造成的风险，通过设置规则来拦截高风险用户。</p><p>生命周期分为三类：</p><ol><li>拓展客户期（学校刚成立时，既要招生，又要有教材支撑）</li><li>审批客户期（学习成绩、平时表现）</li><li>管理客户期（对学生进行管理）</li></ol><p><strong>拓展客户期</strong>需要三个方面的支持</p><ol><li><p>目标用户：</p><p>适用于拨备segment的风险分级或用户画像支持（拨备与财务挂钩）</p></li><li><p>目标产品：</p><p>风险分级对应期数、利率支持</p></li><li><p>资产配置有效性分析</p></li></ol><p>资金成本、获客成本、运营成本，在放贷还没开始的时候，就已经由资产管理部门估算确定下来了。后续需要技术来创造价值的，主要是风控的坏账成本，所以资产管理部会用拨备工具来给予支持。</p><p>在一个产品刚产生的时候，资产管理部门需要给出关于目标客户的年龄身份，期数，利率的建议；放款后，又需要从其他金融机构拉资金，债权转让等。每一个公司的要求都不一样，我们需要给出推荐，哪一些标的推荐给哪一些公司，如何进行资源组合配置。</p><p><strong>审批客户期</strong></p><p>主要由贷前策略实施，资产组合管理部门可提供<strong>盈利性测算支持，并做好监控、预测、预警系统，当准入用户风险状况超阈值，需提出干预。</strong></p><p><strong>资金成本、获客成本、运营成本</strong>，在<strong>放贷还没开始</strong>的时候，就已经由<strong>资产管理部门估算</strong>确定下来了。后续需要技术来创造价值的，主要是<strong>风控的坏账成本</strong>，所以资产管理部会用<strong>拨备工具</strong>来给予支持。</p><p>在一个产品刚产生的时候，**资产管理部门需要给出关于目标客户的年龄身份，期数，利率的建议；**放款后，又需要从其他金融机构拉资金，债权转让等。每一个公司的要求都不一样，我们需要给出推荐，<strong>哪一些标的推荐给哪一些公司，如何进行资源组合配置。</strong></p><p><strong>审批客户期</strong></p><p>主要由贷前策略实施，资产组合管理部门可提供盈利性测算支持，并做好监控、预测、预警系统，当准入用户风险状况超阈值，需提出干预。</p><p><strong>管理客户期</strong></p><p>1.指标方面：新增/存量、风险/规模指标</p><table><thead><tr><th></th><th>风险</th><th>规模</th></tr></thead><tbody><tr><td>新增</td><td>vintage、FPD</td><td>GMV</td></tr><tr><td>存量</td><td>roll rate、coincident dpd、lagging dpd、badrate</td><td>在贷余额</td></tr></tbody></table><p>2.策略方面：主要由贷中贷后策略实施，可提供盈利性测算支持，并做好监控、预测、预警系统，风险状况超阈值，需提出干预。</p><p><strong>资产组合管理作为支撑部门，支撑什么</strong>？</p><ol><li>风险计量</li><li>策略规则上线</li><li>模型效力验证</li><li>向CRO提供各种专题类或临时性分析</li><li>…</li></ol><p>风险计量主要是数据分析，报表，专题性报告，为了规避、减少风险，策略实施者和策略制定者需要分为2个部门。资产管理部门接到业务部门提交的需求，然后根据内容做一些空跑，监控。同时大的模型开发与模型验证也是两个部门，需要资产管理部对模型做持续的监控与评估。统筹贷前、贷中、贷后的数据给到CRO。</p><p><strong>资产组合管理方法？</strong></p><p>1.拨备准备金</p><p>思考：实际风险与名义风险的区别？</p><p>2.风险分级(用户画像)</p><p>思考：有了评分卡模型为什么还要做风险分级?</p><p>3.监控、预测、预警系统</p><p>思考：资产组合管理报表和业务部门（贷前、中、后）的不同点？</p><p><strong>本次分享总结</strong></p><p>1.资产组合管理部门不同于传统的风控业务部门，而是直属于CRO的信息整合部门；</p><p>2.资产组合管理贯穿于客户及产品的全生命周期，需要从业者极强的沟通能力；</p><p>3.作为支撑部门，资产组合管理部需要运用数据分析把控公司全局资产质量，除此之外还需要以降低作业风险的目的为模型或策略设置二次防线。</p><p>4.资产组合管理部门是小白进入金融风控核心岗位的捷径，可以快速的积累风控经验，之后如果转岗策略或模型，都比较容易。</p><h1><span id="can-kao-wen-zhang-lian-jie"> 参考文章链接：</span><a href="#can-kao-wen-zhang-lian-jie" class="header-anchor">#</a></h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/81027037/" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81027037/</a></p><p><a href="https://blog.csdn.net/liulj_0803/article/details/52964473" target="_blank" rel="noopener">https://blog.csdn.net/liulj_0803/article/details/52964473</a></p><p><a href="https://www.zhihu.com/question/51583052" target="_blank" rel="noopener">https://www.zhihu.com/question/51583052</a>  这里也有很多干货</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;mu-lu&quot;&gt; 目录&lt;/span&gt;&lt;a href=&quot;#mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="risk" scheme="https://blog.sofunnyai.com/categories/risk/"/>
    
    
      <category term="risk" scheme="https://blog.sofunnyai.com/tags/risk/"/>
    
      <category term="评分卡" scheme="https://blog.sofunnyai.com/tags/%E8%AF%84%E5%88%86%E5%8D%A1/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud组件01---CAP、注册中心、Ribbon实践</title>
    <link href="https://blog.sofunnyai.com/article/springcloud-H-01-eureka-ribbon.html"/>
    <id>https://blog.sofunnyai.com/article/springcloud-H-01-eureka-ribbon.html</id>
    <published>2020-03-02T14:30:40.000Z</published>
    <updated>2020-06-02T06:36:58.717Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#cap-li-lun-kuai-su-jian-jie">CAP理论快速简介</a><ul><li><a href="#wei-fu-wu-de-tong-yong-ding-yi">微服务的通用定义：</a></li><li><a href="#ben-ci-ce-shi-ban-ben">本次测试版本：</a></li><li><a href="#fen-bu-shi-fu-wu-bao-gua-de-zu-jian">分布式服务包括的组件</a></li></ul></li><li><a href="#huan-jing-da-jian">环境搭建</a><ul><li><a href="#zhi-fu-zi-module-jian-li">支付子module建立：</a></li></ul></li><li><a href="#idea-zi-dong-re-bu-shu-pei-zhi-ke-xuan">IDEA自动热部署配置（可选）</a></li><li><a href="#guan-yu-resttemplate">关于RestTemplate</a></li><li><a href="#zhu-ce-zhong-xin">注册中心</a><ul><li><a href="#eureka-fu-wu-zhu-ce">EUREKA服务注册</a><ul><li><a href="#gong-zuo-liu-cheng">工作流程</a></li><li><a href="#server-pei-zhi">Server配置</a></li><li><a href="#client-pei-zhi">client配置</a></li><li><a href="#eureka-gao-ke-yong-ji-qun">EUREKA高可用集群</a></li><li><a href="#fu-wu-ji-qun">服务集群</a></li><li><a href="#zi-wo-bao-hu">自我保护</a></li></ul></li><li><a href="#discovery">Discovery</a></li><li><a href="#zookeeper-fu-wu-zhu-ce">Zookeeper服务注册</a><ul><li><a href="#zhu-ru-diao-yong-fang">注入调用方</a></li><li><a href="#zk-ke-hu-duan-he-server-jar-bao-chong-tu">zk客户端和server jar包冲突</a></li></ul></li><li><a href="#consul-fu-wu-zhu-ce">Consul服务注册</a><ul><li><a href="#jian-jie">简介</a></li><li><a href="#fu-wu-duan-zhu-ce">服务端注册</a></li><li><a href="#ke-hu-duan-zhu-ce">客户端注册</a></li></ul></li><li><a href="#eureka-zookeeper-consul-de-dui-bi">Eureka、Zookeeper、Consul的对比</a></li></ul></li><li><a href="#ribbon">Ribbon</a><ul><li><a href="#ribbon-jian-jie">Ribbon简介</a></li><li><a href="#ribbon-de-fu-zai-jun-heng-ce-lue">Ribbon的负载均衡策略</a><ul><li><a href="#qi-ta-fu-zai-jun-heng-suan-fa">其他负载均衡算法：</a></li></ul></li><li><a href="#zi-ding-yi-gui-ze">自定义规则</a><ul><li><a href="#zhu-yi-shi-xiang">注意事项：</a></li></ul></li><li><a href="#yuan-shi-de-lun-xun-gui-ze">原始的轮询规则</a></li><li><a href="#ding-yi-shou-dong-shi-xian-yi-ge-fu-zai-jun-heng">定义手动实现一个负载均衡</a></li><li><a href="#dong-shou-shi-xian-yi-ge-zi-ding-yi-ribbon-ce-lue">动手实现一个自定义ribbon策略</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="cap-li-lun-kuai-su-jian-jie"> CAP理论快速简介</span><a href="#cap-li-lun-kuai-su-jian-jie" class="header-anchor">#</a></h1><ul><li>CAP理论关注的是粒度是数据，而不是整体系统设计。</li><li>Consistency（强一致性）</li><li>Availability（高可用性）</li><li>Partition Tolerance（分区容错性）</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531234138010.png" alt="image-20200531234138010"></p><ul><li>以上三个最多只能较好满足两个，一个系统不可能同时满足这三个需求。<ul><li>CA：单点集群，满足一致性和高可用，通常在可拓展性上不强大。</li><li>CP：满足一致性，分区容忍度。通常性能不太高。<ul><li>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性。（违背A高可用）</li><li>Consul和Zk，更关注一致性，不在了很快就给干掉，但不是立刻。</li></ul></li><li>AP：满足可用性和分区容忍度，通常对一致性要求较低。<ul><li>当网络分区出现后，为了保证可用性，B系统可以返回旧的值，优先保证可用。（违背C一致性）</li><li>Eureka，不会立刻踢掉服务</li></ul></li></ul></li><li>分布式架构的P永远都要保证</li></ul><p>图例</p><ul><li>AP：如微博热门微博点赞数，后续柔性理论和base数据补充来保证一致性</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531235033177.png" alt="image-20200531235033177"></p><ul><li>CP：</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531235338672.png" alt="image-20200531235338672"></p><h2><span id="wei-fu-wu-de-tong-yong-ding-yi"> 微服务的通用定义：</span><a href="#wei-fu-wu-de-tong-yong-ding-yi" class="header-anchor">#</a></h2><p>是一种架构模式，提倡将单一应用划分成一组轻量级的微服务互相调用和配合，基于restful，并可以独立部署。</p><p>是一整套的较量，不是单个的组件。</p><h2><span id="ben-ci-ce-shi-ban-ben"> 本次测试版本：</span><a href="#ben-ci-ce-shi-ban-ben" class="header-anchor">#</a></h2><p>springboot 2.2.x+版本  spring cloud H版。如果cloud是G，boot对应2.1具体：</p><ul><li><p>boot 2.2.2.RELEASE：</p></li><li><p>CLOUD Hoxton.SR1</p></li><li><p>Cloud Alibaba 2.1.0.RELEASE</p></li></ul><h2><span id="fen-bu-shi-fu-wu-bao-gua-de-zu-jian"> 分布式服务包括的组件</span><a href="#fen-bu-shi-fu-wu-bao-gua-de-zu-jian" class="header-anchor">#</a></h2><ul><li>服务注册与发现：eureka，现在不维护了。zk、Consul(golang不推荐)、用alibaba的Nacos(推荐)</li><li>服务调用：Ribbon(维护状态)，后续LoadBalancer。Feign用OpenFeign。</li><li>服务熔断：hystrix(维护状态，但是大规模，思想需要学习)，resilience4j(海外，国内很少)，alibaba sentienl（推荐）</li><li>负载均衡：fegin</li><li>服务降级：hystrix</li><li>服务消息队列：</li><li>配置中心管理：config，推荐携程的阿波罗，或者alibaba的Nacos(推荐)</li><li>服务网关：zuul，现在用cloud gateway</li><li>服务监控</li><li>总线：bus—&gt;alibaba  Nacos</li><li>全链路监控</li><li>自动化部署</li><li>服务定时操作</li><li>分布式配置：cloud config</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200530223603142.png" alt="image-20200530223603142"></p><h1><span id="huan-jing-da-jian"> 环境搭建</span><a href="#huan-jing-da-jian" class="header-anchor">#</a></h1><ul><li>idea里面new-project-maven_architect_site</li><li>设置项目encoding  utf-8</li><li>设置项目 settings-annotation processor- 勾选 enable annotation prosessing</li><li>设置java-compile是1.8</li><li>设置pom：maven项目的的聚合、依赖、传递依赖<ul><li>父工程，project根目录下的pom文件修改maven，添加packaging标签为pom。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>dependencyManagement用在父工程，子模块继承后，提供作用：锁定版本、子module都引用一个依赖，而不用写version。<br>dependencyManagement用在父工程只是声明版本依赖，并不真的引用。真正的是要子项目自己引用group和artifactid即可，不用指定版本号自动用父类的。</p><h2><span id="zhi-fu-zi-module-jian-li"> 支付子module建立：</span><a href="#zhi-fu-zi-module-jian-li" class="header-anchor">#</a></h2><ul><li>建module：在父工程右键新建module，新建完了之后父工程上会有<code>&lt;module&gt;</code>引入了</li><li>改pom</li><li>写yml</li><li>主动启动类</li><li>业务类</li></ul><h1><span id="idea-zi-dong-re-bu-shu-pei-zhi-ke-xuan"> IDEA自动热部署配置（可选）</span><a href="#idea-zi-dong-re-bu-shu-pei-zhi-ke-xuan" class="header-anchor">#</a></h1><ul><li><p>在子项目工程pom中添加devtools依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加插件到父聚合项目的pom中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启自动编译</p></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531140623420.png" alt="image-20200531140623420"></p><ul><li><p>更新值</p><p><code>ctrl+alt+shift+/-----registry</code>，勾选允许自动编译：</p><p>勾选下面两个选项</p></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531141004199.png" alt="image-20200531141004199"></p><ul><li>重启idea</li></ul><h1><span id="guan-yu-resttemplate"> 关于RestTemplate</span><a href="#guan-yu-resttemplate" class="header-anchor">#</a></h1><ul><li>getForObjec：返回Json对象，或者Json字符串可以格式化为对象。</li><li>getForEntity：返回ResponseEntity，除了数据，还包括网络层面的状态码、响应头等东西。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601002520722.png" alt="image-20200601002520722"></p><p>RestTemplate已经被Springcloud深度定制，底层可以支持各种客户端负载均衡策略支持，也支持自定义负载均衡策略。</p><h1><span id="zhu-ce-zhong-xin"> 注册中心</span><a href="#zhu-ce-zhong-xin" class="header-anchor">#</a></h1><h2><span id="eureka-fu-wu-zhu-ce"> EUREKA服务注册</span><a href="#eureka-fu-wu-zhu-ce" class="header-anchor">#</a></h2><p>传统一对第一调用，太多的时候就是网状的，需要每个客户端都去维护对端服务信息。无法统一管理，非常乱。</p><ul><li>EUREKA作为一个注册中心的server，系统中其他services都向他链接注册并维持心跳。</li><li>这样EUREKA就能知晓所有的services的信息，就像一个电话号码本。其他service想互相调用可以来这里用service别名来询问当前可用的对端地址。</li><li>下面左边是SpringCloud，右边是Dubbo。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531165250671.png" alt="image-20200531165250671"></p><ul><li>EUREKA分为Server和Client两个组件：<ul><li>Server提供一个监听，供给其他cloud所有service进来连接。</li><li>Client是一个Java客户端，简化与Server的交互，是一个内置、轮循的负载均衡器。默认30s向Server发送一次心跳。如果Server多伦没有收到心跳就把这个节点移除。(默认90s)</li></ul></li><li>EUREKA已经停止更新，后续需要迁移到别的技术栈，比如zk、consl、nacos。</li></ul><h3><span id="gong-zuo-liu-cheng"> 工作流程</span><a href="#gong-zuo-liu-cheng" class="header-anchor">#</a></h3><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531183332365.png" alt="image-20200531183332365"></p><h3><span id="server-pei-zhi"> Server配置</span><a href="#server-pei-zhi" class="header-anchor">#</a></h3><p>pom.xml</p><p>2.2版本后，eureka分为server和client了，此处是server。</p><p>不用指定版本，因为父module中指定了版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># erureka</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 自己仅仅作为注册中心，不去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure><p>Server的main类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="client-pei-zhi"> client配置</span><a href="#client-pei-zhi" class="header-anchor">#</a></h3><p>pom.xml  同上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的eureka-client会自动引入ribbon--&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment"># 是否注册到eureka server 默认true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 是否从eureka抓取已注册的信息，true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>Client的main类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="eureka-gao-ke-yong-ji-qun"> EUREKA高可用集群</span><a href="#eureka-gao-ke-yong-ji-qun" class="header-anchor">#</a></h3><p>高可用原理：<strong>相互注册，相互守望。</strong></p><p>比如7001和7002有两个EUREKA，会互相注册到对方那边去。互相心跳监控。</p><ul><li>两台EUREKA的yml配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment"># erureka另一个节点的ip，互相注册  如192.168.1.2:7001  &lt;---&gt;  192.168.1.3:7002,此处就应该写192.168.1.2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 自己仅仅作为注册中心，不去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 下面应该注册到另外一台eureka，也就是http://192.168.1.3:7002/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment"># erureka另一个节点的ip，互相注册  如192.168.1.2:7001  &lt;---&gt;  192.168.1.3:7002,此处就应该写192.168.1.3</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 自己仅仅作为注册中心，不去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span>  <span class="comment"># 集群模式下，下面应该注册到另外一台eureka，也就是http://192.168.1.2:7001/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><ul><li>客户端的yml配置</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span> <span class="comment"># 是否注册到eureka server 默认true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 是否从eureka抓取已注册的信息，true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,eureka7002.com:7002/eureka</span>  <span class="comment"># EUREKA是集群</span></span><br></pre></td></tr></table></figure><h3><span id="fu-wu-ji-qun"> 服务集群</span><a href="#fu-wu-ji-qun" class="header-anchor">#</a></h3><p>当一个服务在多台机器上运行，注册到一个EUREKA中后，在EUREKA上可以看到服务的多个ip列表用逗号隔开的。</p><p>这时候假设客户端还是使用<code>restTemplate</code>请求的，不能写死对端服务的ip和端口，可以写EUREKA中的服务名。</p><p>这样<strong>消费端不再关注提供方的地址，而且有负载均衡功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    private String url = "http://localhost:8001";   // 单机</span></span><br><span class="line"><span class="keyword">private</span> String url = <span class="string">"http://CLOUD-PAYMENT-SERVICE"</span>;   <span class="comment">// cloud服务名，会UNKWNON HOST，需要给restTemplate开启LoadBalanced</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     * post http://localhost:8080/customer/payment/add?serial=cus_lalala</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> payment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/customer/payment/add"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(url+<span class="string">"/payment/add"</span>, payment, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;   <span class="comment">//</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是因为服务方是多个节点，所以需要<code>restTemplate</code>开启负载均衡功能去调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似&lt;bean id="xxx", class="xxxx"&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//这个注解可以负载均衡，也可以把host地址由一个cloud的application-name去zookeeper转换为ip和端口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="zi-wo-bao-hu"> 自我保护</span><a href="#zi-wo-bao-hu" class="header-anchor">#</a></h3><ul><li>一句话描述：某时刻某个微服务不能用了，Eureka不会立刻清理，依旧会对该服务的信息进行保存。</li><li>为什么？防止Eureka Server网络不通，但是Eureka Client正常运行的时候，EurekaServer不会立刻把EurekaClient剔除。</li><li>详细：默认30s一次，当90s没收到心跳就该干掉，但是如果短时间内大量丢失客户端时，这个节点就会进入自我保护机制。（此时可能大量客户端都是正常的，很可能是网络分区故障）</li></ul><p>属于CAP里面的AP分支。（高可用、分区容错性）</p><p>server端关闭自我保护，修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护，客户端90s没心跳立马干掉</span></span><br><span class="line">  <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure><h2><span id="discovery"> Discovery</span><a href="#discovery" class="header-anchor">#</a></h2><p>主启动类，开启Discovery的能力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//主启动类，开启Discovery的能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller，注入，获取服务和实例信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/discovery"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Object&gt; <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------------Services--------------"</span>);</span><br><span class="line">        discoveryClient.getServices().forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"-------------Instances--------------"</span>);</span><br><span class="line">        List&lt;String&gt; instances = discoveryClient.getInstances(<span class="string">"CLOUD-PAYMENT-SERVICE"</span>).stream().map(each-&gt;each.getInstanceId()+<span class="string">"/"</span>+each.getHost()+<span class="string">":"</span>+each.getPort()+<span class="string">"/"</span>+each.getUri()).collect(Collectors.toList());</span><br><span class="line">        instances.forEach(System.out::println);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"services"</span>, discoveryClient.getServices());</span><br><span class="line">        map.put(<span class="string">"instances"</span>, instances);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="string">"discovery"</span>,map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="zookeeper-fu-wu-zhu-ce"> Zookeeper服务注册</span><a href="#zookeeper-fu-wu-zhu-ce" class="header-anchor">#</a></h2><p>zookeeper使用临时节点存储服务的信息，一会儿心跳不出现就会干掉这个节点（不是立马干掉）。是CAP的CP，和EUREKA不太一样。</p><p>服务引入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--zookeeper client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml只有几行不一样，指定zookeeper的连接字符串即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-service</span></span><br><span class="line">  <span class="attr">cloud:</span> <span class="comment"># 启动基于zookeeper的服务注册</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><p>主启动类，使用DescoveryClient即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentZkMain8004</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于zk的服务提供方，访问/payment/zk即可看到测试效果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentZkMain8004<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /</span><br><span class="line">[services, zookeeper]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] ls /services</span><br><span class="line">[cloud-provider-service]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] ls /services/cloud-provider-service</span><br><span class="line">[ba35208f-59ea-4d70-b75f-857c5a5b0a64]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] get /services/cloud-provider-service/ba35208f-59ea-4d70-b75f-857c5a5b0a64</span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"cloud-provider-service"</span>,<span class="string">"id"</span>:<span class="string">"ba35208f-59ea-4d70-b75f-857c5a5b0a64"</span>,<span class="string">"address"</span>:<span class="string">"192.168.1.10"</span>,<span class="string">"port"</span>:8004,<span class="string">"sslPort"</span>:null,<span class="string">"payload"</span>:&#123;<span class="string">"@class"</span>:<span class="string">"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance"</span>,<span class="string">"id"</span>:<span class="string">"application-1"</span>,<span class="string">"name"</span>:<span class="string">"cloud-provider-service"</span>,<span class="string">"metadata"</span>:&#123;&#125;&#125;,<span class="string">"registrationTimeUTC"</span>:1590931922948,<span class="string">"serviceType"</span>:<span class="string">"DYNAMIC"</span>,<span class="string">"uriSpec"</span>:&#123;<span class="string">"parts"</span>:[&#123;<span class="string">"value"</span>:<span class="string">"scheme"</span>,<span class="string">"variable"</span>:<span class="literal">true</span>&#125;,&#123;<span class="string">"value"</span>:<span class="string">"://"</span>,<span class="string">"variable"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"value"</span>:<span class="string">"address"</span>,<span class="string">"variable"</span>:<span class="literal">true</span>&#125;,&#123;<span class="string">"value"</span>:<span class="string">":"</span>,<span class="string">"variable"</span>:<span class="literal">false</span>&#125;,&#123;<span class="string">"value"</span>:<span class="string">"port"</span>,<span class="string">"variable"</span>:<span class="literal">true</span>&#125;]&#125;&#125;</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12]</span><br></pre></td></tr></table></figure><h3><span id="zhu-ru-diao-yong-fang"> 注入调用方</span><a href="#zhu-ru-diao-yong-fang" class="header-anchor">#</a></h3><p>pom和application.yml和启动类一模一样，暂时用restTemplate调用，需要config一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>  <span class="comment">//这个注解可以负载均衡，也可以把host地址由一个cloud的application-name去zookeeper转换为ip和端口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestTemplate template = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>customer的controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkCustomerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">"http://cloud-provider-service"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/customer/payment/zk"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">testZkCloud</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(URL+<span class="string">"/payment/zk"</span>, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后可以在zk看到双方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 26] ls /services</span><br><span class="line">[cloud-customer-order, cloud-provider-service]</span><br></pre></td></tr></table></figure><h3><span id="zk-ke-hu-duan-he-server-jar-bao-chong-tu"> zk客户端和server jar包冲突</span><a href="#zk-ke-hu-duan-he-server-jar-bao-chong-tu" class="header-anchor">#</a></h3><p>有可能client和server的zk jar包不一致会报错，比如客户端太新，服务端太老。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200531213833705.png" alt="image-20200531213833705"></p><p>需要在cloud的zk的starter里面exclude掉zk的包，然后重新引入一个和zkServer版本一致的包即可。</p><h2><span id="consul-fu-wu-zhu-ce"> Consul服务注册</span><a href="#consul-fu-wu-zhu-ce" class="header-anchor">#</a></h2><h3><span id="jian-jie"> 简介</span><a href="#jian-jie" class="header-anchor">#</a></h3><ul><li><p>分布式的<strong>服务注册</strong>和<strong>配置管理</strong>中心(KV存储)，同时提供<strong>控制总线</strong>由golang开发。</p></li><li><p>基于Raft协议，比较简洁。支持健康检查、Http和DNS协议，支持跨数据中心的WAN集群，支持图形界面、跨平台。</p></li><li><p>功能：</p><ul><li>服务发现：Http和DNS两种方式</li><li>健康检查：多种方式，Http、TCP、Docker、Shell定制</li><li>KV存储：K-V存储，可以做配置管理</li><li>可视化界面</li></ul><p>官网下载解压，只有一个consul文件</p><blockquote><p><a href="https://www.consul.io/" target="_blank" rel="noopener">https://www.consul.io/</a></p></blockquote><p>启动参考video：</p></li></ul><blockquote><p><a href="https://learn.hashicorp.com/consul/getting-started/agent" target="_blank" rel="noopener">https://learn.hashicorp.com/consul/getting-started/agent</a></p></blockquote><p>比如<code>consul agent -dev</code>启动</p><p>访问<code>http://localhost:8500</code>查看信息，或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> curl localhost:8500/v1/catalog/nodes <span class="comment"># 获取消息</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"ID"</span>: <span class="string">"890e9cd0-322b-fafc-fe58-33728d41f305"</span>,</span><br><span class="line">        <span class="string">"Node"</span>: <span class="string">"treeMate"</span>,</span><br><span class="line">        <span class="string">"Address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="string">"Datacenter"</span>: <span class="string">"dc1"</span>,</span><br><span class="line">        <span class="string">"TaggedAddresses"</span>: &#123;</span><br><span class="line">            <span class="string">"lan"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"lan_ipv4"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"wan"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="string">"wan_ipv4"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Meta"</span>: &#123;</span><br><span class="line">            <span class="string">"consul-network-segment"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"CreateIndex"</span>: 10,</span><br><span class="line">        <span class="string">"ModifyIndex"</span>: 11</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3><span id="fu-wu-duan-zhu-ce"> 服务端注册</span><a href="#fu-wu-duan-zhu-ce" class="header-anchor">#</a></h3><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Consul client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--MVC--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--业务common类，引用当前项目的版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sam.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--DEV-TOOLS--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentConsulMain8004</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentConsulMain8004<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-service</span></span><br><span class="line">  <span class="attr">cloud:</span> <span class="comment"># 启动基于consul的服务注册</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">        <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure><p>controller只是一个简单的数据模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentConsulController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个随机payment即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/payment/consul"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">testConsulPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Payment payment = <span class="keyword">new</span> Payment();</span><br><span class="line">        payment.setId(RandomUtils.nextLong());</span><br><span class="line">        payment.setSerial(<span class="string">"这是一个模拟的随机payment，"</span>+ RandomStringUtils.randomAlphabetic(<span class="number">16</span>));</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="string">"I'm Consul Client on:"</span>+port,payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后就可以在上面的ui中看到。</p><h3><span id="ke-hu-duan-zhu-ce"> 客户端注册</span><a href="#ke-hu-duan-zhu-ce" class="header-anchor">#</a></h3><p>pom  application 都一毛一样，config、主启动类、controller和上面zk的一毛一样（因为暂时没用openFeign和ribbon），没啥可写的。</p><h2><span id="eureka-zookeeper-consul-de-dui-bi"> Eureka、Zookeeper、Consul的对比</span><a href="#eureka-zookeeper-consul-de-dui-bi" class="header-anchor">#</a></h2><table><thead><tr><th>组件</th><th>CAP</th><th>对外接口</th></tr></thead><tbody><tr><td>Eureka</td><td>AP</td><td>Http</td></tr><tr><td>Consul</td><td>CP</td><td>Http/DNS</td></tr><tr><td>Zookeeper</td><td>CP</td><td>客户端</td></tr></tbody></table><p>C主要是数据一致，Eureka主要保证高可用。</p><h1><span id="ribbon"> Ribbon</span><a href="#ribbon" class="header-anchor">#</a></h1><h2><span id="ribbon-jian-jie"> Ribbon简介</span><a href="#ribbon-jian-jie" class="header-anchor">#</a></h2><p>是一套<strong>客户端的负载均衡工具</strong>，如链接超时、重试等，配置文件只用列出所有的节点，Ribbon自动基于规则（轮询、随机、响应时间加权等）去链接，也很容易自定义实现负载均衡。</p><p>官网在github，目前也是维护模式了。未来的趋势是Spring的LoadBalancer，但是还很不成熟。</p><ul><li>Ribbon：<ul><li>本地负载均衡，进程内。调用前从注册中心获取服务信息，缓存到JVM，本地负载均衡。</li><li>负载均衡+RestTemplate进行RPC，可以和多种客户端结合。Eureka只是其中之一。</li><li>工作时分两步：<ul><li>先选择注册中心，比如先从注册中心选择一个负担小的Eureka</li><li>根据用户指定的策略，从注册地址取到一个进行。</li></ul></li></ul></li><li>Nginx：是服务端的LB。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601000553582.png" alt="image-20200601000553582"></p><p>新版2.2.x的springcloud的eureka会自动引入ribbon：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!--eureka client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--上面的eureka-client会自动引入ribbon--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="ribbon-de-fu-zai-jun-heng-ce-lue"> Ribbon的负载均衡策略</span><a href="#ribbon-de-fu-zai-jun-heng-ce-lue" class="header-anchor">#</a></h2><p>都是IRule的实现，策略模式。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601010519762.png" alt="image-20200601010519762"></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601010535970.png" alt="image-20200601010535970"></p><ol><li>RoundRobinRule： 默认轮询的方式</li><li>RandomRule： 随机方式</li><li>WeightedResponseTimeRule： 根据响应时间来分配权重的方式，响应的越快，分配的值越大。</li><li>BestAvailableRule： 选择并发量最小的方式</li><li>RetryRule： 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server。</li><li>ZoneAvoidanceRule： 根据性能和可用性来选择。</li><li>AvailabilityFilteringRule： 过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</li></ol><h3><span id="qi-ta-fu-zai-jun-heng-suan-fa"> 其他负载均衡算法：</span><a href="#qi-ta-fu-zai-jun-heng-suan-fa" class="header-anchor">#</a></h3><p><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a></p><ul><li><p>LeastActiveLoadBalance：最小活跃数负载均衡算法</p><ul><li>活跃调用越少，说明server性能越高。优先给他。具体实现：每个服务者对应一个活跃数，init的时候大家都为0，收到一个请求+1，处理完毕-1。一段时间后性能最好的机器下降速度最快，优先给他新的请求。</li></ul></li><li><p>ConsistentHashLoadBalance：一致性hash算法</p><ul><li>如nginx的IP hash，把client的ip或者url等进行hash，对同一个client，相同的请求永远在一台机器。</li></ul></li></ul><h2><span id="zi-ding-yi-gui-ze"> 自定义规则</span><a href="#zi-ding-yi-gui-ze" class="header-anchor">#</a></h2><h3><span id="zhu-yi-shi-xiang"> 注意事项：</span><a href="#zhu-yi-shi-xiang" class="header-anchor">#</a></h3><p>自定义ribbon规则类，不能放在@ComponentsScan所能扫描的包和子包内(主启动类和以下所有包)。否则这个配置类会被所有的Ribbon客户端共享，达不到特殊定制化目的。</p><p>注意@ComponentScan 和@SpringBootApplication注解都不要扫描到。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601111454364.png" alt="image-20200601111454364"></p><h2><span id="yuan-shi-de-lun-xun-gui-ze"> 原始的轮询规则</span><a href="#yuan-shi-de-lun-xun-gui-ze" class="header-anchor">#</a></h2><ul><li>默认的那个轮询规则：<ul><li>discoveryClient拿到所有的Server实例，然后搞一个int计数，每次取模决定返回哪个Server。</li><li>里面有自旋锁、AQS，避免重量级锁。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;      <span class="comment">// 注意这里是一个原子型的Integer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"no load balancer"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Server server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="keyword">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            List&lt;Server&gt; reachableServers = lb.getReachableServers();    <span class="comment">// 获取可用的server</span></span><br><span class="line">            List&lt;Server&gt; allServers = lb.getAllServers();   <span class="comment">//所有的server</span></span><br><span class="line">            <span class="keyword">int</span> upCount = reachableServers.size();</span><br><span class="line">            <span class="keyword">int</span> serverCount = allServers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">                log.warn(<span class="string">"No up servers available from load balancer: "</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);           <span class="comment">// 注意，这里调用了下面，使用了一个自旋锁。传入服务器总数量。</span></span><br><span class="line">            server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* Transient. */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Next.</span></span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"No available alive servers after 10 tries from load balancer: "</span></span><br><span class="line">                    + lb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">incrementAndGetModulo</span><span class="params">(<span class="keyword">int</span> modulo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = nextServerCyclicCounter.get();</span><br><span class="line">            <span class="keyword">int</span> next = (current + <span class="number">1</span>) % modulo;</span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="ding-yi-shou-dong-shi-xian-yi-ge-fu-zai-jun-heng"> 定义手动实现一个负载均衡</span><a href="#ding-yi-shou-dong-shi-xian-yi-ge-fu-zai-jun-heng" class="header-anchor">#</a></h2><p>步骤：</p><ul><li>ApplicationContextConfig对象上面去掉@LoadBalanced注解（restTemplate上面），否则就会使用ribbon自带的策略</li><li>写一个LoadBalanced接口</li><li>实现接口来一个choose方法，使用discoverClient去根据策略选择一个instance</li><li>在controller的请求时候注入这个负载均衡，choose一个insrance，拿到uri，拼装请求地址。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLoadBalancer</span> <span class="keyword">implements</span> <span class="title">ICustomerLoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">chooseInstance</span><span class="params">(List&lt;ServiceInstance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instances == <span class="keyword">null</span> || instances.isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有可用的服务！！！！！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器线程安全得+1，对server数量取模</span></span><br><span class="line">        <span class="keyword">int</span> i = incrementAndGet() % instances.size();</span><br><span class="line">        <span class="keyword">return</span> instances.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自选增加，获取下一个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr,next;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            curr = integer.get();</span><br><span class="line">            next = curr &gt; Integer.MAX_VALUE ? <span class="number">0</span> : curr+<span class="number">1</span>;  <span class="comment">// int不能超限</span></span><br><span class="line">            <span class="comment">// 只要没获取到真正的curr，就一直自旋</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (!integer.compareAndSet(curr, next));  <span class="comment">// true之后就中断</span></span><br><span class="line">        System.out.println(<span class="string">"------------------next:"</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller，使用上面的loadbalancer手动获取instance地址url地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试使用自定义手动负载均衡的方式获取</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/customer/payment/lb/get/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getByIdByHanLoadBalancer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt;instances = discoveryClient.getInstances(<span class="string">"CLOUD-PAYMENT-SERVICE"</span>);</span><br><span class="line">    <span class="comment">// 使用我们的自定义轮循负载均衡器</span></span><br><span class="line">    ServiceInstance instance = myLoadBalancer.chooseInstance(instances);</span><br><span class="line">    <span class="comment">// getForObject 返回Json数据，可以转化为对象</span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(instance.getUri()+<span class="string">"/payment/get/"</span>+id, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="dong-shou-shi-xian-yi-ge-zi-ding-yi-ribbon-ce-lue"> 动手实现一个自定义ribbon策略</span><a href="#dong-shou-shi-xian-yi-ge-zi-ding-yi-ribbon-ce-lue" class="header-anchor">#</a></h2><ul><li>自定义策略，实现<code>IRule</code>接口，或者继承自<code>AbstractLoadBalancerRule</code></li><li>在<code>@SpringBootApplication</code>扫描位置外定义一个Config，里面配置我们的自定义策略</li><li>在主启动类加上我们的自定义策略配置</li><li><code>RestTemplate</code>类加上<code>@LoadBalanced</code>注解</li><li>controller正常请求类似</li></ul><p>自定义Rule实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRibbonRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;  <span class="comment">// 获取服务实例用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 人工实现一个轮询策略，在主启动类使用了下面的注解引用过来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RibbonClient</span>(name = "CLOUD-PAYMENT-SERVICE", configuration = MyRibbonRule.class)  //为每个服务定制规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义核心方法，挑选主机</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Server server = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            <span class="comment">//List&lt;Server&gt; allList = lb.getAllServers();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = integer.getAndIncrement();</span><br><span class="line">            System.out.println(<span class="string">"MyRibbonRule----integer-cnt="</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">                integer.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            server = upList.get(i%upList.size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The only time this should happen is if the server list were</span></span><br><span class="line"><span class="comment">                 * somehow trimmed. This is a transient condition. Retry after</span></span><br><span class="line"><span class="comment">                 * yielding.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选了个挂的，重来</span></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Shouldn't actually happen.. but must be transient or a bug.</span></span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig iClientConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        System.out.println(<span class="string">"--------------init rule-------------"</span>);</span><br><span class="line">        System.out.println(iClientConfig.getClientName());</span><br><span class="line">        System.out.println(iClientConfig.getProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据一个key返回一个Server</span></span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似&lt;bean id="xxx", class="xxxx"&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//当调用服务方集群的时候，需要加上这个，然后restTemplate请求地址写cloud注册的服务名即可。</span></span><br><span class="line">    <span class="comment">// 自定义负载均衡策略的时候不用这个注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">getRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRibbonRule();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient</span>(name = <span class="string">"CLOUD-PAYMENT-SERVICE"</span>, configuration = MyRibbonRule<span class="class">.<span class="keyword">class</span>)  //为每个服务定制规则</span></span><br><span class="line"><span class="class">@<span class="title">EnableDiscoveryClient</span> // 给自定义规则用，这里可以获取实例列表</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CustomerMyRibbonMain8083</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试使用自定义负载均衡策略的方式获取</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/customer/payment/rule/get/&#123;id&#125;"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getByIdByIRuleBalancer</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id)</span>&#123;</span><br><span class="line">     <span class="comment">// getForObject 返回Json数据，可以转化为对象</span></span><br><span class="line">     <span class="keyword">return</span> restTemplate.getForObject(url+<span class="string">"/payment/get/"</span>+id, CommonResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://blog.csdn.net/qq_41211642/article/details/104772140#comments" target="_blank" rel="noopener">https://blog.csdn.net/qq_41211642/article/details/104772140#comments</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cap-li-lun-kuai-su-jian-jie&quot;&gt;CAP理论快速简介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#wei-fu-wu-de-t
      
    
    </summary>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://blog.sofunnyai.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>基于贝叶斯优化的机器学习超参数优化（未完待续）</title>
    <link href="https://blog.sofunnyai.com/article/bayes_optimization.html"/>
    <id>https://blog.sofunnyai.com/article/bayes_optimization.html</id>
    <published>2019-07-16T03:26:32.000Z</published>
    <updated>2020-05-28T04:48:30.411Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="wrong password, try again!" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="Password Here：" /><label>Password Here：</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="5e7467d5ed7fdbaca4eb59cebea7f9f5bf13fe802440dc00f39b470570a7f946">883a8d3a732ddffabc77395481c6a54baf8ea99e822cc100ee48e18be5f2ec121781a469a7f81b7a45f54262118a757411f4f42ca30286150c3f1587a3e10d67c993e7860b2051958b5361aa3d0d915e5b63e343ebe2855eb6cee2b8078aedf6018f883fe335bf4e34be349e5a5e0039f6c0e2640fe0a2803afba4f2cd160afe0a37af070a58b845b59abf323ccbb1a4e1d58d6052c5f63eb0d86f3841888d5b661931f7a3ec7dd8ff8f8bc612cd6ed874e5b865ef156c0c4d6e913cf2634ec4fe1dce151b8fbb8c1580430513c92d980f7b6f139985478227eaa3e3d497ecbce855df3fe0fd4ca15d12f08579f83d26e389dcb10cfe805312613fc0f6368f5474a9e6a542f728487f0b1fc8c10ece84e314d7f450df4cc6f9f863a197f3c41f147a1375ebd42662c47a8125f50257eee9dc1316a52d70f0acece593295a40ca27d155f2db091fbbdba7a52c1f6a3735b84942ea7fe3e5246cf2dbe9bd6077590e6a68e8354f6b0664c4afdeca06278f0d23c8c57de9e997e7d23b441fcd90ba4abbdb0ce0d0716e3390d8277d4acfb0262cdf0e37238d39bc15594ad6240b278e327c5d2e56778e988073fedff3568831376d521579150e5d1d9f06c3354c50fce5c1ddebd05d1ffa7207fd8a929d284c50226e42c89ba7a1f59c495dd1139bc50719d991a22483c63ba0faa0c4ed09dbac8968a3e32df09d6a7a062c96e35bbcb21592808cc3d6bbfe93ac9835b1268cfba5bdad40e5df100c1e4605e578fcf5e5cd0a955a65ea524ecfab6cd3b0fabbea677a4e716f4a13be3f8c32232b5541537eec188377fbb8a91e41fe08fcf66994be8d728997ed16d4eb829feef888aca3a62ccf6d74008d6429b0067414163ca50b0c3f7bbfc2db1033ba2e072c996e487029bc9e5b96be2a1338ba3a00572e498d3e36570d9af82d9d7a981c7f7991b1d1b81fa396c1098203f41d812d19c5300b17899db63b7e733e4a9eff40f90aca3f2c2152d49a9b854e2db7bb5823b08d1381c824d6ada55195c33b7c407e3b37815b2afd1935ffe6bb6f7da2a36ed128d09a4d18131269634ad44b16503e0567d0fbecca4a468ff2dcf57396e4c89c5b9fcbe39e31703a27ecd05c2362b661707b95e4cbacf2be49af50c106c5fa49ad0177d19aebc2353cc05e17d07284957f11e7fa39490a0c434e04ee0c6458d0a7c2341079e8b1c16f740a6128c6396db2d729d637065f2c923b1d1fec11b7aaceb98bdf701dcdde2e9c0732e21d780d3a48b5954d42b3e69faa386b48991ba7d8d4a4818c4506be6f0ca10ea51777994617fc449799bb352b2ee112c4e61f098827956bbdea166483b554bc31418fc057d440754104267fbd5f213d58759168f25ab273dcf9a42fb50204bdd0b18c52f4ec027f8d6877248856d3477ede91afddb701efad299609f08607ce0e1ad46cda32d4b426d18f012dfb3c7b72f472238aab9ace30b7f0266301ad486a99439d623b22233f86f70e16978643256822882daac00223c67fdc496b176ad74c61b99df66979bcdf94a7c3b45b15a7e1f109248295ea45f33d137d37943b2fb5ef696aa7479c742c93ae4332512a806b358cc324870b26e85f2da39e9c886dbbaa48df66e5d766de6985708eda7817afec3bb4fe91937787109a75f58c4d66dad088e5ec1d4dcb6c84a97195dc2c00bef55d306d8e30a861dded40a60a2bff6b9d0c1abcbcbed06e7c8567a7430efef12388943749f2546d2535b5ceb6c1d76554f37c1a66fbe66d7767c26065052dde304e4dfb0250d8caf5d341e14c8034124da990629e5b46a9b7d29d87f6276101626bfcc831173c7d70f6ae23bf822afe7a27ef9772d968a276154efd9e4b920ec3264a7d3204c23a639d704f57ce4b4dfb6c8e297c7afcc0a8b318077c9636effbfba6d67db7cccfaeb97dedb5039ca3f9117fde10263c63916dece84c73694285219b42d19b88f2afbf68a18b12ef50937d80df3389f89b8704464cf81ae7e64555c5a364a043f64785f76808b1fc9926976d82d66e4a44cbc874255040c6dfa7b0065c86bc0b637833376eea03580cddb9a29bcdd1da9334e096d3c5ded27aed0dd3ef92583dd81c597593f2113cfa4a82cccc83a2fb47f28f3278c2462beb94b46875442b5c0d6089dee3b121e8e93f0dac199bda0a77355153a67648db77deec59dd668aba539244a4ef2d5407bcf871157b0347150661d0b0541badf869e8ce21c9d0a0c1c2091e9614ad7ea7b8d086c9952e46e4dd59cf5eafd2cd3c57dd71477b0366bc3c83c945d3ffb8a0614dcbf20517dcbe7d61a6d50f786b76fd1cdd61ff4ae37877dd1a4f1db647c9aa168eb8ad00eea5c081e3f92486b1340f35e260aa2db3d847d71aafa2aac1232464f6b32cced0957aa5332f1640d043a55717b6c259c84bceba323cc59e5e2aedba9ccaa154929fad72795301788aff5450eeebc09914ad9c9be6ed41345e1459496e01acd0a0cc9113b49152aa73060e8f29a8731d5110c9c13d0b1c30b2bc28c3d897c1545457d443dcd377f3b73ad25adb73c55a0b6d77f7e239900c6ddc7859a61bd98f3222377e7801660b2abf7826c011578c91c28902709e55706a26f51fb70be497f7b9158ffbaadd0b6bf818b2fc7b69702495c65c9613dc09ff33db8a43afc87d2c695efdd735bb3287fea84a696851f3b1277ed64c12a57e78c56e3b7dbd08959aa95ad9943a3f7bc49386e3b96bd680a6678815625995f6bd14408ee2e6eca72dd83577b5f3fc3803c2c4d928e8499dfd40240135c5042297de8cbc0f3e2a0c80a5b223f623e05911d2cf5c619af528a32e35af1ae501874bd80b202d8a4f4ab333035f80fa5df7b534db06faf2454112b0e767fedceaf59c9b9087e0a671fd225bd40346f20ac2efa3bff8f50a7f883e14a7b2a725a27015dc243af703bff04544c7f20af2a05f5404133428780664e6b152feb35178ed63a508f802afdddc74ea13037d08ea7c6e5f6aaaed695e2f750da3355fb3e220908a7c10e0563801853118ccde32553558e18375f60f3916f1d7a2efa7602e4d1449222cb9db130f7c056a2b32696448ec7f2e4cebf09a6979438e7b09269cf72ee50f69833037e57b9963b17d26c0992ec3d3a6ed05ddeaadacc8ae00784c09e1c658d12dce38e8b5e2da734fcb11ad54cd659eeb1910c162a2a3b3eff9eec6b0317d77f01fed96badb7f1949e17ec452a1cdf74b5e39bff05147327dee4fb0eba83697efa2ea68cedfc7512d96de62950921c8fe60c171e4fb888878c89e707259237fe0dc3a9f2c21afd7d7d61ab17edbcbdb7d84b695b40493ee6e13cad8c7899fe25307e08ef74ad50273b073a095a8c6578d29c6da3425f9c9094b884cf93a259a7cf05f19e7aec2849542aa550a1258826d86df9fb88fb2e8e30d932512da5313ae02593e33a3007b25874b88e258442aed594c94c43d377333c6cdb5153826a6a8f1398c66d7fcb2df11a57759fc7981738b919d2dc1f1164145ca2bd0aa8fc91f4a386f1fbf5eaf0a60d5a8511baeb503e492f946a5a91dd4e80fe405917a146f768e4ddc6146e882bc9b5af282b971e69b5477c7033c91635b69b6a6e67f524d79a21511af7271806a0d051233b1e8fe15a5dd74676853f79ee364f6c2fe4b4708113b256ff40f78040ffdc82c4dc7d3765f062cd5748d4ff9b3c8022d93b381a9d75451a4f322a21e27378ed860e7f507e834fdb0d30136d2971c674cc4d77df3cd02e3d81d4cfd1a3c6fead01a1c4d6a579b6ceb5627a5b71b7752d1792be8645d2db896b25d690606643da066573977bde5ce5eca350679c16b0419f1f38fa2602de6f777813477db12e3032872844402b8b0de81f1270600799c24a69985b1d6aee24e28af6f0b8a75eeb43b0cd142db483ee7f9bf33c2640267c352a285b2fc0fcff6ef51eb46b7d082510437bc856470eac94e1123d60f11fbe15c5336347fd5b433ba18bef3f15603c0e734f38fa74babc76bf807d6a1172bcfe01034afc64f6f3656d0d3dfb882a705054776fc50b09ec2fbf4e00839a6997426bd4404e1fddbe3fcc4716078ca2102f4e3e82233a814e4cc7e3ce7eb52dcf3e4492080dcdacf371d3611b7c4b331e7ceb122b014093033120f2eedb7274b3b1f5dcc5c675df382994eb1f6a7eb3be90edf451d2a39403a4fe1d372ebad2527b6f794335b9505f1bbd58553a9eb612fd2bbbfbf2674685ee38fd36446336e5a43550b45df853c34dee91ac6969076e233ec21a0ad21df3bc031158ea72e88ccccd7adb52f2ab67f3e658f89a0c23d6790279db66bcc0eabc913bcbe88e10fa548ec1dc083991a72c6953edeae46392fd6168808e3ea5665e1621f7f921c073f457e9faabb5727b67d2548125f20a83c9be8d819a71c642caed651160d8c577c7c95a26381ffc23418dfd89846349b397534f8cdbf929eee8e5f97ab11533c623fc3002429c9026aafe10af4aac9843a6327e8a74961f5a1e61d39ca4edb08c56d1987dfadb4046e9da27e6b570dd98b37e0ca941adb7b072a638b4bdb0fb0bea00c4b85577051ab6d4ee7d36a3ec04fa72fa300ca63a21f0ccbb58bd52d48735c95e9fa3e0f411b2f8c44a3892a17ccd08eda490c38eda2e7d643f975dbf40826452570fd200f8182876bad3ef68d0ec5ade8b085e59ca08e2034fde5d30cd178a65dcd01225c25a5db369498d83b34cebab0f18bed53cd2cd69069f05b0dede2ed4d270d12717dbe1b47d935d151ae2f95d8a5a91a87dec5ae08538c32ea40152f592773e0c8be14f8e6a73502b3af18d1fe94ad6b4b0565afe38d89fbf3633eaea4a350ac191059751f8a9ff2f3c9d56d9a0704fefc24ba138880fb3f2ab2bf4dbe5e20ed45277330dd8a49f70546d238224596a1b494e211892a72ad4d28f22de5a9c0e2f18011e9643d7de5bb970bf7e45be9dddcb7b96ec4e7351bc945486ee0a49969f5cd92acf65f6d227b0e05a0b86102b2776f47b4b8d5e82cfd5f452c6967491d68205a54e22efc4a60ac905080cd92ff3558cc986487cb29091b77b91c80a006d95f1709f4029314ed0a2b081e414f34d43de822aaf37ac4a61e3be2e27724f46e1c7a372dc79c49a88b8fe80fa490d77f2e77257ece92a3e52122fa4979096b2b799453d0ca9798bf350c0c0ce7aa7d2bfdd99d4a468f25f899ddbe128087a629bee30789325d06f6ed558ba852875186588f8cf380e2fc8b4196eef264ee6f2f299038b1a5ba801fb27cc73575f6fd5559a6c5a674f570016411bc76aa2a8778f3e1e822d80e4ffc87a438f3be6ceffbf89cf0b7fa7065ab35e23f7e45a2491df11c571c0abfe22ff678b658778cf42320f81403bec2d0d76615fedce9f727b7cb036708f7278feb6e1cbc981969a45b2f66ece82d066ee49eaaedd2a650bac9ce9b92ea78821a7a1c3fa7c834e45d53a6673e7cec3be409b53bd99cd409ee2adb28ce925a3e3826b05d4644e7c5a43b99babdfb09ad896d9e5116ed4868ae8e5ae46a55138e38c276a42964e266bb78c57041726e2173a99f58a4226e7f5f7b778fae578fd7d2f4b9583ed31ebe3f55a09997f4906292203435d7f4f7c827bdf87344f2796de49a3402c9bf0b70aa2556fa36a9bd9e159a1ff65bf65920fea683c84fec9b78703ba7d08b2518257b3596d9038e45f35e73f25faed5e247945ef64de471821dd9b44921ba6766bfef8e99ac8d0622f6b05117897be28021b5e23521ed6c4e9e300042e114b637e26463a883e4ecf7a72628a86e8fdcc2753284484b26d6af8a3c931c3e4b3972efb7b1ac5025975e136f8801edd8f683729b896044ec1709461f4f03ae1d5d9cbdc68e1f9af6540b5a820015c179237ecdc429a1b93ced120c8f9c5f9f6e696b2508080802208a4a3b92e513ee5b4aaa83e2393127734c778768e87156ecdcdf8f5bf08a1fc8217f53dd6a5b68293c82197dd26a4be139169bc6e2bdefb1963fecbb349ba3be9d113dd6b60f09f2f6362561fcfc41271b8daab86be522130e563d1417a422837966b29d3d8473bec529c8cdeb5468463e9ce29e4b34083c97bc2d428d4439719fb01afd3820ba9dc15660e0f941c4b4fc8a7f855cdcbb34b0631b9d55bbc6bdb224daafd72d2d08f331cd1973f5b691ce3a38581052cbd13d0c909621844a61ba4d96f34852417f6387448d849c81d98695132863bdc3bf5d41de4a27733201bf30a314dc2a68d445d5306cdfbcdaaa58c2492ab5c850270637590c4ff0669f1d6747763878047b3fa891b59a73be7f244b1bb53ff31949af339db09bc6df6aacae22376390cbc7d8072966c4e7dda1b1e7b02477cc213d09987f6fdd8d829e07b7a40a939668dab77eed966aaf9c55bdd9fa982c3565d159a3c636a29d65935086f7f4a9a35309275dab2517125dd7afdd0eeb3f60c1ff938c4e8c56ab307070b29d6d5ace68ad2fd449cee0429dd5459cb642d7fb5f03de9c80df329aca372b3125eb51428d75361c39157507693a00cdff3145783a24ba77c6eeac408ac9705a941893b4ef791e6fe0577403af156b9d8c044118bb3bd5dd9307a911c2ac9bac45082c8fd1f14669819e837b67a537bce4f82863041f41230fb5ab4683cc4488a1ab18133a25881d3fc2e63fbec5d6171d41ce6e8bc66db8ef6046a448b5c49e24dd68e8aa378ec82d9ea793aae62fe11853b49ea95dbf4e476aed7687ea6579f980c64a37ad4b3f183cd49946a92eacacb887f637afd1e224154b5a96faeae0abd2f6ac42f6b7da49334137a491fbe3694c9431b4f904d980175bcbcc2795f47c2d04133afa916ef387e2d094bc1939f7ab56086202e69469d6cc8de7de45f307278e522e5bb34aba87dedd7a28c69ecdd3c528bdcdda1b1e7c6547718c5cc9f6a0f41d319ca1bcd6cfc79febc4542e04eae92245b4361e03b48cb23cddf971e2b30e77824a49e6b9a0fc83d19ad30d5eb8c3e5b47068ce578709e09b6bb66b6c918b23c3d754b4f4ca4a0e180973f892a97a3c58079292c9acff443106585820a117d89dc97a9bf69b3574fe34df02c85022c252c0f29267892a9b37c697af060a3168b14497b629e9389b7fd4cc750a33771e552b3af7cd58616d1cca43f3789eac6f1fc305c59716716ec45b5618158b3aa0ffeb8e04d9e8f5d025fb503a7dce502bd06be331ba2fb344e89c002c18f6dd0f63f97630b4cb9825517c726e2ef35904cd5f67e698f6f7aeacf76ce3a79db02a3d4176b18e6344fa0a1a9606dab52ef7253ab58885f76e1a65588c78c3485e93cd5354a41dc5a71193e2b5cea1a642799d86872ab0220b2ee57e23685ae0324fce3c10c4a7333c69dcf065f63bdd804a66fa821769f06aa8c208dbe64eca6d0d78a01394b3c0f41a8bc004b57dad2144a17008b8b58808145e11bde513e9339833214730ebaabb7c05f6bb2d63bdec8bcfcfd4d76997efccb98f1090f9165fa1b6a91e9ec05e31d0262e352e842a83c82d30215fc54e3c6c3bfd18eed53c9260374d51d9f3759aa0ecb8350348b5c21aa06602d2907404f9cc5fb935150902614fef7a33c0fee9c659435ccfec4049aa6199025bad37b51cbf63691525792af6f808c4469a5f7f2bef62e2e41fc2d64d27fc734ffee1a9ff95992f6610b47c560bb6233b7c9408c082d27fd096d6da59c6905ccabe510a9c4e194763cb6e299b2daceab1eb1e932d712d7d9d6b6d8e64a44fa9e702ab040175f357bd2aa0eda9596bba72df962c1916ecc21c522560a49eeaf529ed3a42a25bd783e1c02aa99c0950269d4f88abb5bd6f07f8823cb529c787c8c0655d124231364e9e614596d81ec98ec2fde26b9d5686fb4f2603f78763076baee301f511bfaf70d78ff8327479dde16cb4829f546d8c07aaf4e76e22c4e9741468b4f64b3c638f0a4c8ec1d70db44aef7a3a7d0b622d3ff32f6f6d1812e71604b2eacff7dc293342d7b216162a740f6dc50780bd07693328f9a14e683cdb8c95bd95481c07f281ba7b9b9e6d0ce855a8c8f58ec3ea3fab5ce492f0d4c37d01d97e577dddcb37a1a772c63cb8013e726c0e185d160a39c9114889ecad757a7501eb9497adbae255767f918539b4d736407ba336b76a592800ba1c5c427eb82e6c84508f07c8784e1f0644d90830619eb535cc7857b6db793ae5164a3c9aa58177d7aa2ca879454520bb22ca7c4173796ee2eb34258d2be25b57776519aaa49be8d6089dd09fe8750c00a95e246e675561ade239813dd3177b6240cfd605ff45fe43d5eb1d7e3e791abd685bad38979a01a6eafdd72098516122f8a104fffc061aac1f307808df1f80855f91fda31c51820219c464e492a2aef34269dc161dcf1547790033f4c315c72fdef90b8534243572a77dfb13505ebf6b2abdd04cc15309b38e78a3feb5cf18f0dc6d8c28d9d510e56306a5d2085d58aff70f0ec2f04f1c0b79f3ea932525cf3e65475baa523748fe66c5e3015ccb29894a4879d0bb4d8f6726d28baefa57d65ef656859b5ec0908f17c34ee2276b03aee7c92aee6a2ffa67c3acaeea03dc478538298c4b2a915ea106db8a3d790cf55e55fec2ffa0874735ffa01c50fae957228ae133c48f4523adba8a24237ef0528bd8b14c6d00d9dbff2e468cd42c9d36042bd77418ada6b9ba0cd3e7d9538142c15f058f6c55acda6cb986ca857739980aa6d62fae44d9bd0e5ee432bab4548d9bbf496e9e22a5e83c6b8de7d1e00e54c1367eb8f126cba6c3d9dc7f35c67e2f8d3ea546401f66ade60e5c4fef8c32e50ddf4aa47ff55f66c9007fe40d4057755aa9b775fecdabef57a92c64f208dd527c6251f798c2f342db06674830a43181d5201233d7d92c85f73a25bd0c706eb64ffa641395af566ae633c1c63218f06440de4f395d5c21984d6a371ca36b2d5d3ea2310a29f6683c850dae0846b95d4dd0d94eefdab0df2d16c7ed1d2caafc777bd6fd8f9903e815fe3c7f644e309799607a4420369c8aea3ed67259825056b34f29b1768bf4d84dbeb86970014ebf6d5b0f5d4aa219d4bbc406eaa7b42675715e69e90edba7c41605dbe72416d640c7a88f8a8fefa6492c5f57f496b7bdd333c4a435e372d3c09e24a5ca253bb5d9f64eb53ae2920710b0217f21856a445623fddde123c2a2b78cdda12b3574c9243121ebe4829f546ba29b30fd782bd11d6d1f5c591d32ae6f1bf6bf8a2bef693540e61685c69b3a458f21adf2c71f5392edf07c7e05550a6c4ed27036c17fc362223b9b6234840c5507bb2746cbedfdd8eb9d873ea4c4e89ddc3f9580231ea3c3b2aaee90dd9de01a1673b40afbeee1cf74ada2a5fbc91ed525f6d231818452bc63adad7ca49b1368bee1d212c6bdf381f4d3797ff55bc71041ed6d13b2ec4b386f08dd0c56d62e8ff3824a03a0e29e2e39f4f8f72211dc0637e0c84e35705657ed181f1a7ad523914cd1299e7230dc42cb2b8764622dbe92b7e4b819b183cc5b6770e39ce787411c64b82640b3c79443e8b0474f5a6156f48913121a655156baf0d563ea847d2e23b06f08c86520574a218a926d7cc2f7bf3814f316ecfaab9c380012e8f8553a7525ac967e05a3b528d0c0807a2075910b165864f99a5be71cfe81556f90c2cc2bc1e63008cfbbb6bdc93a825047d27aa83e43ccbed6e5e70c66099940e7ae698309ac17707fe648b37934a1038ed6a24720d0cb7bb1150db90abeecb128e233ba440cfab803db7c7a71a9dbf9f9164c2bfc90cbcc8cba438249d3d616bd972ceafd48c231b6dc52159453c345b60233d659cd823ce7ed162e0db07f4f323e8f30f0483dc6a63d570d62d0f91048cb63404262fd30f429b3709e8ae14d399a2f67324ae8d07035de8134a3190162adf6c9eaf11120d6fd648ecd3d65473d76ce861e2405506f0c5e5e07c1490f769da70494173993ca85748c66c7fe0dddd9ff12fb37316631bcabe9c83dbaa4f4fce81b355733ca5f6f623929c03abf3f369bf46d2930f9f2245e0ef21e965e1b3f6bc26d6d6ba74cc71bc1d780f49c5d00409d755e3852ce617bc9260de2e9367ff165fd8f576097e0440fc769b79f435233956693c1c7bb50eecba2c417aec0c16d8a70382a9481525701f9b1db2ca54e13809a9f3ee6fa66894f2be36b19eef7f07059dfaf31c4a900bd5848aa1ebc34947c770a3c296f864b621d17f6af63eac2d91050e147ea93269d818dab9b33197ab0c485ff8754c77f6473c94f7c2471a4bd2d8a723269516a9b2c3434af1691c3461ffbdba363da7d2ced34cbe50de2b5d31235c23620e313d9bf775cbf1e919c8ba3f0412908c9e9f74d59742f0cc967e5c414b3bd77194b52a063ac44f248d595d0e7bde89c90e35fe2453a4b7e2e02559abd52e847301763d3881af5f97c3c433b06585665cef80ff28c68e6fa3f8a65ebe4449a5fc511bdbdb3e2ce3bde49cd6737fc849ef77dc5a541edc47e6b6dcbd58eeddbd35f1142e5adba410a0f6732fa8bfbedb45c64ce10841af7f366021a62394d187183da0305f682ea114be46774cd720e6264424e7196f4839762bf1e8def029934d6d416a2925f4431791a77adcfb1b5c2a8a5cdbfcf4dbdb788f35fb66efb0ae1a36a445f3d38c6c96084145be6abda8783eed3856dc38a9b77ebba05dc277c60297c4f0c7ab983d750c4652ad6cbeca4d41e7d5652a943103d3c4cd0addd18b9446b72d1414dd2ce77e605f5d5c7ccdf407d5dd5d48cc32792a8e8a2da4799dfffbdc2eefd173c1053820a7584f78235618d75060edf8f8c7b62bc4b408f886b29af4bc449fd1408a814e83a3dc33a4185e112c91305384544cd74a10b488c39cf2e53a3f73ede1a2a1e98742c368bdfdf273865c76827853c4b4cf1feeb0d6ae0ef9af2a5b7bac61ab8cd0af59549ff4ba5f19e308acfe527a7cbc278fc858c6a23c97bc073258f2938ac76644e30e999eb166421b601ede9bcfef16696aa1f8d307a3fa6b369f728083d61665d6e81da7bf866d466894054e6028ff2d55b88811b104446dbf6db8f40220ec6b7f27f57f220cc8b5836b8e60c48ed9cecb3766905f74537045ed9f9c334505afb2a4d04a6a43caaafd616dba445e1e4561811ab71fcf37729275f5c100d05848811a75ec516bc1fe050ee0569ce314a96d0519d4edbb6617d5bf77560d150e5b1582b5cb73f31a9a4912c0e28e9c7f54d5cac902feb4e9cb7d5ca8bad3ad2e7c12911380662fa8ff7010b4463d727efb8a5f962ef869219289baa9f9509b5399342a771d602533cf8387bdca7dea978cc02bdd1824b2e249b8dcd2d88b7796439cf020dda3cc13f4ab0ff039720d02b89ffdf653c64181d75a1d8c7622a9779f0e54c99dafb06a0a36d762bfe65b3cf6abf0be5aa4a4d8a3973f8dc764e1233bd2356e0ee55cda4301372c5277ab782e4626e48ee93b1407b09dafb562580c5b1c91973252be7f3bccbdc7c2f1056248d8d81b95d9cac805e8b337ffcc23d454b1f7a245f0f85e40a869cc673ea219b0868516694957f0ce916a28f8ae4ff8465a1e39c1e998070f45d8cd8085b068da655f5c9fbd4b088a28dad876b011ed85f1eca8e6c378fbea01b9da3f5f55865fa7a9153b2dbc1b72dafb532bab68254908004eba9ec9f23d4f4caec5482a80c5a259f1c7e8085e6885c22e38c09b39b1b6f4055004165bfd9c0e388a289a370068ed1da56c625f4dc475f2d47e7e46237bf7be71e8119bf6bd5e6132cd52119ca11c243686308bab9d153d7828b96cd19d0f05e667996922d96339dedfbd523bfd480c93d5dd9813a3a2f4063b63939db7b60538de86f4234d8faf12b66e5332a762d8667f34ec39b4b6daa2106df9f1446dc256e9c20665522d225447105f00e7042059d808ce0ca962e15c013fdac320c65c89ca0e69612eb737c2ee4d559dbe36adda2513ef7bd3473075cab77d1385863a0f21b3a4b6142042d73988c39cb0c22c501890d15b8613a19dbdd8de388652c5d306740aea456a24a57cc589e7ce6afa1e179b3377d9c6a3fc0804c125b0e153dd09e6baa3f681ae6ab1e52ed968302921bd09608f94afa8d7b0f916f17dde0d729b19d38f1fdffc6c60b14d324146ff6c8015f8abcb69585bae9b8407a70167ecba8c388b04ca120f1f90bedb412519900f269f2703a17889d2b7f56e93e9a55fd74e99fcb2a53046aa42917cd621b2b6872d40c7ccff7d3888a69ca3789550f77468cf1da4bc7ffa885cc97d5fe0379c8f94630745e33f0c592636c403f6bab50e762da0e063c7418cec9fb247942b56107c2163d12f79c132aa3841711e7121c5002ff29c5ce53163388495d300d1e67f15e7beffeb786f94399b49b812f3f4a8040c8cb34686f248047fe20cc179c132289046efaba32179fbbaac198b675f2ea87d5b57eb074555caf77b1f13971919fa5c36289c66986659b9103dd988b25ee36b0401e67ec2d670069c68f5f7b532a56d90003f21a031fd8d457e468be65b403801987efb5db0b1024ef4eb7fd317a933721bf46d69fe951f30da590f280bc2ea8337c3158f9bcb7004f54c43d0eb58dea59d61a0a9c7c64a42db433e9d46cf16696b4742a11e5ce9ccf7fb7c0c07fcd6019261b05481dc096c6b230f1df8ac4e4ef3ed8f156d1d05c09f7e02f7521fe9e006e682e58a894d4ed20486e21f78ea56d717d9135483e973228474b4510a77d48b5c3c235171b1e3a3a8bcfca2df7ff9a5eb90170871bb8ee6cdbfb49636700eabafb6e3eb0787202fba33526b84a24fe5cc28436a032f16bffb2369aebefa17d4be1fd0b78f2fcd4202abd41820bbbb8e39552ee9af5a638c7aac06c01de40878b02a4133f419220c718b07f307a99abdf0f7fe5130230a2854dfae409948dfc21f7e6af604d3ffcf8910e1dbe5c9bfbf6afe64dc0976b85ebfb8e761f0fefcbee3075208b9943b4b7f9aa762cf24216fa3c79564afcc46c68038931b60f02e131b3163d458003dc25f4427b97c44fa44519a886e7a968c86759d6059d8b0fde3146ec5fad4e9e1f9e28e274e49c036641bebcea61eec8967c4087bdf3f0ba25edcb6982784d9e8d1532cac165ea33b5e8c1e8ee6a9ae07e7c6e51f2a399efc98a9aad0181829866d55756680172eec3e086af2008b75284c3f630eac625cfc5bc1b768761e6fd17e27907e9104878df8f79c84dcbca9bfeb6e0ea47772e4e5cbce6b8d40c2cc0e920479ea1344f8a5345de8041866224307a890e7805d464bfa7a05096d84829bebaad74ae47e775c2f5453038ec99b8ece43712945fcb9ffbb7fd654aa39f6899454c168e7c6a694f38e42cf47a3bc2450fc8c37dfe9bf46a51f85f6f29851cda58fe7bc7e1a92069dfec49eca2f81d545fd59cd124973ee69167c1d65def795118cefaf0798d63dc80052f7478b3d9ead86e40a9ee48ed7e439dec0b0c108483a39ea3137b0d32021673f81e9200de5d6ac4616f3779d072adb06f439cde9b77254229dc9a18f877fa9e41d911295b42604893c7b3616c1dce14f2284a7a0f7dfd63f960df52b44c4345d15fc14a22a1ab49e2edb043c9c8344574a2eca87f111884d44f75ce311586d57a2624bea9310b89b9e8bbf96658fb669527215525cd3977562f1ebf7c59434f4c63131d297d8c15b1cbf4cf58a6be70d2ee9cd9776a1d8c004a562531808cbb01a82b7f9c9258e3ca6d298bbcbaa36e217c8e5ba76cc076be9637602e1c06355ec6dc6d3753ea6d0a976ff88d4215ff7b377c5567bc534e872ca7bac0e101ed3e8056d6b69f6c1822cde6ea67ece4cb04b9d73cb2e18e474ddddc1d028ab466efc8fafe03357c4424b6dda6cd9d21f6a60c8ac590fd717ce2e25817c9154ef7a693ffca97c6e1ad573220d2165f745efc6b97567901a2137bceb05fe4a3d18751f52604fc28ffb19910ce7b3135fee9b18c51368299122630fc86c3ce533537f6c09bcb496b94bb062fa2c59a3f0dc341350b00aac19ee670107f136c7c2dd57f97b9de7ea61c474fcd24cfb5d49643af351d3d661442fd7da27a001825a2dda560eb064b09dd7960974a0bb0a4de70b4ccf2c9aba061426f8f3893dc4898b00b80d78caabc716d2931409afbc6132c1bbefa161985b5722b1e738f64f37aea94c101952094ae2feb803a2431796a261373d7b7a1e795b547a33638d599b4e1a0feacb1c4b454e44adb8cdc11441c6e12b5f1b25a49c576e5fef1e6fa4ae2da27cdfda840ffbeabc8919d921014ddec49b464ca919920aabc6e5ff0c7a383f8b6d0f1209c778cc5754a0ca625ce1374b36f2eb571410f158ae3c8f17daed732a498ab4b2aa2de28eee897e5da12b2b6c1c4e77f62866c7cdbd98397a47e82f148feb48f17cc752794809ccf7894de84305a888b6a33d6fd069cc859c87131776e5f2f6f25faf8727f47ac6dc63b6fe869645520f80ab0cbbccbd4a44e444cb6b2947952f2af895f38ec0eb2d44f7bee37ccd862c988ee81c1d751cda8a2ef46d291c1707d1495ef5bc8dacd842ad01e86ae437693fb45cfe581196052767c4e3aafeac34fb4a84441d0557223b990389df277d6fbd9a1a9e68c5a4d4d9422583ec4db0b60b912af2653bc4daf8295473a6befa47a8f4053a17d139486551d000abb781e3668880020a6731d6fe621ef406215353744af67aa945b7dcc44a6508522a5bd1ea38c488df29b0a39c105489d29d188a7c327c975b33e2bcc16e43ad01a64010eff61e7c7367a59cdbb2f4ec30d783133598ab525adfcf942fe2e61c4615c808d4d6e44e12ecc657d09fb35f2f333b84008052c491b94e38fa0dc147b5b4be7de86962e2cdd984841210685bbed9706a1028a3830505da42f3f70f4db3f06035b96902df04d9e3aa318c1d667ec9bd51399dd3a0a2fd83a62f964711280892dae704c741b889c9459e1e047bb600b346cbdddd60d278c104e35c9295a0aa5c8e0fa90688ea1cb37a5cf18347ebc109958ef448ca6e787f28a3fdc10bdc5b8b3f7b4e8bbb9c06861d4a20458d7b7a22566a4e1afdf16d7d07746f6a665d91ff62d695628478365426e87cfa8b9891c914b6b8b73666b9c2e35f36c31de3b8b1ed250e350328a5c32dcb6173a23bc4cf17a9993b0f2484153c87e170f66846333fb7c11673b46dc5a2ed004c72da5a1fda34919d72bb4285f1b85aa56995efc4a8340db4322c9c50c20438a4ed5ca4d7ce627ebb6c01b6c8ad2a419887d7d47fc6afcd0a72e1feef15cdcc41a5cc74dc580e811cbe9a0e9a878985f6df45736368a1a645c799ff8fb426a819a55b46ccaef060b85d119c3baf6fbf8d4cac21f7b67e9937208618f720b4d8374deb8388469aa1b5d71e3047c161c4fde7254abe36a6524f060bda05c0a18216c1a7ca6773a83fda0b434d88537c72b515d0146a615e43be8f72133230184d7b4b50a50c3bb576915911a68e37ee4bf3e0a6e7b316645ced347adb2c6809df5b0115c1c22bddce0c3a97b8c75113715a46dbc8f8f0f8ad35fc32cf055ca63116012fb32e1fa607d176489317b1879667ae7b963ed2c16a028ed710c4cecf56a24e180e8ec12c47124efd2a9223066c2b77c185f05af61f5a22c0904e76a8bcce38d26841e7da0835aa9e8220d9fb8ebebb45dfe45fe20fc4de312cfecde097bc2f14657ca7cb7a6518e870f4c6b3e8bdd0874b04df75c9d340edad37c58e273e3cba55ddd6071a2abf2f22a3bb4f1338203f73599b844f6186d663b1f1c74271b6000430b50993d792414f335f05d10135acdc21348995a64374e343c192c7cbfdcc3489bcd554e911d70432d5031dddb05007f6796e776e4828481f3eef418848254429eec936429cf7f652f950c1e2d522a8c407f7fd15b8cffc5701ff2d5fa37e2ad32af0e689d40f12a0f9305f37ce139f2b99e75c74963c582bcb097d71133fbc7120cedfeb166c0aafb9f85b613f69004befd28c5c9a739961b27370fb08e01e1b1c801271823aca398c8895b7a97692f9b6bc78eb01b4ecdce96db7e11410747f26d61f5b4882a9d58393a6f2d2a519c849708d3eaf0c43a93971f7774055cfff6148691276854f37e481a052f56ef41264bd4e44954db8352c726505d95d89c346b832ff7268e896abfa897d79994817674327f3934a07e35afdfc989033d218f4630328daf64fabcfa01ffa7619932dffd2e2a96d3fa7f5159f61cdda318198041cbf32dcd1a0e9079765cdc5484651e808a651654f88ae779816332c5ed9e7bac1eac3aeedb1fd33070169ec4eca6ab20e28833ad3bba8892adc2d6a7ea3ee061808f3d0c633db687a9e4dc201f01ebfb33871406cf033a3986f6d9a227606cd14d0cca6e11253403418271fa08a391b1177c6e8d4d200d6ce2e897f4e41fc95b9ac821cf75ace227169b92664964b713284791e44f8685ec7dddae6e86d41b40f573b8403c2cedf5d813bab50cfffcd6ef1c3719aad7d1618baa3cc6621f6cb9c897396b25b51318f082150f7da8dab26f926b07a3f6d2246f9fc6f356296f2e9ec0b977b8b15caf1156da1d36abdefd8fd83652273e912909d3c98a09969edff1c09c76a9a3d8035d280a22f743ff7201cc389758c16ea1ffa8e42fc9502b4367c4310182247961c13eee8c002058b390987c968d0d601c5a70782308ac53753dc331b26719285f13276867b07c71780e74c150fab7272b44e9d95b097d841c9c7d0c561de877d57a0bb1cbe3d7f3763560cedbdaea17a5669e754237855a2bd1914d1179208de12880245ae7721e70ce4655483444799d3891476efb52b0224f72f30216e35e57859ce5afe06923d0dc92b5a57f43491b893c2c6a397c15400e5818b629609966d7f153cc387be0c3c7eac4e35ba22ace14411866a167d642e7c7e0ef8fe6b05883f56cab4a66dfa57e6804568a79ef6f848f3d4bdbe87afef6e5831489ba4e7ed8caed4ff596e4b9bcea151779fe797fb83bffafde7caf6dd4b26a63b1daac5de115b5954f1c8d8a575a56dbe70e5aa1633bf8b273974fabfe4f63bb541f45a0ee8ee2a7d106a3ffa3ff35410973e9db599872f71f48f7639575c97ee388a468a3e783f09e67681baead2f650743660f3b08daea8fcf09d367919573eff9a816d6f72215f5a6d1e2485c5a2be59c22c2b55eda7eb5a5d097d1b3c84d4a401ac9555585c3912f71f5ccb0c135826bb08def5be02a4d406271881be337817d04583f1493a90da498610a7535b44045a0adaedf42c9e6f3eba101e54319714d50b0370c1fbc992c71b1b0fd31fb6c31a2cf87ddc75a4a72d6edd8ebc7bf2510e109afcb7556917f37e3eb96fb4a9153c08d1b6865c04e5dccd20cf11efd8b5f07cc23044e102ef2eb6ff3217cb79e3e8122af385ff8de90259218631b97106cda0fc692a6167b478ba2ed531b04a0a44b90f9fa8d758ae90a117d3f49e8dc00da1cba9caab7ff6208dfb4ef31e9e8d58f8cb2d8eadb2f9338f9fb96f02eaccdf3935d707ea4a3c257e913d6d9174eb504e5562dc6911a0acdc9f080112333e25b9a1eb865f4177b515bbc925065a2e8293d872314c1cfffdc4675dd2fab5d1dd1e96822d590dd3efaaa827d2da198916a6890409f2ac6da4569c2479991aada1c1a46d3cd3eb5c73c233a35dcc8c498b80c848b4d8d9c20487927c7bde2cee870c01ecde2323536b762874922e0d240cbd78ffc6d6449c638e792197c211abff2e89a05f14ec79178567f9dd4cb2900464542bcca5edc295e1ad0a09a8ba861fe402e1454be977fd6a1793d4edae9a8ec1f80305fff853a33da3feae7265cf0eefacbbbfa55b3ed488fbf8cef0cf6080cec117adcdf794f3d048a2b76154ecc0e4ee2645778feab58af81fe28dc47f9b4c47bfb57c604e9a28244a2338e5376f92e80512a57d80d84bf210c3231c99ff16efe2e70a9b0e0c9a1ec29d41cd1012925d268f94d172c0ee969f5dc855bab4485800cc8e08014df4f990d3d4b1fe48486b2f0b0118b1436386cbdeae97d68d1984bd9b4c233e626198cebb5cfe00ac627e22c10b25415895c247bf8bf50468cf038bdb65afc7d2abf0feb90eddeadb89594c4949f14031634048ff7aa55b4257e2b7fd906efa65c62f2e4ee9f8d09779b4ee66389f307365095669b984662fb6cd8b19268d5a6a62b9e363e561395cceae45d29f05f8ca1226f05037f60c51c5593b152c0ea3aaec74e7cc196f6404b7deed2f6dc75acbea25042f24f1737b3b0bb7530fc4b799f190df5f5a761b92d865cb5e39cbc8c8499896c83c62a0f1a4a7197bddf85a74a9b96ccd9b8abc7ed3fefcd7dabbc95412242f612c9c1be846a7ce6825056927bea700acf1f1147ff8b5050e6650ad14ba0eae6a3c9888d2e24894450686e025552a08def7a91081d7316e192b5e15df8286280cefe4dade66c1558acca9448fa3b14a52c149685367442bd3cd4960a4f8d7446555efdd12b6c94d68dd0d39f15f2b872105f6ac2e664c9da631045c9daf5f2a306457c7d2c0fb38b51fb25506a6e8d3e2c3b03dc5345ab4ba42ffcb03af1e638a1b079e7a43859237bddc03449f6299b7f2edc4ee8f7753d94583dc552a3763129d1077445c1f6262183f89c4c15e0a6da0c36735e133be60884b7b64fc0e6c469209f06a1c8157a6731ea4d9e1177575164504eb1a6c666daf4802c985d75de3613c891d5eb6898b016468cdb1a146efb22cb72ae6b14b61bda10f6b55d109099b2c7959922010d7288d328f5b0b067a05adbf9903bbf34bffaec363c25cc115f19afed792198121c1b26a0b3f0721b36bf3212e93e141dfd8d82c623447eb19fb45e9734d99653739474510d91e2305859775d19ed540f8fda4f0e3873d0d02a2e53a7bc96a98853fa5cab741f1a0a52bc4961cb56332ef9c7c91a52ba7d73fbe94511f99e11f138446869f4475cbb745b73a0fbb3667ae5373b263ff20cac91e9037ec360f335bca41a9265a824b585372c95eb15a60dada4c4d4fb57a8ccc61f73d0c8480dcdd7b4a7c5a50acc5428535e3f2fdfb099ad0f69e38405844592b42fc9d37996c1a44621eeacd98c3428ce8a8fdcf4ffdff3ed0641285d2a77354db6a5b2a9eb373bcf8c9143fbae9918b17227a0e2434616cea4ce201c333e99ab9acac768158433134d35ef96daec7573a8891c5368d9ac03087a3bba3bb6126cc5cafa9017384be3c564b6211f34f2f842f4b940d361ce817bcd0c4433a84d20e5d450d3549ee11087f820090ebd2346fe06379b1d5e9afd79526f127b51a96a64e4a679859974788c33c2f80a3389e1208312266d60d6b9bf8a1eb116897025cac8a6c77d62ccb63075d6ad84c2fe25e788b2c0e4cdde0caaa4e66cd73ac104154776e24a9a43be9b404bbb4c8491fee40947bcff8ad8c7199062c63f46fbf90fc5935686e245965b826c66818633369cad197ddde5a2afa153c1a761eceb376418aaafda77d335608b50e294cceefa0ba12b52fd0b3deafaf315748affb687bce20b2e396050d414ad940c0ba8249fda39687a1228a4926d4fbc5e656c8f8b306a128858b345d63b50c7d2f0304ea1053f24ab8ef6b0d6aec2640a6c1c8a5eb8bdfe0a2c8bb00727e486f7233b5726e2e57609a7bbf246c596a1c9485af05b49962d1032c2ede8b5c04040355b5d3c9f8957c086606ed60192c4b58eb96a5c4aa91122597fb92e09e5d800e5caaa2d9f20a5f272225525e71ac84a29670e06bf15009084de00686b527c2177f64f71b7faca0169ae8e33afcc2a686569e3d64af23a984b71a6916245eba5ec0a252c69dbf5fad828e445dddadc65445099d25a52d7decd9fcfcf35e3e5212c594d011d1a6066d2d2802046029a318b9186df103f8a002759067ebd1b2e28b6ba5d67b0553fde04e05cbaf7e2278a3a0be1f2c8f48266322a0e9842575de774dba5e65aac8d146848f4118fddf12813f1d955f6f615e33523463e8cf7117f96d295844a0ed51975cde18c5f3c0997885cabda6b9383933ce34c5a43b02430ab259760123676c07184311309f81e3166ae1ba0530c25dd3b9df110f5f97464562df34cef1c73b02540f948494c2d0a7d5cdf72c5cab948d6538a3f19a16e78d118ccfb2bbfba52b39c70ba393b451be5053a291a708ba1917cd056c6827e40b6ea7245c182a60e78915d560a93c507145a6dbd7d20c39c8f5c75e9009e59f1879dfd52392a0c7f50d1c4056b885d662162695ac3058b13df107fefbf56cf454a5cb18cbf8418bd90a22ec855291e86a14ebe12c23370ccf58b7b450b84aad4c750290dcc63f4dde37a1884d84e512a8a9b26ebb113ecd9e0dbbd3c12188ad7a13b07e53a7fbdf97aba8f236bc3d3bbe10080d899d7469147e3afe9b92ed728afd9c1a88cceabb148f9ce5e7c04049b2756b4f215e038d0025b7450635825232c0ba079c619a365d575fc6f89707f2d1e892a24c05fc104de5adccb5f9a7d4ec93d62340b53e1a59fcbba4f8e3103bee127a7b8cc131944ca8cfd8a13fed0f1b29ca39337ad72c528af68fcf2e490ae6ff994982cb9cb5dcd26d5326ebac22fd4525c23e523d3a95e58fcfbc4ef1e0da2e89249e9293311c84feb6fb8126c0e4a7184b915d0cc1a403a3eb7b2f34cb120c40f18f335652a331b3ec73b5181f53cab52fecacecdbdd6bcd9f389f36c1e691a7d1c4969335728eab7dee9b0bdbb4d8b5e612d21d903aad8d493bf29ccc2e0d9c11e3af37b5f31da481e025508be76c393ff042ecbe7958ac63b6dd4ab1583cd0c9c95f09eb995334cbb70ba5ab2175b13019b42ce3ced737aea038620c6d86afbc882c3a0abae38c2680c2e520c9da12fa085c8289004cd39c9a0b7d4425a974af9d150b717efbabb365af57660816d044fba9f9a540b41272e86b5eae18a8d69fddbeb425551fba6d8b8bd441282b4ea651e8c3a63a3932b143ee428639e3bd9030edf0b3265e7f374330c8bdead8fdbcf1f64411ba8dfc8957c5046de410970101aba7534845272e71710a63a09d52ede0474a654f4b077717d87062ca11c3c461f029f084bb6f77960de99b82701ed14b270f3268366cdfe7d1d05f16bb2d2b4ad24886f6a60777301a275d0c9607ed3c50a81a4b0ba50c7b243cfbcadd07d6fa3e4d4e377088c7d8c0885f97358b4ac472e4c00c648636040e3da9522566ba6b09c1efce3d6cd4b8d99f9968a2deea8de0d8b8962573af843f83edbf121c1e30ca9dd18bff3ff4353a281ace456b873edeb098b0273b0ca6d4c424de6f96d32c1ef58683f47ed8341d8521f252c6e1ee695c1208c7ce63d19515a70694d66b2c8e68f6559a723c1ce2e511878e21c8ec9abd318495e8ab7c839fb6cfff416cd7c7d7afb9853c74618bc7db10bbde039f48553912160839f6e0a642851a2a5a2df92bbb8d3ae6bdc077786561c9c74bba54cdec616da2f85c5a25d2176c57ad9ba2810124563a5344728eb0a0b5823ee2f34f044269ed065cb7c32205a4ba2fb88df88615ea3fc8566b8a01467559b97fde48f2494318295778d24e488ea83323508bad44c71552dcb393395ba351db93f34d83a72bb68f3c6f06028004dd4ab1269834709fe4e61f77d1e07c17dc576fea995b6045085fb9b35f9e9fb673d58e75ace0fd3c55bf68186414c312edba35d27a574441c65a3334677ce54d2512b82de46fda4444f7efe6743bf6b7b274d7f60c60d764a94c86b140f8de67e160eb8e33ec82b48076bb50923e16c1abc402d62bb27dafbaea605a579e85cf42d040919fea320e56e5a9f918579e008bd2d72f08337e7cbf74e1ef78005a349f0923995430edf0aa0636834e15045a0ddcd408bbf6c4bf1bbaf8d61c40e1c8b83509bae8eef6d4e3303c3a98ec66a57b5509196afc992e765c3918d84711b039756af5703d7935076799e52834ff7830675a99d7ea5e0a2d10ffb4cd9ea253c6afe3ec837da9da134f089565895c2c6495c6543626bcc84a95d4368323c830b054a48ae695fffc2c97fe81f17b47d0698b4dc7ada795637cfa3d3a8bbbc022f2944a0524a6aacea224d14853e347ddb2f2ff078005aaa16cc30ecc56e3a1cb6d071b41eb3ab8e530ebe631ebe4739efdad689a948326c84c79fa3b90fa40194c0876a9d007709569df862249de34bce11ce92d370b69bf132ed68ed604a333f3a63ea62da5ba45bd84230bd48e04f96021e4bcaede15780286027e5b41a2e0e899b9217da391e7955644052115295be8fe75a2f2e015965b86b8e468acab62c6ce2190e339f1de3ac44bade3902b332ec97679585458df985eadbc3e03993335b1c070a633d5b589e4c2183273630130aca92ad3e0800872a2c9be4de87bbf124129420ae7f9a9b7be292dbfc346adfd07f834e3f21eb3b9fbd158645d8495fff004340d02d9c48fc16341e87dabe52d4d00bc59f210071b0dcea78b8c0c12ad393fa756f228e162f907a0f89a20b471d3fe310fe38ed91bd5f504e159171f01ec4b8c068d48b27c3ccfd34352e317126fb9d58a9c95d7800b414e6b1befde6b044eb50731b9a8321be89fde67b2442365e83f9f09242682bd052198cbc49244af708cead09cf87cf12b1fcc1988c15a445615e532fa9b14f1d3e507c6e84721be4918ce9ab7ae2d97f9eaad52230e953cceb9d038cf5fbf864f5dc2e426212f6491d8b583289e45ccfa5c4211c4a1cdecf8128a84a2c0e9c51183cf090edf2dc8083b1c715109f4efd90306da02fe5a5b93770da4f356a9424b2ee58ae233c4fb8313743d587ad39be14abab32a22787007642b57b33df7f04fcb16aab7a005d3b0d696df4d2bb48204d7fcd8adcf8e8de478f9761973bb2cada4500c72c6513198fda0ea4db0126e34fdc88198f5e8f1c84f6f8e9cde4f8f4f716a7e103e485a61ef140d37180c3ed63f8203e3bbf35e7842b71946ef3ae6df24b5392aab9260a2153cd374c71c4110a95b8e56af682c5bbe4a7ea159f0bcc8268525e0d544be457e9201672eb36677c4d9adbbf1d6b6c9cfd4eb385ef023cc0c298ba175772265b2ec3e5bb6fd9070faf0a23197716d5809ff9d8ec9dbe842c14761bf8b60ddb1c56dadfaa0d5e4efa16d7267cfd00d6c03d636dad30a4bd18fde0806eb9652a3ffaca102c57e3fda22244a8acc943b6b4601c09fe6b1695769c29b482553c90eca57075dbbb2ee0fbd76c6bba191071019e32c62e186b6400c7c90bb055558a7cf5dc9ba5089a633cfeff5de78183441ce01632a066b5f4503b4f16cb382cb2e9c13e82a99647622dee2af98ac560b541af3f4370de86534175a3f76abc4aad15ca0d882e632580cf1de51ee3d04a1e8a47f4eec40abfcf0126a302c485ba2cbcf4b15bb4dfcfa9b54913e3947c73e37438e61a55650bf9b04bee852971029b0079daecbfbb47b0a69216c44da87bd4acb7f774ea483558d83da1e04fd9fcc56a70a108a242a8f0e47d87e98a0c31a84c4ba868588f47705a6f88451dff700d594b52e6e47120a8810060e97330402d76a488d486e0352a54fae69cb8d4b2ea5eed7f19f78d9b2aececb48d5548970f94daf8e63edf6e17fb1fb67b169cf2b20f1689550211d86f0c96af0fe94e1ad29be1f88f741926b5e2934d334d16a831f10da000617aa648be7d918dc9d5a64af38768900c0caf0b8d01c5d59997a04f2cdaee06bb99a778248f50253bad3d8809d61b5a50c70b387f539f6d13ecf24a0d68c2d73094fdafc327fc45d472c327e0f245bc6e46093118b54632570edb32ea833647705716901f325d236dca6ed703727246577a7acd9964c8c1aa684906137c0108123030b2cc3056fb26123f394103759f756effb4b57446bdce5dce16c5c11520906ad3b7a37165d097f76d2409c72a26fdefe001ecc781b57cb8770c53964c309762cbdefbc60bf33875c2accbb9d482666dc4e4a4731bd562a7e6ac4e10df72caf51b53a994a01f722c0e44cfd296ed8cc90db83bc4743ea0251ee5721ab817d033c2799e88cfebb856b8cb73db2eb69bd8095e2b1a8c0892e539b390ee891037c1c38c2ed2cd767cb743b3f6abbf33c5a70c13d440c60f15dc644fe976e6d07f31da711905c2eb1965d700a0da8a4194fe71f83cfb088798c47bdc3a9f9165b303ea7b41580e0210a375467b613468cdd3e4b0a1e4dc68e6ffd5c3a58fcfc425856782708484a30d608e4bf00daefadb1292d29f7536119dcaba07f57a9fc46fea6d9c30aa7f6053fcec75106e7b7d23ceb10952aa7e42c0bea01914618e4aeefab317f6815f397729beecd35c58836f85c47a0454fcb69fc4bbcf2d41a2f806706abff9f1b3028f687b33e209ca9858c9c5fbff8c5b734ee1c90cc5cb19c02229047d95aeb32e711104895820f6b553db287591321019a1edb9501ee48e3df6d0f97d6b1473b7caae8a60fc6a21d2775233c95c4ac219b5b7e44d2800fd67059f49c88258b9776f24edbf3520271e2e885ea89be77fda5b50078a6122aea231f016da8031de50648a91d792b5b72f4754e636609c3c702cd33e2fbc45c0249aefef57ed8da19b976b41da8fdd3875a7679d6065371b679a6bce2266ba0c579858f38977cb04bc2f2488c8a256925d44faeb1f2c52842a252f68a465733f547527a86bc3d0235e4fd11b49ff9431f7905ce3e05aeb72824647b8666b24688c63332c50880763b46447a6b651c421262bffdd620f52f1ee4523aa4a76c302898ce026c00f1e56b0c68027da440e3f5985d6bc46c6cc1236287cae5249b5ead7beb7d109d95a8d96c6510ce6812fb97b97d9756bdaf3b983223fc5287b59b0b4c5a71c13b1f84338fa23d192c75987a41ff8ad3b8d5d4e38692065d96862b84b97a4b01fc1616778a6d2f03c1a08c7852c8ce23f64f403333c78cf92e68ebbd7c6022328b93ac08ee517bdcbe6682d89de496510195c146d4d63d58948cbac017974e44147014542211869f4cd288fc0db263308cf2c6e79314dbc1926415af1fb95a7f0f9ab1954fe0484e7a3c5f041d1c65b743a084d2c1e45c1303f4fb57e3f4f89fb04ea314d0611dbd973e404f0312ef61d6795c768a12e17e9ee70f9e023d2df3d9a0f22f9e9eb51d0f5739b47cca4c3d8afa7b991021441c77328bb57da7d53227029d55c1c8d67f30fbfc0ad5c5886f075065dcd73660a29394de645c0fc2d4f7b6019e1b5a72d17d1c7ab40e36a4df9dfc1f7ff069589bb8b70fb04d46ca8e6e12e7ddd19bceb8cbb307ac6553068b61522a9c5cd0c972188a526827efc44dfa0da795b619199e4f42218cfad570e0db31f31463cf5f644217c1843027aaaf03f7aff1bc6f65bac1d7eb388dc0f45d1830b67771804d78a75378ac3654c576fb71fb67cf31ac83f1d4f8717a0e4b36844cd1bd5dae938fcd957ddf60c5246c624204235affe8beeb288a0fc4892a46e7e37dda299ec94760263769a2a2311abeade5ad9706b450695498db0c823c86568160da256832f1dba96274dd7bdfabed85cca7afaec9d58ded6b344711ca6b7aa5c6ed2e9b59841071103b3438cd8df82711ff7bfaf4e726abc3166d40ca94578269d96b2f27a8e964aa2a5f6811e5484482fce232c19db20e5c281b2112587dac3b48cd5a440f1a4cccbdf10dfd8bf18d26ffa8e01c4f6604518b8dbf23aa0b1f85559bc9fa5b4732ff574e1f84a3c8898a40331b423e97ba65dcc0372b5cc83e4fd957ba55bf14e3698f6610e14967a9d2e4f0aba2027172034c1caec9b31bce3f6f9893be3b38da978e7673808e90cbea2a5f5a77bfd0e2e2fc33c590bf3325e2f55d3427b16833949d1e9c0425fd7b29458d6f041ce7d2df32903a7bf5cf3edff3e6496d84064036fc30c606f556dc13988e7e99af368d068ac19beb891c38d5c3e85a555f8d51868a22c8f0434ed77f68a7f1b4471b963b3e75399b36fd405fa1e69c1b0c4c72f686fffb5275046653e888b6342c70fd8d0310d6ea024b8dddaccb9d6ecfa4e524853ee0cf1620b3080a7156db0004c87b76020d728f1dc0b189ca1c1b1415497365a98c12686fa60c74fde734cdfbb7a774ad046c05b4fadd28ddb77bfb337db5bd1609c20c6051b6739c47a52175606b0e12e0f47340b7f2242410d1c30a82ff5c14641c13d7730f7d007bcc703fd757f0b7b217ce4f84ab2415a2420e63137302a4420d6848f97591e2a51bcff345ae81701b0b7f045901598fc0ba979fd7fa35da65252bbd22ae3b8244a731028ca0c82295b9d446e509a94492ffb9523ef31bbafbac20d17bc51afa1f33410dd9e947bd6a7eb3b8386568689e3ab3089d6318a84a7dec93d0c11845996b5d3b8a7e9fad3f8de459e85449f13899c977232a3d44afd9c9f2971080dc1fb0d35faa6f78e18691ebe4a90e4ff199022a0b13a029944f761f5d070385b3ba3f6306de935fda2091d27173760379cc387cd84dc9c4c9f2370f63f94093ed2e58bac065fe257f2b5647739723d8d26e995366a8c1438acdc88e8039ef74aa68cf8b2fea92d3a7992e0a665b8be918c5d7190f8dcefbc915834ce1ece7de6d9c09db2b809ff06c66b991d54a25db995c509db21c95b10f26205dffd634beabee997735b54652646f88922a44d70d00b27c649e417f56366a479a29dbad4611f0fedba91125b49be136e54b03ba248b92b8a2b175e93256c1c0eb94d56427f34353fbf47e59e8a71aae02359a7ff9161d98174f7df1a457d124c8ce028f6142738ac47db2029e579628bcaf7517b3736d2e9c1c2c1772c7a2cacc187965c260aa22ae44e1e18650dcddf668171201419c7780736c8a5e4169f21b3e0fcedc53108443e3500148ecb85126c881d606a54a7411e3a70ca75ae96ad8fc63b9772ef96c7e672e60ff97d829d4e44723e72fecb1b1b83e8124c3f3bbec37e532b52b2d52073d0bb477b23cbe5e13d57abb2fa30fa3bdfb85ca33e8a00f59c8d0e2c233c8e021ff46ce77b3274c6fce4d1a2d5e06c44b1e85045a323d28c3fa19d9bb15e85ac247ca022dd312c38304bb296b27d02d6706cb5ecce05a1f800f39b9137b7ec74f8678230c3f0e13233060a23818a78dc3fa4992cb7480b9fba67c084523102d0d7e00a5bfbb70b9478e59e0874cd62cd6c1e3ed08adce03ad3d2ac94130dc710021b039ee53d18df3a999a48065b23fdedceab3dd746920b28302a141dbe139ffb76432671ed7388a2ad35d7589d7106181074e3ce9ac5e845698c66919cae45a8fdc0a1c220bfc59bd1fb99767e3096b8616ed4e22bff4b1b6ca7576dc0253a1626025275cc858a066a6593d526c59f712256fc873b9243dcf64b7bcf7bd564186e1603547eccc37f3cc2ba6c91da3d59a07d4a821d7c19d4d036ae78293361d0d21c4ac59708fe5ef07cb34809f4e5092e57868b79d4088580660fa27b28d11cf356a721db45849b588197d1d83278cfa845508f5c0d4bc5bfd102cda8456ba84def24b1fc59fccbbddb3858abf903b9ecf135e0645dd4d1799ba5685dcfd3bbfb57544cc86773358f77a22dfac1e7bd18263f3296e18fad7e258c236f7017abe43977328d39aadbad44ad17a1fc56e24c53f239bfd3444948a42a31cd5de40accd97f68a212d25aa28cec552e7bec6ddda05c6bc06b3ef895bdaabdaffc21c343d9d6b854a5744ca3a2745c6e3572dce0b0d96e7ed2bdfdbc264f1119635ce4eac0d418a1ee865e8434c005d688a1840c9124e527e10230c28a6c1b92c8b59239a0dbd49dee2dd405216198429db0722fbd8ca12941f64ffebb1865c4312539a21ee220d99c5929415e064072ad7f3b1ef5de236a488c806a1e4a7df23eea57befd6a48b0f09143b0b1a29a9197f4c058da9e12fe1df6d90e84e7a9cf10c8423f82cbdeec4553fdd517bbd361e797bafa4668523e51c3b8c867ef9cb5070c523bab4585d90a747635b725f296a96e20262436bebb71fda11bd001a9796b4a6b22e82388b152c362f34d66ac988acd6237c51268967398cd70d45d7c8b87d112646b53fa226ff649fd8545fe7208b20f8d6444428b495b9f15d9dd463acfd21b254246672d7c52f25cc29c541132baf9beec00e66179af9ddd548cd5870fe5ef15b8b01c549febed814f4bd2ea87c6483813cc0b1c2d0213e8bb2be4de238b2e1cb9b1e5b377c0727411c6b18e089e290011f2a794d85bdd1a1eafb21c7a7467b78ecc3937683580deab2f144578cfd6cef42a7c5a65357ec3d4f1f20875dc1ae0836cc3162e57a560cba93676fe23dd0561c819904dd8b0a95ce09637381f75f3edaec5505b7da13aa01cb963d122f92249e23880dd74e4cbcec0394f8b9720cd472d41e2ef6257a28c8f71621992fa9de6848a61176c7ae71edcfc98e87567c55dc3c2cf4a3bdee8e9f3b7a75d7bde2b66dea0aaffff542faf582bd9b463e902d8ffca9050a1003b3a2054a55bc3811003fa14723b19eed04a2c47008ffd01a24d2b372582d438a71c66a61c778998adf28df22bf74e7195256f68dce2aa4f154da7ec81f3ea6e09093aaaf84265237ba6dc4d7d51f1b6da0c929bbb4bf0836173258e8e5f0f3c099bfcb112e2ec0eca8d8f4db3d1fa574e21c024ddbbfc9fa28233bd5e73fb7d718412e44e144fa5a691a49d21a1eed72c9de012dca264e313573c8c28fcd0b51751a2dbd8752c9fb3be07d0e7c0555b3684a7ddbdeb8e8fdfcdfab35981367d5306ed157a64f93c3c9603b46a375107b3f96e59b1344547a10bf635b1cb2727830e99d132b353fdbbf7884559f394bdfa82fb9f835b668da1bfb3a53e2d99fdbe98f20be60afbdab0c65f987fcc751777b40e5dfc760475708104621400376d45487b1f5e6cb3076ceb406864ca029eb81f0310b2c7d2877a4b4f7f511c805939308c4ab918fecdac074f5ec16d81adf5d670ade50ab359d45df6a2383bc2d4772510f002aff690fe9205f561d9d3f549f11d0cc60c6b36e60fef3c1dcbe28a4284f267e44d662cd493d7243e20b8c73e090c03310e7217d586379752a586ef596385a247042e65dfb63e04bf7656e31f0569a84f010681dfbd7af7336e0a7a5c867f472aa4176b8e89e75a16d83f1d0154b87a82a0b74b890238ebb8ad84e6abc2e69c60f49c70c24c82c29506e95b02efd7614086f26f0632ee6573b9ee9362a3c2e26f9f16214a71d8f3d54279754ffcd5752f3b72c75d0147b7f3631b9f38a49bd302e048a7ef2e52f8c89e253d0db631c4217c8afa77f10a0a8e42a283963f26a4508ca192335ac2a783a5b6666b2b099043d75d6ce576e77d838ce01bc65b1cd03f7878d7d95055694c1b20dd7a57ac0ffec0a5eb022f71b1aaf7eebdb94b210d03080d4c35442ae3a51ff3c32e606f207052376751253e07f15724f4c2be9b0434ddb344df395e7596f707c1dfc62c5abc32f43ca9ffa40abaa40af9924c61f7ed2a01d617ed6be0ea7a384418c108c62e050244998ada0e3b15e477b01ca9a71ec406f1c0ff8a3c1376eb47ff592c62efcabc285607ff9205588ff8c3cf67303e205e4a563b74f41f809b416c3c8191002d5ee710f4e58ece1a98e212b5fffd76f28deb7a26b65ef1541c8570dc7382e34853afed25772a0fca7b1c8eb91b82290f074a5ca0b406dfc4640a85b9edf249e76fe62a2291615ac78f03af694b0c683a6f772d2642ff64ab85e5531c022da453727a6c92af494bb13032e67a24f4e39095d7ce7eb575158942969b68ebefd2aee34a1f5b0d3e043cef4c19c9ddd916246a9237b346b9ed14b035eb1aceb64efe58322937a573dfce393c99fce4f9e0ebd1c374d1910440695af77e765cf6b6d889ee036146cd76d574ec29a1261cefb731992f761b20b8df7b4382072c909553a876aae13c7d8d585a2399fe9fa552432b78578727feca9cb1bd4b568a86079bd805a97a8a7bda7b80ec317a67e651f3e90896c49daa2e7f7e9e3dac5599ff6931a77e52e5f526284665a8a6d8dd0e9cd878e403fbfe0cfdbd7747838a6973a51f1c90728a4f8f06fa081819c10da515efc6c878d8f9dc04998373516ec05abb2e43bd257cafbecaad2e9d063a33ceafb75c0427598f67e30ee1642f54ee5314b39fd6ccf8bab82b8ee4ee6528d678b62e51b38cd4993d6903fe5152a3a6f94874f55319e2fc27541eca00840f7504a5e369d8e997c3784a77bf62744fae5ef342bed57be3774786372c0d3d17e57f4eb4454c5119a953badb685c9cb744f6aa8e9b6a6130c21f7725bb221c40185e4f4dd82c16cabc47561299e7fec1fb38ca3348caa0232348738d029a14a91882f04dce786009b9e320a42b89a54debe28d8b39f62759cc78e90fbd907d24101f1bed47ee537d125226d59bdf01620c2450f75af87caff65b24e727d74001be6f66783748eea5f90715288f8e06f226734887bbb79a1ff34df207218f209ee4c72f10ae06c51ba5583e6dea026bab12980def157e9041ba2026741cf15557efa3c60f743aa55ae21fe2feabf04da31383a4c51f09c184cb3ca14950bacafc0ceadd792f36d8209cf56c6cbbfc37e2c5e79e341c78ac8816aab802aa41857f803b9ea309149cea5b243b7a5f9e5f09057b062a17a1d7114271bf8e283933c6b209f24b0f2c469dd7a1520b6953ca69a969c3d74481b0b3009d73c422128ce60b80a1b2d7fa0857c2164bf762000b9e17ddb965075bfcd1bbc1b62a8e3c83e3ffdb6580004d20e98f17526130e69433ad01c16631c38cffdfd15ef45d02fa58629e871cfb6ddd0642f043d288f16505bf873322f9788d8ec2377af4cfdd8c79c98f744f22c6a6ea856d38c6745397436ade2e4f2af63ce4555d06f9d7306b6f9fcd8757afb97b937c68b864a51c0eca8fa794da6ae57a819b704c987bebafad85c99f6a59b2cba73d1d1cc1a6c3cf7fe74f6e149e9594072bdc31ec2cc73b6bdbd67791991775a9f7d0c461be4266aff8d36bdfcc4db14183d736263ee6339990115454ae24ddbfc9eb4478d3df587060690c52610f9dc06557c4966a999dfc0471cc77abd8afe44ef454328833080d2e29b6beec5b39ead43ae7d8f294e434122342df68cf7b1c8ed0ea6d204e28626f5de81fb60e192a88cd67ddec602adee1417217739ce2fb22233278bff9dfed03e260afa18e9d87f23fd43b855fc577722138479766adbb8fab10ca733e220d5f915a0d5689609d3703bb6524638b349ffa19a5445d9f0073d8162d494adf8cb0cb42e8295dd78bd871566f934b911ceb16887abdba72dc423c4ae40d0685009aafde7e78fcc154d2e7dc98790cf1b56936d2f0b811ad16976576ec59083689cfba3044f2661129867bc16064dc0e7e1975e21d34a4e0bce38b304895ada5b73dd7149b69d73a29bedc44a9b8af912551ec757ac5f547b7c829881f3946cca1da864dc74f74482af6d1cf77becb90043050e00d9eedd2c1ceccf4c16cd2897c2e6359b02cadecdfbacb009a11981741c6bbd93c322a6282d7697624f597a5d881b605530a130b31af920a010260bd0bbc92d07aa5f255b86f5cdf2e355960d876e612ae8f08bf58e585db82f2140fb720ed0175642ea4ad1970c5df7afc37c758fcb4c80d62b1bb53776fad9d0facde18e753c78089174aee5056ced27d50e1e19d97cf508570d3f7a8e091c5683116e366b9fed4ed148b45d1ff2fddbcfa38614689ac55159cd8baeb5564dcd87edc9b064a66d2d4089cc620e46c5c38a5c9887dbf42fd2e710fa001f13a1e7a3325417b7b28a334e10c1078287caaf07c6d4cd3916eec5105753bb833c4598870cf3734fe39ae3f0c2fb6c22817a37b36a977c7dcaf01e7492171e33945d9ee04d9ab9c05b41020155f9a65fc6704bfa678850addee0289297a0dce691255480e0bc3d0bf1751595564b388414598f67ff0acc1b503b7564c3aac6cf722d6d9449f4520d80e30c03fc6a92715747aefcbf7c8a052e540750f5e6d7ec0688d8442983aecc0d5425779810ac54ae20275eb38db7eb486a6e3182abf0ca05844f6757c880fcfd90783ceb7a1ba25da2d8a7f159f5d252b4ecf4785c3ef7f3405e40f568f95df49633071547691e87eda10f027f34dfe6f214a3cb7e63b7c9501d14dc1a4b0031680b726424289e8081fa4cd3213f1f617a25c081d501475d67ed92fea988a802c6c10b6bb2c8832f9139a4d88826cf9957008965dae16fbaa0f1adf1541fd91ada6e4cb8aed46c993a9619d3ba99e4b98a82552590396aa8e8759b119b094875807755f56be08d17926d25c5b30e2ed220d0aa99abfb4af7f7075190e2c192a5942ba3d753a3f2d5ea47b91e849e987a2c469ca3d5bb04a2b92ba59341b0d8e90abcce4eb600f51ed1b616b6d756c982e97b9a65cec22290264ab3fea90f890a1d84dfd674c52d2e6cb8ec23c0624f372552538235160d03ab2277713964bde2d6e27f266c358b5d8d839df3abac243fc4b3d70552942cecc54f6198bd073b563630e95e2e58c6058dabe8e27dc5074a419d1518de9f8fe1b6e663319f4419ff72d88fba53ed4bcfcea823d2ccc5d2ee0602c5caefd60824bd0fe49a92c314e0f9b06e4eeb418069ad130316d94baaa15b426b8f6204c1688941260cf64e07dee26268c4bbe03c92d045dbb89265dc59c92e197b1361f3c55b887a83904f08701c71c7f7328f9d7bfdce41d2198ab3ded90799389e23da63ee3055d770a9cef7f8a95063210865e198d826abe15a679a185c4a55876343633ecda18628d5318bb3fa4d48d9c2df575aae9c42a0f57125d529f71a4e07eb1ce6d5c0338131ff03a6965da29e54b0ab5d19c37ebdcd4a153dc6c66a282d1499696f415a95977faa7e6d654594e6f48cf9005c2d5addbf20943462d6eb56674f4938b69b7c4358626b0e16dfd1f260a22e2353ba4dedad24b638e3816e624aa97d11113ffcc287fa9617dd772576bc64ab72d62c89c6e6b861f08ed194f040767a0f2e33bc485f22d304e75e47bd99b748619cf48b87c883ec93d410d6caef36a49999b4d73b87f7504567de50ad8d68142f3ebc7781f15334b371ecec476bdf3bd7f6ab0e76e6265dbc3c6104adad26f7d72da775f387d0dbc94ee3eb409e8d3e0981831980848f50a679a219d4340da6bbb3d732fcb1941862122af94557d37c74196bb03076efd7ac323852a141e56a4e46b471c44a1cb99386efc09bc68cf68eb14dfde2c3b8cef2ba74ec7239b01765d01319bb1a405354a67e1d684837d897f6840dabedebb61af14a4a9f3409191e5d4debef1b7857d98c64bd3191a0f1edae12b4d1ea08158e8f0a87edcef767c2cbbbdf5074d9e1833f5e505c217fddf35713fc8b9da4cf26c16176f83dbfc76793b7ff8769c32f9ffd00c9b337ebd004eda249dba6974c16d35737e67d93e3f9ba68be3a96d9b5feb92fb3d64cb3166c3eafed2cfa54ca17b8d86ca6845358501b751bd7665b4f0f873d7ace816ab4b67033c34f0512a0fa0b9733af72ce965f5671b9faa9349977182cec77e6707e1b0c8dc0176a2eb695a6ce7c6b2b9283664ced144d80c9aec8adfbad9c8ce50ee7d4bcf4f805fc0d45aab7cc4e3cf67456145bf050e4adf5ff43bfe04e434fad021c9d3a18e14eeb0b260694778666d5bbaad4fbc173e0a746c88b4128d1274aabf24ad47171d8b4480a1a3e99936d4bdcfa1be65b5b5b25e99d0f7c9bb1be28c52f014bef02eaef4f04956a8c4e37b657a96f5f09a908cbb626bee9d9a7924f2601e9219e109d1844b871f0c1c4e643fd49958d98e17327664341d716bb0106a45bb278140c572bb6960d891c9bd5a98a2410b078cb59fe8d3a89b06cdb462e8069fd945d695278b23b9269a1bdd4f4e4bd1c7688a7712cdb60d3091e84a899c59d47eb3bcd0a12cc0508549bfa4d70ab2814161bcbab285d02f59d68b7dc100c6bfa6ce390cf3f315183708c5dc4d8255470ec15fbbf5c31e49d69a2291dcc78d7c22c514bd160e09e0f7ad24c8748da0759a583ddd120a5caab2890c7307321ace4280a4c0fc5c691117c8b3b6bfe24228864722d1fefb4f438ac0a50d1f8b772ab23e85ad371965d286cf07c90acca410ce26056cfa833d12b69db11866f8efc855c8e4652c16c14b8038670f75bcd13b67e1e59967aa5a44616b6f4be3061e8b7a7119e6a2605f1ffe6505bd967569086219a4e10883bbe40a83d54abe60a158f00e638e8112d07a2a7a33a95bc909f5d47add2f5be7843cfdb31ffa70e8a092d9b70724de50a0b2bb910f1ace2d8e3ddcd3b052b4b4067037bd7912c8428fba57a0ec5a9c525a422c5d1b5e783548095d8a45cf5651e5e89c541a65ba3847aacd5b61f1999b3fa2bc407354af2aea7b43ab5faa1846eed7ab967fb84fc5ad56bbf4a77e676e5e9d2562400d45c83d1d12cd4eb59c8f59e2a880af5f7f0c7a4b36fdd55458f7cee645901c2f1984d346dd99f6350aece280cd83f679a8e6ac1568b55ccdcd77f55b8f0acff9543b5a87cccba6cfe2e5c4e4c15adf5ad6e33cbdcfea6edb481e00acff9b5385afc66198f04cb6be4ae6f71a5bb1feda54c3b65eeadf8b3f9f8d8b1b55101fba698038e9a4d2a5333fe4db1e36fc2931b6e2cae1a55792d7ced3832c0c5a8dbfbf6b685f878d3382c4a7f9036b74ffa0b186555999b397ba46142aa937fa72577f5c57df7b0ad0e979079f403388cadd6bcc429b4e1633e4d6817ddb863246118ea3e3c026aaabf3416e52cd64907b94a530bb219b862a8cf109cf7d71f0a0da2c0f76ac70fc57ec31efe445d451c872e2c1bfa266ed188e0189390d3746e4658c8a917ddbad717ab66ae22ce368c6913ad788f5e95f0a1943a84115c527828d98980c6eca26f9b4d29fc3bdcf0d6fcdf386263ec5b9ed4ceb8a8630674de923ffcd52b94bc259552cb05ed1a7003f2572ff7effb548cfd82019295040c9c7d69b2ee2290dc8763bae196b3e02e0a8f5dce1c243729f565163fa4dbd9efda4ad1e5d95772195723af4f71d69d87b075d2d4241a4c812ca47c2fc324145a3a5a70d1ccf6d71b594412f18c6ea417eec212e457e26a238c2b93b1f1a698b12ea3bbd2e5f137bc0c8522a40349b96b5fc85b7402b43bb7b060d6b72185761dc0472c82f812d4fdd5ed8ab7311884ab71cc246fd5a6a832f2969787a27355040f1af8eaf0fe511a707ce42833798cae6e3c313f328731aea97d5f3e2ee8f549609365d18a614373da4a216d19602a457cadeb1424ded10b5d77cf6098f147cafbd535570baba01a5da6e0500e36864301aa6dd7d88979b191454a8d01b5896d2837ea6b34ca22b04bdcdc4a9e471a703de1d4e7e8228c418591e0467101e56d4c14bb240ff0fc4024cef9622eea9ea9ea731679b65f80cab0c67b17c9b733f5de9b6a1e8b443bd1ea825471ff49a1c9c237b5f3a120ef9862419f8645e639639db8cd7a9c91f9dbc265cc46ffb9c504293a19683bdf78996b6ae74afd008170abe92dff0bae480e06be2a15182cdba1acf2f0449190652ebf5e6cff33dcd1f9dca4f9febf12c9f21ffaa7808079c0ef3b97763185f0145a9aaaf7f5ca556cde01b482b2a05a900a2a139ee86d45c4c6953bc8d921830bc6c6fd9ef9157d6c61810ede32fb25552a063ac14c546b77872f67fb66a2fcd67cf518998874546d47ce25c389dfa1b901fedba3c87b578a99e470fd9cacaf716dd3a7f111f216025071d229b41abed17a6cff88a4c7912820e9020cc890e6941f97116849f9ef176a51bae40dbef529e441520dde93d402579e7f21b6159b199749531160f04ca8fc22efc0f8a91e0a42e4e1fe6a5a5c069592d0f419b2c486514e8ae0a98d75601a974e4131586c1c3325dca9ee0126a203d9fd5e4e468181d99a27238c1951148b6c7a0ee67d1bb5ce620c7db06f29517bd5798bb6eb9282e9aa9a3c39dc85d9fd18f3e32a721527762ca95baa1dd89389afe8fbc4da7dd6885745bba57ebbf2365c068feeba22c72cee7957e405abb2e8675d2570c3db93f5136e23db39cad77450ed891983efa077ee900f6b0737406c8fbe2c8198928ee450791c46807453fbde3d57d54db9dc0bd30b3f1a2ebd5bd5bab7a3519bf6034976e91c1d6b02212e1bef3f592a27bb2f80ebf09cb2f6a638b813cfa1bd5741aa602b14db2180aa21ddb001665793b2bd295f7d71a6048375fe7b5cf973526529eec4a33c2ae846219babb2c46061a2652b088dadc61d74e847ff57efa1406797a8a764e0ebf2193006010d2a55ba609344242dea6070bcc50a4b9814ca7808fc18e87e1923995234a97f2d86958464e24b43fa8eff13c656bfd88779db6550edc55a1e320155a21f0962af8e370e12fb8504e7393e506bc1a00af71ae98ff6d79abb236840d0692333801804d348f42b87150044a7fadde9e35573aa370ed1c5d7e843336eaebf36f6478f6c79ce3e8641a80524c5e30375a0e1ff5f26f03435379caf8982fc4891a1123a3dedd7153b95b58425a3a670df4a22250ba10657097ecbff425b0e123b5da572ab10e226dfa34b01bbdb5708c41ce3722ec132240cf5fbd0c7186e0274296e81821c24f414655a0bd9eee1dabf1d90a7c7a18976c020ba9cff000936763965cf1ede8d1a37047235e6c04bca845d80db21239a5334324042d61177a8fc23cc454febf944ef3f30deab31f930f712d660dbe5aa66cdf093b335d54f47a6f7072d780f112ecaa4457b09e3b9d9921c60deab85a58676e424c3dfeb057df63363552883d4657f779bb554ae542aff714ea637e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文为加密的内容, 请输入密码后查看。
    
    </summary>
    
    
      <category term="ml" scheme="https://blog.sofunnyai.com/categories/ml/"/>
    
    
      <category term="risk" scheme="https://blog.sofunnyai.com/tags/risk/"/>
    
      <category term="机器学习" scheme="https://blog.sofunnyai.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>let&#39;s-encrypt配置网站免费SSL证书及自动更新</title>
    <link href="https://blog.sofunnyai.com/article/lets-encrypt.html"/>
    <id>https://blog.sofunnyai.com/article/lets-encrypt.html</id>
    <published>2019-07-13T18:44:23.000Z</published>
    <updated>2020-07-19T15:25:55.925Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a></li><li><a href="#han-shang-xuan-ze">厂商选择</a></li><li><a href="#xia-zai-an-zhuang-cert-bot">下载安装cert-bot</a><ul><li><a href="#an-zhuang-cert-bot">安装cert-bot</a></li><li><a href="#huo-qu-zheng-shu">获取证书</a><ul><li><a href="#zhi-jie-an-zhuang-dao-nginx">直接安装到nginx</a></li><li><a href="#zhi-sheng-cheng-zheng-shu">只生成证书</a></li><li><a href="#ce-shi-zi-dong-geng-xin-zheng-shu">测试自动更新证书</a></li><li><a href="#chun-shou-dong-de-certonly">纯手动的certonly</a></li></ul></li></ul></li><li><a href="#can-kao-lian-jie">参考链接</a></li></ul><!-- tocstop --></div><h1><span id="qian-yan"> 前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><p>相信看到这里的对SSL/TSL都有一定了解，链式信任、防劫持、防隐私泄露、安全可信，这些关键字大家脑海里都很熟悉。具体SSL细节就不啰嗦了，感兴趣可以去看看阮一峰的博客或者网上资料，本文主要是实操。</p><h1><span id="han-shang-xuan-ze"> 厂商选择</span><a href="#han-shang-xuan-ze" class="header-anchor">#</a></h1><p>除了域名统配的高端证书之外，一般我们的博客或者小型网站可以考虑使用免费厂商提供的证书。和大厂商的主要区别就是公信力了，不过理论上都是同等安全的。比如： <a href="https://letsencrypt.org/" target="_blank" rel="noopener">https://letsencrypt.org/</a> 在chrome等浏览器厂商的努力支持下，这些之前看起来小点的证书厂商现在兼容性也非常好了。</p><p>本文就以<code>let's encrypt</code>和nginx为例。</p><h1><span id="xia-zai-an-zhuang-cert-bot"> 下载安装cert-bot</span><a href="#xia-zai-an-zhuang-cert-bot" class="header-anchor">#</a></h1><p>废话少说，现在<code>let's encrypt</code>是推荐在server上使用<code>cert-bot</code>来安装、更新我们的证书，<a href="https://certbot.eff.org/" target="_blank" rel="noopener">https://certbot.eff.org/</a> 所以：</p><h2><span id="an-zhuang-cert-bot"> 安装cert-bot</span><a href="#an-zhuang-cert-bot" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install certbot python2-certbot-nginx</span><br></pre></td></tr></table></figure><h2><span id="huo-qu-zheng-shu"> 获取证书</span><a href="#huo-qu-zheng-shu" class="header-anchor">#</a></h2><ul><li><p>首先把我们的域名解析到当前机器的nginx上，80可以正常访问。</p></li><li><p>然后获取证书有两种方式：1.直接自动安装到nginx，并由cert-bot管理nginx配置文件。   2.获取证书，但手动修改nginx配置文件</p></li></ul><h3><span id="zhi-jie-an-zhuang-dao-nginx"> 直接安装到nginx</span><a href="#zhi-jie-an-zhuang-dao-nginx" class="header-anchor">#</a></h3><ul><li><p>配置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ln -s /main/server/nginx/sbin/nginx /usr/bin/nginx</span><br><span class="line">ln -s /main/server/nginx/conf/ /etc/nginx</span><br><span class="line">certbot --nginx</span><br></pre></td></tr></table></figure></li><li><p>会自动识别nginx配置文件，生成nginx的证书，并修改nginx文件。这是最简单的方式。</p></li></ul><h3><span id="zhi-sheng-cheng-zheng-shu"> 只生成证书</span><a href="#zhi-sheng-cheng-zheng-shu" class="header-anchor">#</a></h3><ul><li>只生成证书：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot certonly --nginx</span><br></pre></td></tr></table></figure><ul><li>会让你输入邮箱、域名等信息</li><li>然后去域名DNS插入一条TXT，之后会生成证书。</li></ul><h3><span id="ce-shi-zi-dong-geng-xin-zheng-shu"> 测试自动更新证书</span><a href="#ce-shi-zi-dong-geng-xin-zheng-shu" class="header-anchor">#</a></h3><ul><li>配置自动更新</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"0 0,12 * * * root python -c 'import random; import time; time.sleep(random.random() * 3600)' &amp;&amp; certbot renew -q"</span> | sudo tee -a /etc/crontab &gt; /dev/null</span><br></pre></td></tr></table></figure><ul><li><p>测试一下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot renew -q --dry-run</span><br></pre></td></tr></table></figure><p>如果报错一个ASCII错误问题，是因为nginx的配置文件有中文。。。所以还是建议只生成证书，手动去配置nginx比较好。</p></li><li><h3><span id="chun-shou-dong-de-certonly"> 纯手动的certonly</span><a href="#chun-shou-dong-de-certonly" class="header-anchor">#</a></h3></li><li><p>适用于上面的certonly报错的时候</p></li><li><pre class="highlight"><code class="bash"> certbot certonly --manual --email xxx@xxx.com -d *.domain.com <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 自动更新DNS并更新通配符证书</span><br><span class="line"></span><br><span class="line">- 如果还是想自动，nginx配置文件的中文也解决了的话，&#96; certbot renew -q --dry-run&#96;测试如果还报错：</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;bash</span><br><span class="line">   certbot renew -q --dry-run</span><br><span class="line">  Attempting to renew cert (sofunnyai.com) from &#x2F;etc&#x2F;letsencrypt&#x2F;renewal&#x2F;sofunnyai.com.conf produced an unexpected error: The manual plugin is not working; there may be problems with your existing configuration.</span><br><span class="line">  The error was: PluginError(&#39;An authentication script must be provided with --manual-auth-hook when using the manual plugin non-interactively.&#39;,). Skipping.</span><br><span class="line">  All renewal attempts failed. The following certs could not be renewed:</span><br><span class="line">    &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;sofunnyai.com&#x2F;fullchain.pem (failure)</span><br></pre></td></tr></table></figure>大意是说缺少一个`--manual-auth-hook`，因为我们比较狠使用的通配符证书`*.sofunnyai.com`,所以此处每次更新证书需要给DNS插入一条TXT的记录。我们需要脚本自动插入这个DNS记录，我们使用的`cloudflare`作为DNS厂商，所以这里需要一个插件`certbot-dns-cloudflare`。</code></pre></li><li><p>先去<code>CloudFlare</code>后台申请一个局部的API令牌，只允许编辑DNS。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200719214622846.png" alt="image-20200719214622846"></p></li><li><p>然后去github找到了这个<code>https://github.com/7sDream/certbot-dns-challenge-cloudflare-hooks</code> 一个DNS更新脚本。</p></li><li><p>下载配置dns的APIKEY</p></li><li><p>依赖jq    <code>yum install jq</code>  是一个json字符串处理的库，很小。</p></li><li><p>上面的脚本一共有三个文件，因为<code>CloudFlare</code>的官方API修改为标准<code>Authorization</code>授权，但是原作者还没改。需要修改三个文件里面的http认证头：</p><p><code>cat config.sh</code>文件的http认证头：</p><p>这个文件的主要功能是获取<code>zones</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CLOUDFLARE_KEY=&lt;这里修改为你的key&gt;</span><br><span class="line">CLOUDFLARE_EMAIL=&lt;这里修改为你的邮箱，新版已经不用了&gt;</span><br><span class="line"></span><br><span class="line">CHALLENGE_PREFIX=<span class="string">"_acme-challenge"</span></span><br><span class="line">CHALLENGE_DOMAIN=<span class="string">"<span class="variable">$&#123;CHALLENGE_PREFIX&#125;</span>.<span class="variable">$&#123;CERTBOT_DOMAIN&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">CLOUDFLARE_ZONE=$(curl -X GET <span class="string">"https://api.cloudflare.com/client/v4/zones?name=<span class="variable">$&#123;CERTBOT_DOMAIN&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"X-Auth-Email: <span class="variable">$&#123;CLOUDFLARE_EMAIL&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Authorization: Bearer <span class="variable">$&#123;CLOUDFLARE_KEY&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Content-Type: application/json"</span> -s | jq -r <span class="string">'.result[0].id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"获取zone结果=<span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><code>cloudflare-update-dns.sh</code>文件，这个文件的主要功能是添加dns记录。但是这里也需要修改里面的http认证头：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DIR=<span class="string">"<span class="variable">$(dirname "$0")</span>"</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">$DIR</span>/config.sh"</span></span><br><span class="line"></span><br><span class="line">DNS_SERVER=8.8.8.8</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CHALLENGE_DOMAIN: <span class="variable">$&#123;CHALLENGE_DOMAIN&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"CHALLENGE_VALUE: <span class="variable">$&#123;CERTBOT_VALIDATION&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DNS_SERVER: <span class="variable">$&#123;DNS_SERVER&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ZONE: <span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">ADD_RECORD_RESULT=$(curl -X POST <span class="string">"https://api.cloudflare.com/client/v4/zones/<span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>/dns_records"</span> \</span><br><span class="line">     -H <span class="string">"X-Auth-Email: <span class="variable">$&#123;CLOUDFLARE_EMAIL&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Authorization: Bearer <span class="variable">$&#123;CLOUDFLARE_KEY&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">     --data <span class="string">"&#123;\"type\":\"TXT\",\"name\":\"<span class="variable">$&#123;CHALLENGE_DOMAIN&#125;</span>\",\"content\":\"<span class="variable">$&#123;CERTBOT_VALIDATION&#125;</span>\", \"ttl\": 120&#125;"</span> -s | jq -r <span class="string">"[.success, .errors[].message] | @csv"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"添加记录结果Add record result: <span class="variable">$&#123;ADD_RECORD_RESULT&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;ADD_RECORD_RESULT&#125;</span>"</span> | grep <span class="string">"true"</span>) ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"添加记录失败....Add record failed, exit"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    records=$(dig -t TXT <span class="variable">$&#123;CHALLENGE_DOMAIN&#125;</span> @<span class="variable">$&#123;DNS_SERVER&#125;</span> +noall +answer +short | grep <span class="string">"<span class="variable">$&#123;CERTBOT_VALIDATION&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;records&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"等待DNS生效.....DNS records have not been propagate, sleep 10s..."</span></span><br><span class="line">    sleep 10</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DNS已经生效，DNS record have been propagated, finish"</span></span><br></pre></td></tr></table></figure><p><code>cloudflare-clean-dns.sh</code>，这个文件是当证书处理完毕结束后清理掉记录，修改认证头：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">DIR=<span class="string">"<span class="variable">$(dirname "$0")</span>"</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">$DIR</span>/config.sh"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"DOMAIN: <span class="variable">$&#123;CHALLENGE_DOMAIN&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ZONE: <span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">records=($(curl -X GET <span class="string">"https://api.cloudflare.com/client/v4/zones/<span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>/dns_records?type=TXT&amp;name=<span class="variable">$&#123;CHALLENGE_DOMAIN&#125;</span>&amp;page=1&amp;per_page=100"</span> \</span><br><span class="line">     -H <span class="string">"X-Auth-Email: <span class="variable">$&#123;CLOUDFLARE_EMAIL&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Authorization: Bearer <span class="variable">$&#123;CLOUDFLARE_KEY&#125;</span>"</span> \</span><br><span class="line">     -H <span class="string">"Content-Type: application/json"</span> -s | jq -r <span class="string">".result[].id"</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"即将删除这些DNS记录：<span class="variable">$&#123;records&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;records[@]&#125;</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"clean: <span class="variable">$record</span>"</span></span><br><span class="line">    curl -X DELETE <span class="string">"https://api.cloudflare.com/client/v4/zones/<span class="variable">$&#123;CLOUDFLARE_ZONE&#125;</span>/dns_records/<span class="variable">$&#123;record&#125;</span>"</span> \</span><br><span class="line">    -H <span class="string">"X-Auth-Email: <span class="variable">$&#123;CLOUDFLARE_EMAIL&#125;</span>"</span> \</span><br><span class="line">        -H <span class="string">"Authorization: Bearer <span class="variable">$&#123;CLOUDFLARE_KEY&#125;</span>"</span> \</span><br><span class="line">    -H <span class="string">"Content-Type: application/json"</span> -s | jq -r <span class="string">"[.success, .errors[].message] | @csv"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>测试我们的脚本</li></ul><p><code>certbot renew --manual-auth-hook=&quot;/path/to/cloudflare-update-dns.sh&quot; --manual-cleanup-hook=&quot;/path/to/cloudflare-clean-dns.sh&quot; --post-hook=&quot;/path/to/nginx/sbin/nginx -s reload&quot; --dry-run</code></p><p>如果测试通过，就可以配置定时任务了</p><h1><span id="can-kao-lian-jie"> 参考链接</span><a href="#can-kao-lian-jie" class="header-anchor">#</a></h1><blockquote><p><a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/centosrhel7-nginx</a></p><p><a href="https://www.jianshu.com/p/6ea81a7b768f" target="_blank" rel="noopener">https://www.jianshu.com/p/6ea81a7b768f</a></p><p><a href="https://www.jianshu.com/p/a1cc68c7d916" target="_blank" rel="noopener">https://www.jianshu.com/p/a1cc68c7d916</a></p><p><a href="https://github.com/7sDream/certbot-dns-challenge-cloudflare-hooks" target="_blank" rel="noopener">https://github.com/7sDream/certbot-dns-challenge-cloudflare-hooks</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qian-yan&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#han-shang-xuan-ze&quot;&gt;厂商选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="network" scheme="https://blog.sofunnyai.com/categories/network/"/>
    
    
      <category term="网络" scheme="https://blog.sofunnyai.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="运维" scheme="https://blog.sofunnyai.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="hexo" scheme="https://blog.sofunnyai.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>mybatis一些容易忽略的问题</title>
    <link href="https://blog.sofunnyai.com/article/mybatis.html"/>
    <id>https://blog.sofunnyai.com/article/mybatis.html</id>
    <published>2019-03-29T09:20:42.000Z</published>
    <updated>2020-07-29T11:09:16.024Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#mybatis-huan-cun-de-wen-ti">Mybatis缓存的问题</a><ul><li><a href="#yi-ji-huan-cun">一级缓存</a></li><li><a href="#er-ji-huan-cun">二级缓存</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="mybatis-huan-cun-de-wen-ti"> Mybatis缓存的问题</span><a href="#mybatis-huan-cun-de-wen-ti" class="header-anchor">#</a></h1><h2><span id="yi-ji-huan-cun"> 一级缓存</span><a href="#yi-ji-huan-cun" class="header-anchor">#</a></h2><p>默认开启，和session的生命周期相同，一般一个session和一个线程绑定。如果在同一个线程里面进行重复查询会使用缓存。</p><ul><li>但是和spring融合之后就会失效：</li><li>因为myabatis和spring融合的时候，mabatis提供了一个<code>mabatis-spring-xxx.jar</code>，里面提供了一个类叫做<code>SqlSessionTemplate</code>代理替代了mybatis中默认的SqlSession实现<code>DefaultSqlSession</code>，是对<code>DefaultSqlSession</code>的一个增强。这个类在容器启动的时候注入给了mapper，同时它在代理的代码中把session关闭了，所以session执行一次就关闭，无法使用一级缓存。</li><li>为什么要关闭？mybatis为什么不关闭，因为用户自己拿到sqlSession，<code>DefaultSqlSession</code>暴露给用户了，可以自己任意时候关闭，充分利用一级缓存。spring没有把sesqlSession直接暴露给用户，所以每次执行完必须要关，防止用户忘记关闭造成泄漏。</li><li>mapper交给spring来生成代理，sessionFactory也给spring，每次query他都会去开启一个session。</li><li>也就是spring给sqlSession做了一次代理，sqlSession放到了代理中，每次调用完毕他就把sqlsession给关闭了。这样即使在service一个方法中调用dao进行多次同样的query也不会使用缓存。也就是会失效。</li></ul><h2><span id="er-ji-huan-cun"> 二级缓存</span><a href="#er-ji-huan-cun" class="header-anchor">#</a></h2><p><code>＠CacheNamespace</code>注解放到mapper上即可开启。但是名字就能看出来他是一个Namespace级别隔离的。</p><ul><li>在同一个namespace内进行update、delete、insert等操作，此级别内的二级缓存失效，不够精细。</li><li>但是假设这个表的数据在别的地方被修改，或者联合修改，这里感知不到会有问题，又容易出错。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mybatis-huan-cun-de-wen-ti&quot;&gt;Mybatis缓存的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#yi-ji-huan-c
      
    
    </summary>
    
    
      <category term="mybatis" scheme="https://blog.sofunnyai.com/categories/mybatis/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="mybatis" scheme="https://blog.sofunnyai.com/tags/mybatis/"/>
    
      <category term="框架" scheme="https://blog.sofunnyai.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>代理模式的一切</title>
    <link href="https://blog.sofunnyai.com/article/proxy_jdk_cglib.html"/>
    <id>https://blog.sofunnyai.com/article/proxy_jdk_cglib.html</id>
    <published>2019-03-15T04:43:38.000Z</published>
    <updated>2020-07-29T06:05:11.491Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#dai-li-mo-shi-de-bei-jing">代理模式的背景</a><ul><li><a href="#jing-tai-dai-li">静态代理：</a></li><li><a href="#dong-tai-dai-li">动态代理</a><ul><li><a href="#ren-rou-po-su-si-xiang-de-shou-dong-dai-li">人肉朴素思想的手动代理</a></li><li><a href="#jdk-dong-tai-dai-li">JDK 动态代理</a></li><li><a href="#jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng">JDK动态代理为什是接口不是继承？</a></li><li><a href="#cglib">CGlib</a></li><li><a href="#javassist">Javassist</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="dai-li-mo-shi-de-bei-jing"> 代理模式的背景</span><a href="#dai-li-mo-shi-de-bei-jing" class="header-anchor">#</a></h1><p>假如我们有一个用户实现接口，如<code>UserService</code>，和实现类<code>UserServiceImpl</code>。现在想在<code>UserServiceImpl</code>的某些方法前后打印参数日志，可以选择的方式有：</p><h2><span id="jing-tai-dai-li"> 静态代理：</span><a href="#jing-tai-dai-li" class="header-anchor">#</a></h2><ul><li><p><strong>继承</strong>：写一个子类继承这个<code>UserServiceImpl</code>，然后方法前后加上日志功能。但是如果要再实现另外一个增强需求，就需要再次继承。或者对多个接口的方法同时进行增强，就要链式继承。长此以往产生类爆炸。</p></li><li><p><strong>聚合</strong>：<strong>装饰模式</strong>。实现同一个接口<code>UserService</code>，装饰器的构造方法传入一个同样的类，进行包装。在包装方法里面进行前后的增强，再去调用父类。[Java的IO流使用了大量的装饰模式]。和上面的代理很像，但是装饰模式只能装饰一个特定的对象，在构造方法里面传进来，实现同样的接口进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰模式增强，实现相同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDeractor</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法传入同样的对象进行包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceDeractor</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------------装饰模式增强，传入参数"</span>+name);</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：实现起来简单，但是代理类会比较多，比较复杂。</p></li></ul><h2><span id="dong-tai-dai-li"> 动态代理</span><a href="#dong-tai-dai-li" class="header-anchor">#</a></h2><p>基于以上的静态代理，会产生大量的class，如何改进？最浅显的想法就是</p><p>程序拼装这一段动态代理的java文件代码—&gt;然后生成class字节码—&gt;然后加载到项目中—&gt;创建对象并使用。</p><h3><span id="ren-rou-po-su-si-xiang-de-shou-dong-dai-li"> 人肉朴素思想的手动代理</span><a href="#ren-rou-po-su-si-xiang-de-shou-dong-dai-li" class="header-anchor">#</a></h3><p>基于以上思想我们试着实现一个山寨版</p><p>先来一个函数接口，用于动态封装我们的代理增强功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标包装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,Object target, Object... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对某个对象进行增强，就写一个Handler接口的实现，然后在invoke方法中增强。</p><p>将这个invoke传入到我们下面的<code>ProxyUtil</code>中去创建一个代理对象：</p><ul><li><code>public static &lt;T&gt; T getProxy(Object target, MyInvocationHandler handler, Class&lt;T&gt; ... interfaces) throws Exception</code>有三个参数，目标对象、增强实现（或者Lambda）、要实现的接口列表。</li><li>这个方法会把所有target的public方法进行重新生成java，每个方法里面调用<code>handler.invoke</code>进行增强</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人工模拟动态代理， 不用任何第三方jar，也不用JDK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要生成一个代理对象，必然要：</span></span><br><span class="line"><span class="comment">     * 1.先得到java代码</span></span><br><span class="line"><span class="comment">     * 2.然后把java代码变成class</span></span><br><span class="line"><span class="comment">     * 3.然后把class变成对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们动态实现那个装饰模式的静态代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object target, MyInvocationHandler handler, Class&lt;T&gt; ... interfaces)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Class clazz = target.getClass();</span></span><br><span class="line">        <span class="keyword">if</span>(interfaces == <span class="keyword">null</span> || interfaces.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"该对象没有实现接口，无法代理！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Class interfaceClazz = clazz.getInterfaces()[0];</span></span><br><span class="line">        System.out.println(<span class="string">"即将针对接口"</span>+interfaces+<span class="string">"进行动态代理..."</span>);</span><br><span class="line">        <span class="comment">// 拼装java类</span></span><br><span class="line">        StringBuffer java = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String proxyPackage = <span class="string">"com.sam.proxy"</span>;</span><br><span class="line">        java.append(<span class="string">"package "</span>+proxyPackage+<span class="string">";\n\n"</span>);</span><br><span class="line">        <span class="comment">// 引入接口</span></span><br><span class="line">        java.append(Arrays.stream(interfaces).map(c-&gt;<span class="string">"import "</span>+c.getName()).collect(Collectors.joining(<span class="string">";\n"</span>))+<span class="string">";\n"</span>);</span><br><span class="line">        java.append(</span><br><span class="line">                <span class="string">"import "</span>+target.getClass().getName()+<span class="string">";\n"</span> +</span><br><span class="line">                <span class="string">"import java.util.Arrays;\n"</span> +</span><br><span class="line">                "import "+MyInvocationHandler.class.getName()+";\n\n" +  // import MyInvocationHandler</span><br><span class="line">                 <span class="string">"// TODO 这个类是由ProxyUtil自动生成的\n"</span>+</span><br><span class="line">                <span class="comment">// 接口$Myproxy         此处也可以使用</span></span><br><span class="line">                <span class="string">"public class MyProxyOf"</span>+target.getClass().getSimpleName()+<span class="string">" implements "</span>+ Arrays.stream(interfaces).map(Class::getSimpleName).collect(Collectors.joining(<span class="string">","</span>))+<span class="string">" &#123;\n"</span> +</span><br><span class="line">                <span class="comment">// private 接口 target</span></span><br><span class="line">                <span class="string">"    private "</span>+target.getClass().getSimpleName()+<span class="string">" target;\n"</span> +</span><br><span class="line">                "    private "+MyInvocationHandler.class.getSimpleName()+" handler;\n\n" +</span><br><span class="line">                <span class="comment">// 构造方法包装</span></span><br><span class="line">                "    public MyProxyOf"+target.getClass().getSimpleName()+"("+target.getClass().getSimpleName()+" target, "+MyInvocationHandler.class.getSimpleName()+" h)&#123;\n" +</span><br><span class="line">                <span class="string">"        this.target = target;\n"</span> +</span><br><span class="line">                <span class="string">"        this.handler = h;\n"</span> +</span><br><span class="line">                <span class="string">"    &#125;\n"</span>);</span><br><span class="line">        <span class="comment">// 不用在每个方法处理，使用动态处理</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : target.getClass().getDeclaredMethods())&#123;</span><br><span class="line">            <span class="comment">// public com.xx.xx.User getUser(java.lang.String</span></span><br><span class="line">            java.append(<span class="string">"\n\t@Override\n\tpublic "</span>+method.getReturnType().getName()+<span class="string">" "</span>+method.getName()+<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// String name)&#123;</span></span><br><span class="line">            List&lt;String&gt; params = IntStream.range(<span class="number">0</span>,method.getParameterTypes().length).mapToObj(i-&gt;method.getParameterTypes()[i].getName() +<span class="string">" var"</span>+i).collect(Collectors.toList());</span><br><span class="line">            java.append(String.join(<span class="string">", "</span>,params));<span class="comment">// java.lang.String var1, java.lang.Integer var2</span></span><br><span class="line">            java.append(<span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getExceptionTypes().length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                java.append(<span class="string">"thorws "</span>+ Arrays.stream(method.getExceptionTypes()).map(Class::getName).collect(Collectors.joining(<span class="string">", "</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"&#123;\n"</span>);</span><br><span class="line"><span class="comment">// 开始调用invoke或者lambda进行代理增强！</span></span><br><span class="line">            java.append(<span class="string">"\t\tSystem.out.println(\"代理对象中即将调用invoke.....\");\n"</span>);</span><br><span class="line">            <span class="comment">// 调用包装类target的方法，进行增强</span></span><br><span class="line">            java.append(<span class="string">"\t\ttry&#123;\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getParameterTypes().length == <span class="number">0</span>)&#123;</span><br><span class="line">                java.append("\t\t\t"+(method.getReturnType()==void.class?"":("return ("+method.getReturnType().getName()+")"))+"handler.invoke(this, target.getClass().getMethod(\""+method.getName()+"\"), target);\n");</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt;vars = IntStream.range(<span class="number">0</span>,method.getParameterTypes().length).mapToObj(i-&gt;<span class="string">"var"</span>+i).collect(Collectors.toList());</span><br><span class="line">                List&lt;String&gt;paramClazz = Arrays.stream(method.getParameterTypes()).map(c-&gt;c.getName()+<span class="string">".class"</span>).collect(Collectors.toList());</span><br><span class="line">                java.append(<span class="string">"\t\t\tClass[] paramClazz = new Class[]&#123;"</span>+String.join(<span class="string">","</span>,paramClazz)+<span class="string">"&#125;;\n"</span>);</span><br><span class="line">                java.append("\t\t\t"+(method.getReturnType()==void.class?"":("return ("+method.getReturnType().getName()+")"))+"handler.invoke(this, target.getClass().getMethod(\""+method.getName()+"\", paramClazz), target, "+String.join(",",vars)+");\n");</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            java.append(<span class="string">"\t\t&#125;catch(Exception ex)&#123;\n"</span>);</span><br><span class="line">            <span class="comment">//method.getExceptionTypes()</span></span><br><span class="line">            <span class="keyword">if</span>(method.getExceptionTypes().length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                java.append(<span class="string">"\t\tList&lt;Class&gt; methodExs = Arrays.asList("</span>+ String.join(<span class="string">","</span>,Arrays.stream(method.getExceptionTypes()).map(c-&gt;c.getName()+<span class="string">".class"</span>).collect(Collectors.toList()))+<span class="string">");\n"</span>);</span><br><span class="line">                java.append(<span class="string">"\t\t\tif(methodExs.contains(ex.getClass()))&#123;throw ex;&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"\t\t\tex.printStackTrace();\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getReturnType() != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span>&#123; <span class="comment">// 异常时候返回null</span></span><br><span class="line">                java.append(<span class="string">"\t\t\treturn null;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"\t\t&#125;\n"</span>); <span class="comment">// 结束catch</span></span><br><span class="line">            java.append(<span class="string">"\t&#125;\n"</span>);<span class="comment">// 结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        java.append(<span class="string">"&#125;\n"</span>);</span><br><span class="line">        <span class="comment">//System.out.println(java);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 落盘</span></span><br><span class="line">        String filePath = System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/java/"</span>+proxyPackage.replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>);</span><br><span class="line">        String fileprefix = <span class="string">"MyProxyOf"</span>+target.getClass().getSimpleName();</span><br><span class="line">        File dir = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        File javaFile = <span class="keyword">new</span> File(filePath + <span class="string">"/"</span> +fileprefix +<span class="string">".java"</span>);</span><br><span class="line">        <span class="keyword">if</span>(javaFile.exists())&#123;</span><br><span class="line">            javaFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(javaFile);</span><br><span class="line">        fw.write(java.toString());</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">        <span class="keyword">boolean</span> result = compilerJavaFile(filePath + <span class="string">"/"</span> + fileprefix +<span class="string">".java"</span>,System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/target/classes/"</span>);</span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            <span class="comment">// 因为上一步编译到了当前工程的target中，在classpath里面，所以可以Class.forName</span></span><br><span class="line">            <span class="comment">// TODO 如果是线上编译到一个类似/tmp目录，这里需要使用URLClassloader去LoadClass加载进来才行</span></span><br><span class="line">            Class tClass = Class.forName(proxyPackage+<span class="string">".MyProxyOf"</span>+target.getClass().getSimpleName());</span><br><span class="line">            <span class="comment">// 找到装饰模式的那个构造方法，传入装饰器包装的原始对象</span></span><br><span class="line">            <span class="keyword">return</span> (T) tClass.getConstructor(target.getClass(),MyInvocationHandler<span class="class">.<span class="keyword">class</span>).<span class="title">newInstance</span>(<span class="title">target</span>,<span class="title">handler</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态编译java文件到class字节码，需要把JDK/lib/tools.jar加入到环境变量中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFileInputPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileOutputPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compilerJavaFile</span><span class="params">(String sourceFileInputPath, String classFileOutputPath)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sourceFileInputPath="</span>+sourceFileInputPath);</span><br><span class="line">        System.out.println(<span class="string">"classFileOutputPath="</span>+classFileOutputPath);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 设置编译选项，配置class文件输出路径</span></span><br><span class="line">            System.out.println(<span class="string">"输出到:"</span>+classFileOutputPath);</span><br><span class="line">            Iterable&lt;String&gt; options = Arrays.asList(<span class="string">"-d"</span>, classFileOutputPath);</span><br><span class="line">            StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Iterable&lt;? extends JavaFileObject&gt; compilationUnits = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(<span class="keyword">new</span> File(sourceFileInputPath)));</span><br><span class="line">            <span class="keyword">boolean</span> flag = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, options, <span class="keyword">null</span>, compilationUnits).call();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">"动态编译成功！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ClassNotFoundException)&#123;</span><br><span class="line">                System.out.println(<span class="string">"动态编译失败！"</span>);</span><br><span class="line">                System.out.println(<span class="string">"把JDK/lib/tools.jar加入到环境变量中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        UserService instance = getProxy(<span class="keyword">new</span> UserServiceImpl(), (proxy,method,target,params)-&gt;&#123; System.out.println(<span class="string">"在lambda中的增强代理....."</span>);<span class="keyword">return</span> method.invoke(target,params); &#125;, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"-----------------开始运行"</span>);</span><br><span class="line">        instance.addUser(<span class="keyword">new</span> User(<span class="string">"wangwu"</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 这个类是由ProxyUtil自动生成的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyOfUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl target;</span><br><span class="line">    <span class="keyword">private</span> MyInvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyOfUserServiceImpl</span><span class="params">(UserServiceImpl target, MyInvocationHandler h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.handler = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> com.sam.bootdemo.model.<span class="function">User <span class="title">getUser</span><span class="params">(java.lang.String var0)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class[] paramClazz = <span class="keyword">new</span> Class[]&#123;java.lang.String<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"><span class="keyword">return</span> (com.sam.bootdemo.model.User)handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"getUser"</span>, paramClazz), target, var0);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(com.sam.bootdemo.model.User var0)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class[] paramClazz = <span class="keyword">new</span> Class[]&#123;com.sam.bootdemo.model.User<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"addUser"</span>, paramClazz), target, var0);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"initService"</span>), target);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以正常运行并输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动态编译成功！</span><br><span class="line">-----------------开始运行</span><br><span class="line">代理对象中即将调用invoke.....</span><br><span class="line">在lambda中的增强代理.....</span><br><span class="line">UserServiceImpl假装addUser：User(userName&#x3D;wangwu, age&#x3D;20)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="jdk-dong-tai-dai-li"> JDK 动态代理</span><a href="#jdk-dong-tai-dai-li" class="header-anchor">#</a></h3><p>JDK动态代理使用<code>InvocationHandler</code>实现，和我们上面的思想很像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个增强器，来拦截我们包装target的方法，进行业务增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理方法的增强器</span></span><br><span class="line"><span class="comment">     * 调用代理对象的业务对象的时候会来执行这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------UserServiceInvocationHandler.invoke代理增强"</span>);</span><br><span class="line">        <span class="comment">// 此处进行拦截增强</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);  <span class="comment">// 执行target的真正业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试JDK的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"===================JDKProxy InvocationHandler========================="</span>);</span><br><span class="line"><span class="comment">// jdk动态代理</span></span><br><span class="line"><span class="comment">// 为啥要classloader？因为JVM启动的时候已经加载了project的所有class。</span></span><br><span class="line"><span class="comment">// 但是项目运行过程中动态生成了calss，所以要传入classloader去加载这个class。</span></span><br><span class="line"><span class="comment">// 为啥不是URLClassLoader去远程加载？因为JDK动态代理产生的项目是在classpath下的</span></span><br><span class="line"><span class="comment">// 传入classloader、接口、和要增强的InvocationHandler</span></span><br><span class="line">UserService service3 = (UserService) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                                                            <span class="keyword">new</span> Class[]&#123;UserService<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">new</span> <span class="title">UserServiceInvocationHandler</span>(<span class="title">new</span> <span class="title">UserServiceImpl</span>()))</span>;</span><br><span class="line">service3.getUser(<span class="string">"小马"</span>);</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><ul><li><p>Class使用来描述一个类的，看起来是废话。但是很重要，仔细体会。</p></li><li><p>Class对象如  <code>Class userClazz = Clazz.forname(&quot;com.xxx.User&quot;)</code>就可以拿到User类的详细信息，包括属性、方法、构造方法等等。</p></li><li><p><code>一个java文件---&gt;编译成class文件---&gt;解析成byte[]到JVM中---&gt;构建为类对象Class-----&gt;newInstance变成实例</code></p></li><li><p>判断两个对象是否相等，首先判断类加载器是否同一个，不是的话就不相等。这块动态代理判断了。传进去的接口列表使用用户的ClassLoader先加载一遍forName的结果，看看和传进来的是否相同。</p></li><li><p>默认生成的代理类在<code>com.sun.proxy</code>这个包名下如<code>com.sun.proxy.$Proxy0</code>，除非有interface不是public的，会生成到这个interface同包名下（否则无法外部implements访问到）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.reflect.Proxy中获取到包名后生成class字节流的方法，使用了native方法生成</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><p>JDK上面那一步动态生成的类，我们反编译后看一眼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sam.bootdemo.model.User;</span><br><span class="line"><span class="keyword">import</span> com.sam.bootdemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了JDK的Proxy，所以不能继承我们的目标对象，只能是实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反射获取了我们UserService接口中需要覆盖的方法，同时反射拿到要覆盖的hashCode、equals、toString方法</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"initService"</span>);</span><br><span class="line">            m5 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"addUser"</span>, Class.forName(<span class="string">"com.sam.bootdemo.model.User"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"getUser"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法传入了我们写的增强类InvocationHandler，塞到父类Proxy中了</span></span><br><span class="line">    <span class="comment">// 这个handler里面有包装我们的原始userServiceImpl对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 因为实现了同样的UserService接口，这里代理实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> User <span class="title">getUser</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用了invocationHandler的invoke方法，传入 代理对象、method、参数。（但是缺少真正的target，target在invocationhandler中，也就是我们要增强的userServiceImpl对象）</span></span><br><span class="line">            <span class="keyword">return</span> (User)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User var1)</span> <span class="keyword">throws</span> FileNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | FileNotFoundException | SQLException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString、equals、hashCode也调用了invocationHandler的invoke方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现JDK生成代理类的逻辑和我们之前手动山寨版的很像。只是JDK是调用native方法直接生成字节流数组。我们是拼装java，再动态编译为class的。</p><p>虽然是native方法，但JDK也是通过反射生成的，他反射读取了我们接口中的方法列表，逐个实现，然后生成到class流里的。</p><p><strong>缺点：</strong> 必须要有接口，才能生成动态代理。如果对象没有接口就无法进行代理。</p><h3><span id="jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng"> JDK动态代理为什是接口不是继承？</span><a href="#jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng" class="header-anchor">#</a></h3><p>因为Java是单继承的，JDK底层源码已经继承了proxy对象， 里面存放了invocationHandler（invocationHandler里面包装了我们的目标对象）。所以不能再继承我们的目标对象。</p><p>只能去和目标对象实现相同的接口，包装一下，具有相同行为。</p><h3><span id="cglib"> CGlib</span><a href="#cglib" class="header-anchor">#</a></h3><p>使用基于继承的方式，使用ASM进行字节码操作完成代理增强。都是直接操作字节码和JDK比起来性能差异不大。来看看Spring使用CGlib对类的代理：</p><p>这里的核心作用：</p><p><strong>这个类使用CGlib来生成@Configuration类的子类，使得每一个@Bean修饰的方法都会被子类重写，除非容器来调用，否则在其他地方来调用这些@Bean方法的时候不会创建对象（会破坏单例性），而是返回一个容器内已有的Bean的引用。</strong></p><p>CGlib的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* CHlib创建子类的核心逻辑</span></span><br><span class="line"><span class="comment"> * Creates a new CGLIB &#123;@link Enhancer&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 一个增强器，是CGlib核心接口ClassGenerator的实现</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       <span class="comment">// 设置父类，就是当前@Configuration修饰的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">       <span class="comment">// 给代理类实现一个实际上是BeanFactoryAware接口，用来注入$$beanFactory</span></span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">       <span class="comment">// 是否实现Factory接口，一般false</span></span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 生成的beanName策略 xxxBySpringCGLIB</span></span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">       <span class="comment">// 自定义CGlib生成策略，里面声明了一个public 的 $$beanFactory用来存放aware注入的bf</span></span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">       <span class="comment">// 设置一个方法调用的过滤器，塞进去了两个：</span></span><br><span class="line">       <span class="comment">//new BeanMethodInterceptor()： </span></span><br><span class="line">       <span class="comment">//拦截@Bean方法,&amp;beanName去BF里面拿一下，判断是否是FactoryBean，是的话对FB里面的getObject进行代理，非inCreation调用时返回引用。容器调用的时候inCreation，才真的getObject</span></span><br><span class="line">       <span class="comment">// 非FactoryBean的代理了@Bean注解方法，非inCreation调用时返回引用。容器调用的时候inCreation，才真的new</span></span><br><span class="line">    <span class="comment">//new BeanFactoryAwareMethodInterceptor(),</span></span><br><span class="line">       <span class="comment">// 代理setBF方法，如果找到$$beanFactory，就在setBF方法里面给bf设置到$$beanFactory上</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整部分参见下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment">* 这个类使用CGlib来生成<span class="doctag">@Configuration</span>类的子类，使得每一个<span class="doctag">@Bean</span>修饰的方法都会被子类重写，除非容器来调用，否则在其他地方来调用这些<span class="doctag">@Bean</span>方法的时候不会创建对象（会破坏单例性），而是返回一个容器内已有的Bean的引用。</span></span><br><span class="line"><span class="comment"> * Enhances &#123;<span class="doctag">@link</span> Configuration&#125; classes by generating a CGLIB subclass which</span></span><br><span class="line"><span class="comment"> * interacts with the Spring container to respect bean scoping semantics for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods. Each such &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method will be overridden in</span></span><br><span class="line"><span class="comment"> * the generated subclass, only delegating to the actual &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method</span></span><br><span class="line"><span class="comment"> * implementation if the container actually requests the construction of a new</span></span><br><span class="line"><span class="comment"> * instance. Otherwise, a call to such an &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method serves as a</span></span><br><span class="line"><span class="comment"> * reference back to the container, obtaining the corresponding bean by name.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #enhance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The callbacks to use. Note that these callbacks must be stateless.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line"><span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类里面增强一个BF的属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_FACTORY_FIELD = <span class="string">"$$beanFactory"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ConfigurationClassEnhancer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SpringObjenesis objenesis = <span class="keyword">new</span> SpringObjenesis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">外面ConfigurationClassPostProcessor调用的入口</span></span><br><span class="line"><span class="comment"> * Loads the specified class and generates a CGLIB subclass of it equipped with</span></span><br><span class="line"><span class="comment"> * container-aware callbacks capable of respecting scoping and other bean semantics.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the enhanced subclass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (EnhancedConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">configClass</span>)) </span>&#123;  <span class="comment">// 这里判断是否EnhancedConfiguration接口。这是一个空接口，是BFAware的子接口，</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">"Ignoring request to enhance %s as it has "</span> +</span><br><span class="line"><span class="string">"already been enhanced. This usually indicates that more than one "</span> +</span><br><span class="line"><span class="string">"ConfigurationClassPostProcessor has been registered (e.g. via "</span> +</span><br><span class="line"><span class="string">"&lt;context:annotation-config&gt;). This is harmless, but you may "</span> +</span><br><span class="line"><span class="string">"want check your configuration and remove one CCPP if possible"</span>,</span><br><span class="line">configClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> configClass;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，真正开始进行增强</span></span><br><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(String.format(<span class="string">"Successfully enhanced %s; enhanced class name is: %s"</span>,</span><br><span class="line">configClass.getName(), enhancedClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* CHlib创建子类的核心逻辑</span></span><br><span class="line"><span class="comment"> * Creates a new CGLIB &#123;@link Enhancer&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个增强器，是CGlib核心接口ClassGenerator的实现</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类，就是当前@Configuration修饰的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">        <span class="comment">// 给代理类实现一个实际上是BeanFactoryAware接口，用来注入$$beanFactory</span></span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        <span class="comment">// 是否实现Factory接口，一般false</span></span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 生成的beanName策略 xxxBySpringCGLIB</span></span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="comment">// 自定义CGlib生成策略，里面声明了一个public 的 $$beanFactory用来存放aware注入的bf</span></span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">        <span class="comment">// 设置一个方法调用的过滤器，塞进去了两个：</span></span><br><span class="line">        <span class="comment">//new BeanMethodInterceptor()： </span></span><br><span class="line">        <span class="comment">//拦截@Bean方法,&amp;beanName去BF里面拿一下，判断是否是FactoryBean，是的话对FB里面的getObject进行代理，非inCreation调用时返回引用。容器调用的时候inCreation，才真的getObject</span></span><br><span class="line">        <span class="comment">// 非FactoryBean的代理了@Bean注解方法，非inCreation调用时返回引用。容器调用的时候inCreation，才真的new</span></span><br><span class="line">    <span class="comment">//new BeanFactoryAwareMethodInterceptor(),</span></span><br><span class="line">        <span class="comment">// 代理setBF方法，如果找到$$beanFactory，就在setBF方法里面给bf设置到$$beanFactory上</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Uses enhancer to generate a subclass of superclass,</span></span><br><span class="line"><span class="comment"> * ensuring that callbacks are registered for the new subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line"><span class="comment">// Registering callbacks statically (as opposed to thread-local)</span></span><br><span class="line"><span class="comment">// is critical for usage in an OSGi environment (SPR-5932)...</span></span><br><span class="line">Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line"><span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">空接口，只是一个BFAware的子接口，用来标记当前类可以注入BF</span></span><br><span class="line"><span class="comment"> * Marker interface to be implemented by all <span class="doctag">@Configuration</span> CGLIB subclasses.</span></span><br><span class="line"><span class="comment"> * Facilitates idempotent behavior for &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer#enhance&#125;</span></span><br><span class="line"><span class="comment"> * through checking to see if candidate classes are already assignable to it, e.g.</span></span><br><span class="line"><span class="comment"> * have already been enhanced.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Also extends &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, as all enhanced &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * classes require access to the &#123;<span class="doctag">@link</span> BeanFactory&#125; that created them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this interface is intended for framework-internal use only, however</span></span><br><span class="line"><span class="comment"> * must remain public in order to allow access to subclasses generated from other</span></span><br><span class="line"><span class="comment"> * packages (i.e. user code).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnhancedConfiguration</span> <span class="keyword">extends</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Conditional &#123;<span class="doctag">@link</span> Callback&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalCallbackFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalCallback</span> <span class="keyword">extends</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> CallbackFilter&#125; that works by interrogating &#123;<span class="doctag">@link</span> Callback Callbacks&#125; in the order</span></span><br><span class="line"><span class="comment"> * that they are defined via &#123;<span class="doctag">@link</span> ConditionalCallback&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callback[] callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt;[] callbackTypes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionalCallbackFilter</span><span class="params">(Callback[] callbacks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks = callbacks;</span><br><span class="line"><span class="keyword">this</span>.callbackTypes = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbackTypes[i] = callbacks[i].getClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.callbacks.length; i++) &#123;</span><br><span class="line">Callback callback = <span class="keyword">this</span>.callbacks[i];</span><br><span class="line"><span class="keyword">if</span> (!(callback <span class="keyword">instanceof</span> ConditionalCallback) || ((ConditionalCallback) callback).isMatch(method)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No callback available for method "</span> + method.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getCallbackTypes() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.callbackTypes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Custom extension of CGLIB's DefaultGeneratorStrategy, introducing a &#123;<span class="doctag">@link</span> BeanFactory&#125; field.</span></span><br><span class="line"><span class="comment"> * Also exposes the application ClassLoader as thread context ClassLoader for the time of</span></span><br><span class="line"><span class="comment"> * class generation (in order for ASM to pick it up when doing common superclass resolution).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAwareGeneratorStrategy</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">ClassLoaderAwareGeneratorStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanFactoryAwareGeneratorStrategy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassGenerator <span class="title">transform</span><span class="params">(ClassGenerator cg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ClassEmitterTransformer transformer = <span class="keyword">new</span> ClassEmitterTransformer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end_class</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 给代理类塞进去一个public的$$beanFactory属性，用来BeanFactoryAware接口的setBF的时候拦截注入BF</span></span><br><span class="line">declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory<span class="class">.<span class="keyword">class</span>), <span class="title">null</span>)</span>;</span><br><span class="line"><span class="keyword">super</span>.end_class();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TransformingClassGenerator(cg, transformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts the invocation of any &#123;<span class="doctag">@link</span> BeanFactoryAware#setBeanFactory(BeanFactory)&#125; on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class instances for the purpose of recording the &#123;<span class="doctag">@link</span> BeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnhancedConfiguration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAwareMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">ConditionalCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">Assert.state(field != <span class="keyword">null</span>, <span class="string">"Unable to find generated BeanFactory field"</span>);</span><br><span class="line">field.set(obj, args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?</span></span><br><span class="line"><span class="comment">// If so, call its setBeanFactory() method. If not, just exit.</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">ClassUtils</span>.<span class="title">getUserClass</span>(<span class="title">obj</span>.<span class="title">getClass</span>().<span class="title">getSuperclass</span>()))) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 匹配是否是setBeanFactory方法</span></span><br><span class="line"><span class="keyword">return</span> isSetBeanFactory(candidateMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetBeanFactory</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (candidateMethod.getName().equals(<span class="string">"setBeanFactory"</span>) &amp;&amp;</span><br><span class="line">candidateMethod.getParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">BeanFactory<span class="class">.<span class="keyword">class</span> </span>== candidateMethod.getParameterTypes()[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">candidateMethod</span>.<span class="title">getDeclaringClass</span>()))</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts the invocation of any &#123;<span class="doctag">@link</span> Bean&#125;-annotated methods in order to ensure proper</span></span><br><span class="line"><span class="comment"> * handling of bean semantics such as scoping and AOP proxying.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">ConditionalCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enhance a &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; method to check the supplied BeanFactory for the</span></span><br><span class="line"><span class="comment"> * existence of this bean object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable as a catch-all for any exception that may be thrown when invoking the</span></span><br><span class="line"><span class="comment"> * super implementation of the proxied method i.e., the actual &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine whether this bean is a scoped-proxy</span></span><br><span class="line"><span class="keyword">if</span> (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">beanName = scopedBeanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To handle the case of an inter-bean method reference, we must explicitly check the</span></span><br><span class="line"><span class="comment">// container for already cached instances.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先检查是不是FactoryBean，是的话就创建一个子类并拦截getObject()方法，调用缓存的对象。</span></span><br><span class="line"><span class="comment">// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span></span><br><span class="line"><span class="comment">// proxy that intercepts calls to getObject() and returns any cached bean instance.</span></span><br><span class="line"><span class="comment">// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span></span><br><span class="line"><span class="comment">// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span></span><br><span class="line">            <span class="comment">// 如果是一个FactoryBean，而且&amp;beanName可以拿到，就去处理FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (factoryBean <span class="keyword">instanceof</span> ScopedProxyFactoryBean) &#123;</span><br><span class="line"><span class="comment">// Scoped proxy factory beans are a special case and should not be further proxied</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It is a candidate FactoryBean - go ahead with enhancement</span></span><br><span class="line"><span class="keyword">return</span> enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// BF在调用的时候，需要真的去创建</span></span><br><span class="line"><span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"><span class="comment">// The factory is calling the bean method in order to instantiate and register the bean</span></span><br><span class="line"><span class="comment">// (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually</span></span><br><span class="line"><span class="comment">// create the bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanMethod</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">logger.info(String.format(<span class="string">"@Bean method %s.%s is non-static and returns an object "</span> +</span><br><span class="line"><span class="string">"assignable to Spring's BeanFactoryPostProcessor interface. This will "</span> +</span><br><span class="line"><span class="string">"result in a failure to process annotations such as @Autowired, "</span> +</span><br><span class="line"><span class="string">"@Resource and @PostConstruct within the method's declaring "</span> +</span><br><span class="line"><span class="string">"@Configuration class. Add the 'static' modifier to this method to avoid "</span> +</span><br><span class="line"><span class="string">"these container lifecycle issues; see @Bean javadoc for complete details."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到bean的引用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveBeanReference</span><span class="params">(Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The user (i.e. not the factory) is requesting this bean through a call to</span></span><br><span class="line"><span class="comment">// the bean method, direct or indirect. The bean may have already been marked</span></span><br><span class="line"><span class="comment">// as 'in creation' in certain autowiring scenarios; if so, temporarily set</span></span><br><span class="line"><span class="comment">// the in-creation status to false in order to avoid an exception.</span></span><br><span class="line"><span class="keyword">boolean</span> alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> useArgs = !ObjectUtils.isEmpty(beanMethodArgs);</span><br><span class="line"><span class="keyword">if</span> (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// Stubbed null arguments just for reference purposes,</span></span><br><span class="line"><span class="comment">// expecting them to be autowired for regular singleton references?</span></span><br><span class="line"><span class="comment">// A safe assumption since @Bean singleton arguments cannot be optional...</span></span><br><span class="line"><span class="keyword">for</span> (Object arg : beanMethodArgs) &#123;</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">useArgs = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :</span><br><span class="line">beanFactory.getBean(beanName));</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) &#123;</span><br><span class="line"><span class="comment">// Detect package-protected NullBean instance through equals(null) check</span></span><br><span class="line"><span class="keyword">if</span> (beanInstance.equals(<span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">"@Bean method %s.%s called as bean reference "</span> +</span><br><span class="line"><span class="string">"for type [%s] returned null bean; resolving to null value."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),</span><br><span class="line">beanMethod.getReturnType().getName()));</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String msg = String.format(<span class="string">"@Bean method %s.%s called as bean reference "</span> +</span><br><span class="line"><span class="string">"for type [%s] but overridden by non-compatible bean instance of type [%s]."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),</span><br><span class="line">beanMethod.getReturnType().getName(), beanInstance.getClass().getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">msg += <span class="string">" Overriding bean of same name declared in: "</span> + beanDefinition.getResourceDescription();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore - simply no detailed message then.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line"><span class="keyword">if</span> (currentlyInvoked != <span class="keyword">null</span>) &#123;</span><br><span class="line">String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);</span><br><span class="line">beanFactory.registerDependentBean(beanName, outerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (candidateMethod.getDeclaringClass() != Object<span class="class">.<span class="keyword">class</span> &amp;&amp;</span></span><br><span class="line"><span class="class">!<span class="title">BeanFactoryAwareMethodInterceptor</span>.<span class="title">isSetBeanFactory</span>(<span class="title">candidateMethod</span>) &amp;&amp;</span></span><br><span class="line"><span class="class"><span class="title">BeanAnnotationHelper</span>.<span class="title">isBeanAnnotated</span>(<span class="title">candidateMethod</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableBeanFactory <span class="title">getBeanFactory</span><span class="params">(Object enhancedConfigInstance)</span> </span>&#123;</span><br><span class="line">Field field = ReflectionUtils.findField(enhancedConfigInstance.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">Assert.state(field != <span class="keyword">null</span>, <span class="string">"Unable to find generated bean factory field"</span>);</span><br><span class="line">Object beanFactory = ReflectionUtils.getField(field, enhancedConfigInstance);</span><br><span class="line">Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">"BeanFactory has not been injected into @Configuration class"</span>);</span><br><span class="line">Assert.state(beanFactory <span class="keyword">instanceof</span> ConfigurableBeanFactory,</span><br><span class="line"><span class="string">"Injected BeanFactory is not a ConfigurableBeanFactory"</span>);</span><br><span class="line"><span class="keyword">return</span> (ConfigurableBeanFactory) beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the BeanFactory to see whether the bean named &lt;var&gt;beanName&lt;/var&gt; already</span></span><br><span class="line"><span class="comment"> * exists. Accounts for the fact that the requested bean may be "in creation", i.e.:</span></span><br><span class="line"><span class="comment"> * we're in the middle of servicing the initial request for this bean. From an enhanced</span></span><br><span class="line"><span class="comment"> * factory method's perspective, this means that the bean does not actually yet exist,</span></span><br><span class="line"><span class="comment"> * and that it is now our job to create it for the first time by executing the logic</span></span><br><span class="line"><span class="comment"> * in the corresponding factory method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Said another way, this check repurposes</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableBeanFactory#isCurrentlyInCreation(String)&#125; to determine whether</span></span><br><span class="line"><span class="comment"> * the container is calling this method or the user is calling this method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName name of bean to check for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether &lt;var&gt;beanName&lt;/var&gt; already exists in the factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">factoryContainsBean</span><span class="params">(ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (beanFactory.containsBean(beanName) &amp;&amp; !beanFactory.isCurrentlyInCreation(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check whether the given method corresponds to the container's currently invoked</span></span><br><span class="line"><span class="comment"> * factory method. Compares method name and parameter types only in order to work</span></span><br><span class="line"><span class="comment"> * around a potential problem with covariant return types (currently only known</span></span><br><span class="line"><span class="comment"> * to happen on Groovy classes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCurrentlyInvokedFactoryMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line"><span class="keyword">return</span> (currentlyInvoked != <span class="keyword">null</span> &amp;&amp; method.getName().equals(currentlyInvoked.getName()) &amp;&amp;</span><br><span class="line">Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory</span></span><br><span class="line"><span class="comment"> * instead of creating a new instance. These proxies are created only when calling a FactoryBean from</span></span><br><span class="line"><span class="comment"> * within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean</span></span><br><span class="line"><span class="comment"> * instance directly. If a FactoryBean instance is fetched through the container via &amp;-dereferencing,</span></span><br><span class="line"><span class="comment"> * it will not be proxied. This too is aligned with the way XML configuration works.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">enhanceFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean, Class&lt;?&gt; exposedType,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = factoryBean.getClass();</span><br><span class="line"><span class="keyword">boolean</span> finalClass = Modifier.isFinal(clazz.getModifiers());</span><br><span class="line"><span class="keyword">boolean</span> finalMethod = Modifier.isFinal(clazz.getMethod(<span class="string">"getObject"</span>).getModifiers());</span><br><span class="line"><span class="keyword">if</span> (finalClass || finalMethod) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedType.isInterface()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating interface proxy for FactoryBean '"</span> + beanName + <span class="string">"' of type ["</span> +</span><br><span class="line">clazz.getName() + <span class="string">"] for use within another @Bean method because its "</span> +</span><br><span class="line">(finalClass ? <span class="string">"implementation class"</span> : <span class="string">"getObject() method"</span>) +</span><br><span class="line"><span class="string">" is final: Otherwise a getObject() call would not be routed to the factory."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to proxy FactoryBean '"</span> + beanName + <span class="string">"' of type ["</span> +</span><br><span class="line">clazz.getName() + <span class="string">"] for use within another @Bean method because its "</span> +</span><br><span class="line">(finalClass ? <span class="string">"implementation class"</span> : <span class="string">"getObject() method"</span>) +</span><br><span class="line"><span class="string">" is final: A getObject() call will NOT be routed to the factory. "</span> +</span><br><span class="line"><span class="string">"Consider declaring the return type as a FactoryBean interface."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line"><span class="comment">// No getObject() method -&gt; shouldn't happen, but as long as nobody is trying to call it...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createInterfaceProxyForFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean, Class&lt;?&gt; interfaceType,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">factoryBean.getClass().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceType&#125;,</span><br><span class="line">(proxy, method, args) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"getObject"</span>) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ReflectionUtils.invokeMethod(method, factoryBean, args);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createCglibProxyForFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(factoryBean.getClass());</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setCallbackType(MethodInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ideally create enhanced FactoryBean proxy without constructor side effects,</span></span><br><span class="line"><span class="comment">// analogous to AOP proxy creation in ObjenesisCglibAopProxy...</span></span><br><span class="line">Class&lt;?&gt; fbClass = enhancer.createClass();</span><br><span class="line">Object fbProxy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objenesis.isWorthTrying()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ObjenesisException ex) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to instantiate enhanced FactoryBean using Objenesis, "</span> +</span><br><span class="line"><span class="string">"falling back to regular construction"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fbProxy == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to instantiate enhanced FactoryBean using Objenesis, "</span> +</span><br><span class="line"><span class="string">"and regular FactoryBean instantiation via default constructor fails as well"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((Factory) fbProxy).setCallback(<span class="number">0</span>, (MethodInterceptor) (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"getObject"</span>) &amp;&amp; args.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> proxy.invoke(factoryBean, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fbProxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="javassist"> Javassist</span><a href="#javassist" class="header-anchor">#</a></h3><p>也可以实现字节码增强的代理，使用不太多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#dai-li-mo-shi-de-bei-jing&quot;&gt;代理模式的背景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jing-tai-dai-li&quot;&gt;静
      
    
    </summary>
    
    
      <category term="spring" scheme="https://blog.sofunnyai.com/categories/spring/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="spring" scheme="https://blog.sofunnyai.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>IO基础-select、poll、epoll和TCP</title>
    <link href="https://blog.sofunnyai.com/article/io-basic-socket-tcp.html"/>
    <id>https://blog.sofunnyai.com/article/io-basic-socket-tcp.html</id>
    <published>2018-09-12T12:12:26.000Z</published>
    <updated>2020-06-14T10:58:15.967Z</updated>
    
    <content type="html"><![CDATA[<!--toc--><h1><span id="ji-suan-ji-zu-cheng-yuan-li"> 计算机组成原理</span><a href="#ji-suan-ji-zu-cheng-yuan-li" class="header-anchor">#</a></h1><ul><li>内核态与用户态：计算机刚开机的时候，硬盘的kernel内核程序先加载，然后才启动上层的各种app应用文件。</li><li>kernel启动的时候会先在内存中开启<code>内核空间</code>，或者<code>内核态</code>。剩余的部分给<code>用户态</code>、<code>用户空间</code></li><li><code>用户态</code>的应用程序无法直接访问内核态的内存，必须调用内核的“系统调用”才可以。(system call ，在man里面是2类)</li><li>应用程序去调用的“系统调用”需要通过【中断】的方式找到内核的方法实现，CPU切换到内核态，内核中断去访问硬件</li></ul><h2><span id="zhong-duan"> 中断</span><a href="#zhong-duan" class="header-anchor">#</a></h2><ul><li><p>背景：CPU内部有<code>晶振</code>元件，通电后在一定时间内振动固定的次数。当晶振一定次数后，产生“时间中断”，就产生了所谓CPU时间片。</p></li><li><p>1.内核启动的时候会产生一个<strong>进程调度的回调地址Callback</strong></p></li><li><p>2.CPU产生中断的时候会把缓存刷回程序内存，保护现场。</p></li><li><p>3.然后调用内核的callback，根据不同优先级调用的不同进程回调地址。（从主存里面把曾经刷过去的缓存再加载到CPU缓存）</p></li><li><p>4.下次晶振再重复上面的过程，就完成了进程切换的过程。</p></li><li><p>**缺点：**如果进程很多，切换成本很高，比如切换过去后发现在阻塞，其实是一种浪费。</p></li><li><p><code>软中断</code>：因为应用程序需要进行<code>系统调用</code>，调用内核态。会发生用户态到内核态的切换。CPU需要刷缓存，调用callback，传递参数，再回来。</p><ul><li>系统调用是一个软中断，中断号是0x80，它是上层应用程序与Linux系统内核进行交互通信的唯一接口。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200611004737711.png" alt="image-20200611004737711"></p></li></ul><p>我们有多个应用，应用IO的变化是由内核的变化来实现的。</p><h2><span id="ying-jian-zhong-duan"> 硬件中断</span><a href="#ying-jian-zhong-duan" class="header-anchor">#</a></h2><ul><li><p>我们有多个硬件设备，比如键盘、鼠标、网卡，当他们发生动作的时候如何让OS响应？也是通过调用中断。</p></li><li><p>比如鼠标点击的时候调用CPU中断，传递参数生成一个事件event。CPU去调用kernel（kernel启动的时候通过设备的驱动程序获取了中断号和callback。包括中断信号，和执行的方法）</p></li><li><p>然后kernel根据对应的callback程序做出正确的响应即可。</p></li><li><p>网卡为了避免频繁发送中断，使得降低CPU的浪费，会在内存中被分配极小一块缓存区域（DMA区域 直接内存），攒够了发一次中断。是一个<code>buffer</code>思想。</p></li></ul><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200611012918098.png" alt="image-20200611012918098"></p><h1><span id="io-sheng-ji-fa-zhan-zhi-lu"> IO 升级发展之路</span><a href="#io-sheng-ji-fa-zhan-zhi-lu" class="header-anchor">#</a></h1><h2><span id="jing-dian-cs-jia-gou-de-bio"> 经典CS架构的BIO</span><a href="#jing-dian-cs-jia-gou-de-bio" class="header-anchor">#</a></h2><ul><li>任何服务想要启动监听接受请求，需要进行以下步骤</li><li>1.调用kernel启动一个socket的文件描述符，假设叫fd3，监听</li><li>2.死循环去调用kernel的accept(fd3)方法，去不断获取最新的客户端文件描述符，假设获得一个客户端fd4</li><li>3.去调用kernel的read(fd4)方法读取客户端的消息，这是一个阻塞方法！！！</li><li>4.为了不阻塞，只能accept拿到每一个客户端之后，read去启动一个线程，线程里面去阻塞读取用户消息。</li></ul><p>弊端：有多少客户端连接，就要启动多少线程，资源浪费极大。而且多线程的数据共享、调度都很麻烦。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200611003327548.png" alt="image-20200611003327548"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    client_fd = accept(server监听的fd)  <span class="comment">// 获取客户端的监听，调用内核态</span></span><br><span class="line">        <span class="keyword">new</span> Thread(read(client_fd)).start() <span class="comment">// 单独启动线程去阻塞读取用户响应，阻塞调用内核态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【痛点】：kernel的read(fd)操作是阻塞的(在等待对端发消息)，会需要很多线程，但是多线程开销太大，kernel的调度也很费劲。</p><h3><span id="c10k-wen-ti"> C10K问题</span><a href="#c10k-wen-ti" class="header-anchor">#</a></h3><p>最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程/线程。假如有C10K也即是1W个客户端，就需要创建1W个进程/线程，可想而知单机是无法承受的。那么<strong>如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题</strong>，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。</p><p>【<strong>问题本质</strong>】：是操作系统的问题，创建的<strong>进程或线程多了，数据拷贝频繁</strong>（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，<strong>进程/线程上下文切换消耗大</strong>， 导致操作系统崩溃，这就是C10K问题的本质。</p><p>【<strong>解决方案</strong>】：</p><p>同一个线程/进程同时处理多个连接---------------------多路复用。</p><p>​</p><h2><span id="kernel-de-fei-zu-sai-de-read-yu-duo-lu-fu-yong-qi-nio-shi-dai"> kernel的非阻塞的read与多路复用器（NIO时代）</span><a href="#kernel-de-fei-zu-sai-de-read-yu-duo-lu-fu-yong-qi-nio-shi-dai" class="header-anchor">#</a></h2><p>kernel进化了，支持了一个应用层面非阻塞的read接口，所以我们应用就可以同上类似：</p><ul><li><p>任何服务想要启动监听接受请求，需要进行以下步骤</p></li><li><p>1.调用kernel启动一个socket的文件描述符，假设叫fd3，监听</p></li><li><p>2.死循环去调用kernel的accept(fd3)方法，去不断获取最新的客户端文件描述符，假设获得一个客户端fd4</p></li><li><p>3.去调用kernel的非阻塞read(fd4)方法读取客户端的消息，这是一个非阻塞方法。有内容就给你，没有就给一个没有个的返回或者异常。调用后就该干嘛干嘛去，待会儿再来。</p></li><li><p>4.不用去开启线程，直接循环回到第2步骤，再去获取客户端。（截止这一轮2个客户端的话保存一个fd的数组）</p></li><li><p>5.上面的第3步循环这个客户端fd的数组，逐个去调用kernel的非阻塞read(each_fd)方法，拿到返回继续会到2…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    client_fd = accept(server监听的fd)  <span class="comment">// 获取客户端的监听，调用内核态</span></span><br><span class="line">    clients.add(client_df)   <span class="comment">// 存储一个新的客户端</span></span><br><span class="line">     <span class="keyword">for</span>(each_fd in clients)&#123;</span><br><span class="line">         msg = read(each_fd)  <span class="comment">// 非阻塞读取到消息，非阻塞调用内核态</span></span><br><span class="line">         <span class="comment">// 业务处理</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200611010419797.png" alt="image-20200611010419797"></p><p>或者可以启动2个线程，一个<code>Boss</code>线程去死循环专门获取客户端的连接，一个<code>Worker</code>线程去专门死循环所有的客户端非阻塞读取消息。----------是不是有Netty的感觉了？</p><p>【弊端】：工作线程的worker虽然都不是阻塞的，不用启动多线程。但是还是要进行<code>系统调用</code>，也就是调用内核。调用内核是通过<code>软中断</code>实现的。<code>用户态</code>到<code>内核态</code>的切换太频繁。</p><p><strong>比如10w的fd客户端，work线程每次循环需要调用10w次kernel的read方法，发生10w次用户态和内核态的切换。但是可能只有10个人发消息了，绝大部分的内核切换都浪费了。read的调用是O(n)的。</strong></p><p>现在的JDK的NIO包中已经使用了多路复用器解决，见下节。</p><h2><span id="duo-lu-fu-yong-qi-shi-xian-select-poll-he-epoll"> 多路复用器实现—select/poll和epoll</span><a href="#duo-lu-fu-yong-qi-shi-xian-select-poll-he-epoll" class="header-anchor">#</a></h2><p>kernel发生变化，我们才能突破。如果无法解决上面例子中10w个fd需要10w次调用才能传给kernel的问题，就无法改进。</p><h3><span id="di-yi-lei-duo-lu-fu-yong-qi-select-he-poll"> 第一类多路复用器—select和poll</span><a href="#di-yi-lei-duo-lu-fu-yong-qi-select-he-poll" class="header-anchor">#</a></h3><p><code>man 2 select</code>可以看到内核的select多路复用情况。</p><p><strong>【多路 复用】</strong>：假设10w个客户端fd，<strong>把原先需要调用10w次read(each_fd)读取消息，复用成select(fds)</strong>，返回有消息的fd集合。</p><p>select多路复用器带来的改变：</p><ul><li>任何服务想要启动监听接受请求，需要进行以下步骤</li><li>1.调用kernel启动一个socket的文件描述符，假设叫fd3，监听</li><li>2.死循环去调用kernel的accept(fd3)方法，去不断获取最新的客户端文件描述符，假设获得一个客户端fd4，多个积攒的客户端得到一个fd的集合fds</li><li>3.去调用<strong>一次</strong>kernel的select(fds)方法，kernel去把所有的fd进行检查，把发生消息变化的fd集合返回！<strong>【循环发生在kernel里面，没有用户态和内核态的切换】</strong></li><li>4.程序只用去调用上面有消息的一小部分fd的read(each_fd)方法，就能读取到消息</li><li>5.回到2循环…</li></ul><p><strong>【优势】</strong>：大大减少内核态和用户态的切换。例子中一次调用复用了10w次read，后续统一处理返回的个别有消息的fd。</p><p><strong>【弊端】</strong>：</p><ul><li>1.每次循环调用select的时候，都要copy 10w个fd的数据从用户态到内核态。（内核能记住之前的客户端多好？）</li><li>2.内核态还需要把这10w个fd每次都循环检查一遍。</li></ul><p>select支持的fd是有上限的，需要重新编译内核才行很费劲，默认只支持1024个fd的多路复用。</p><p>poll改进：使用一个链表结构突破限制，支持无上限的fd集合一起传输。只依赖于操作系统的<code>ulimites</code>设置</p><h3><span id="di-er-lei-duo-lu-fu-yong-qi-epoll-io-event-notifycation-facility"> 第二类多路复用器----epoll-IO/Event Notifycation facility</span><a href="#di-er-lei-duo-lu-fu-yong-qi-epoll-io-event-notifycation-facility" class="header-anchor">#</a></h3><p>epoll是一个多路复用的进阶版，改进了客户端fd频繁copy到内核态的问题。是同步非阻塞的。是C10K问题的进阶版。</p><ul><li><p>系统级同步：程序还是需要去主动调用kernel的read方法获取数据</p></li><li><p>系统级异步：程序给一个内核级别的callback，发生事件的时候直接到callback，接收到数据。------epoll做不到。</p></li></ul><h4><span id="epoll-gong-zuo-yuan-li"> epoll工作原理：</span><a href="#epoll-gong-zuo-yuan-li" class="header-anchor">#</a></h4><p>epoll不用去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。</p><p>有<code>epoll_create(2)</code>、<code>epoll_ctl(2)</code>、<code>epoll_wait(2)</code>组成（2是系统调用）。</p><ul><li>其中<code>epoll_create</code>创建一个epoll实例，返回一个文件描述符，代表内核空间。</li><li><code>epoll_ctl</code>，将我们的client订阅关注的事件去丢到内核空间（每个client只用丢一次）</li><li><code>epoll_wait</code>去阻塞，或者超时查看发生状态变化的client的fd，拿到后去处理。</li></ul><p><strong>使用&quot;事件&quot;的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。</strong></p><p><code>man epoll</code> 看一眼帮助：</p><p>首先<code>EPOLL(7)</code>是一个杂项，由三个2类的<code>系统调用</code>组成：<code>epoll_create(2)</code>、<code>epoll_ctl(2)</code>、<code>epoll_wait(2)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">EPOLL(7)                   Linux Programmer<span class="string">'s Manual                  EPOLL(7)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       epoll - I/O event notification facility</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;sys/epoll.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       The  epoll  API performs a similar task to poll(2): monitoring multiple</span></span><br><span class="line"><span class="string">       file descriptors to see if I/O is possible on any of them.   The  epoll</span></span><br><span class="line"><span class="string">       API can be used either as an edge-triggered or a level-triggered inter‐</span></span><br><span class="line"><span class="string">       face and scales well to large numbers of watched file descriptors.  The</span></span><br><span class="line"><span class="string">       following  system  calls  are  provided  to  create and manage an epoll</span></span><br><span class="line"><span class="string">       instance:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       *  epoll_create(2) creates a new epoll  instance  and  returns  a  file</span></span><br><span class="line"><span class="string">          descriptor  referring to that instance.  (The more recent epoll_cre‐</span></span><br><span class="line"><span class="string">          ate1(2) extends the functionality of epoll_create(2).)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       *  Interest in particular  file  descriptors  is  then  registered  via</span></span><br><span class="line"><span class="string">          epoll_ctl(2).   The  set of file descriptors currently registered on</span></span><br><span class="line"><span class="string">          an epoll instance is sometimes called an epoll set.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       *  epoll_wait(2) waits for I/O events, blocking the calling  thread  if</span></span><br><span class="line"><span class="string">          no events are currently available.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Level-triggered and edge-triggered</span></span><br><span class="line"><span class="string">       The  epoll event distribution interface is able to behave both as edge-</span></span><br><span class="line"><span class="string">       triggered (ET) and as level-triggered (LT).  The difference between the</span></span><br><span class="line"><span class="string">       two mechanisms can be described as follows.  Suppose that this scenario</span></span><br><span class="line"><span class="string">       happens:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       1. The file descriptor that represents the read side of a pipe (rfd) is</span></span><br><span class="line"><span class="string">          registered on the epoll instance.</span></span><br></pre></td></tr></table></figure><h4><span id="epoll-create-xi-tong-diao-yong"> epoll_create 系统调用</span><a href="#epoll-create-xi-tong-diao-yong" class="header-anchor">#</a></h4><p>可以去<code>man 2 epoll_create</code>看一眼这个系统调用（2类）的epoll的帮助，看他的返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CREATE(2)           Linux Programmer<span class="string">'s Manual           EPOLL_CREATE(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       epoll_create, epoll_create1 - open an epoll file descriptor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;sys/epoll.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int epoll_create(int size);</span></span><br><span class="line"><span class="string">       int epoll_create1(int flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       epoll_create()  creates  a  new epoll(7) instance.  Since Linux 2.6.8,</span></span><br><span class="line"><span class="string">       the size argument is ignored, but must be greater than zero; see NOTES</span></span><br><span class="line"><span class="string">       below.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       epoll_create()  returns  a  file descriptor referring to the new epoll</span></span><br><span class="line"><span class="string">       instance.  This file descriptor is used for all the  subsequent  calls</span></span><br><span class="line"><span class="string">       to  the epoll interface.  When no longer required, the file descriptor</span></span><br><span class="line"><span class="string">       returned by epoll_create() should be closed by using  close(2).   When</span></span><br><span class="line"><span class="string">       all  file descriptors referring to an epoll instance have been closed,</span></span><br><span class="line"><span class="string">       the kernel destroys the instance and releases the associated resources</span></span><br><span class="line"><span class="string">       for reuse.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...........................</span></span><br><span class="line"><span class="string">RETURN VALUE</span></span><br><span class="line"><span class="string">       On  success,  these system calls return a nonnegative file descriptor.</span></span><br><span class="line"><span class="string">       On error, -1 is returned, and errno is set to indicate the error.</span></span><br></pre></td></tr></table></figure><p>他的返回是：<code>On success, these system calls return a nonnegative file descriptor. On error, -1 is returned, and errno is set to indicate the error.</code></p><p>这个返回是一个fd，它代表的是一个内核空间------------保存我们的客户端fd。这些客户端怎么放进去的呢？<code>epoll_ctl</code>可以往里面添加fd</p><h4><span id="epoll-ctl-zeng-shan-gai-fd-gei-dao-nei-he-kong-jian"> epoll_ctl-增删改fd给到内核空间</span><a href="#epoll-ctl-zeng-shan-gai-fd-gei-dao-nei-he-kong-jian" class="header-anchor">#</a></h4><p>一样我们看一下帮助<code>man 2 epoll_ctl</code>可以看到<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>这是一个系统调用，<code>epfd</code>可以传递客户端的fd，<code>op</code>可以传递<code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code>、<code>EPOLL_CTL_DEL</code>去增删改。一个客户端只用放一次，以后再也不用放了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_CTL(<span class="number">2</span>)              Linux Programmer<span class="number">'</span><span class="function">s Manual              <span class="title">EPOLL_CTL</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">NAME</span></span><br><span class="line">       epoll_ctl - control interface for an epoll file descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="function">This  system call performs control operations on the <span class="title">epoll</span><span class="params">(<span class="number">7</span>)</span> instance</span></span><br><span class="line">       referred to by the file descriptor epfd.  It requests that the  opera‐</span><br><span class="line">       tion op be performed <span class="keyword">for</span> the target file descriptor, fd.</span><br><span class="line"></span><br><span class="line">       Valid values <span class="keyword">for</span> the op argument are:</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_ADD</span><br><span class="line">              Register  the  target  file descriptor fd on the epoll instance</span><br><span class="line">              referred to by the file descriptor epfd <span class="keyword">and</span> associate the event</span><br><span class="line">              event with the internal file linked to fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_MOD</span><br><span class="line">              Change the event event associated with the target file descrip‐</span><br><span class="line">              tor fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_DEL</span><br><span class="line">              Remove (deregister) the target  file  descriptor  fd  from  the</span><br><span class="line">              epoll  instance  referred to by epfd.  The event is ignored <span class="keyword">and</span></span><br><span class="line">              can be NULL (but see BUGS below).</span><br></pre></td></tr></table></figure><h4><span id="epoll-wait-rang-fd-deng-dai-shi-jian"> epoll_wait-让fd等待事件</span><a href="#epoll-wait-rang-fd-deng-dai-shi-jian" class="header-anchor">#</a></h4><p>同上类似<code>man 2 epoll_wait</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">EPOLL_WAIT(<span class="number">2</span>)             Linux Programmer<span class="number">'</span><span class="function">s Manual             <span class="title">EPOLL_WAIT</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">NAME</span></span><br><span class="line">       epoll_wait,  epoll_pwait  -  wait  for  an  I/O event on an epoll file</span><br><span class="line">       descriptor</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_pwait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="function">The <span class="title">epoll_wait</span><span class="params">()</span> system call waits <span class="keyword">for</span> events on the <span class="title">epoll</span><span class="params">(<span class="number">7</span>)</span> instance</span></span><br><span class="line">       referred  to  by the file descriptor epfd.  The memory area pointed to</span><br><span class="line">       by events will contain the events that will be <span class="built_in">available</span> <span class="keyword">for</span> the call‐</span><br><span class="line">       er.   Up  to  maxevents  are  returned by epoll_wait().  The maxevents</span><br><span class="line">       argument must be greater than zero.</span><br><span class="line"></span><br><span class="line">       The  timeout  argument  specifies  the  number  of  milliseconds  that</span><br><span class="line">       epoll_wait() will block.  Time is measured against the CLOCK_MONOTONIC</span><br><span class="line">       clock.  The call will block until either:</span><br><span class="line"></span><br><span class="line">       *  a file descriptor delivers an event;</span><br><span class="line"></span><br><span class="line">       *  the call is interrupted by a signal handler; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">       *  the timeout expires.</span><br><span class="line"></span><br><span class="line">       Note that the timeout interval will be rounded up to the system  clock</span><br><span class="line">       granularity,  <span class="keyword">and</span>  kernel  scheduling  delays  mean  that the blocking</span><br><span class="line">       interval may overrun by a small amount.  Specifying a  timeout  of  <span class="number">-1</span></span><br><span class="line">       causes  epoll_wait() to block indefinitely, while specifying a timeout</span><br><span class="line">       equal to zero cause epoll_wait() to return  immediately,  even  if  no</span><br><span class="line">       events are <span class="built_in">available</span>.</span><br></pre></td></tr></table></figure><h4><span id="epoll-gong-zuo-liu-cheng"> epoll工作流程</span><a href="#epoll-gong-zuo-liu-cheng" class="header-anchor">#</a></h4><p><strong>【Epoll】</strong>：假设10w个客户端fd</p><ul><li>任何服务想要启动监听接受请求，需要进行以下步骤</li><li>1.调用kernel启动一个socket的文件描述符，假设叫fd3，监听</li><li>2.调用<code>epoll_create</code>,创建epoll实例，会在内核中开辟空间假设fd6。</li><li>3.调用<code>epoll_ctl(fd6, ADD , fd3, event_accept)</code>,把socket fd3加入内核空间fd6中，同时监听accept事件。</li><li>4.调用<code>epoll_wait(fd6,res)</code>,等待fd6中的所有fd返回，阻塞，也可以可以超时。传递一个res是接受返回的内存空间。</li><li>假设上面<code>epoll_wait</code>的时候，一个C1来了三次握手，制造事件中断。CPU回调，知道来了一个客户端，就把这个fd放到fd3上。fd3就放到上面给的res。（accept）</li><li>5.<code>epoll_wait</code>从res看到有fd3的accept了，把这个fd3给到程序去执行accept(fd3)，得到一个fd8.这时候fd8就代表下面的C1客户端了。</li><li>6.调用<code>epoll_ctl(fd6, ADD , fd8, event_read)</code>,把客户端fd8加入内核空间fd6中，同时监听read事件。（以后就不用监听了）</li><li>7.程序循环调用<code>epoll_wait(fd6,res)</code>,等待fd6中的所有fd返回，阻塞，也可以可以超时。传递一个res是接受返回的内存空间。拿出res里面的fd和事件去处理。</li><li>这时候C2如果来了，fd6里面监听了accept和read，都会触发中断。CPU会把fd3和fd8都放到res，注明有一个连接来了俩event。</li><li>这时候epoll_wait会返回两个fd，fd3里面的event拿出来会得到一个新的client，命名fd9，来代表C2.</li><li>然后把fd9也调用<code>epoll_ctl(fd6, ADD , fd9, event_read)</code>加进去，内核就多监听一个中断事件。</li></ul><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200611022733785.png" alt="image-20200611022733785"></p><p>多而两个系统调用</p><p>epoll空间开辟早期的时候用mmap（程序和内核都可以访问），后来系统调用不用这个实现了，因为多线程的时候mmap有点问题。</p><p>上层开辟线程，传递数据的时候还是用的mmap。内存直接访问。</p><p><strong>【优势】</strong>：压榨硬件资源到极致，规避了客户端fd的频繁拷贝。事件驱动。</p><p>【缺点】：epoll只完成了event的通知，需要拿到数据的时候还是需要去同步调用read。（可以非阻塞调用read，但是还是程序需要主动调用read，不会直接给到）</p><p>epoll不一定是最快的，根据client的特点？</p><p>也就是网卡把数据放到DMA区域，内核通过中断只知道DMA有数据，有事件。kernel知道是什么时间类型，会通过epoll_wait的res告诉程序，但是不会直接把消息读取出来。还是需要应用app去调用kernel的read（阻塞或者非阻塞）去拿回数据。</p><p>思想：事件到达了，会有event告诉内核。</p><p>​</p><h2><span id="select-poll-he-epoll-de-dui-bi"> select/poll和epoll的对比</span><a href="#select-poll-he-epoll-de-dui-bi" class="header-anchor">#</a></h2><p>select和poll是一类         epoll是另一类</p><table><thead><tr><th></th><th>支持一个进程所能打开的最大连接数</th><th>FD剧增后带来的IO效率问题</th><th>消息传递方式</th></tr></thead><tbody><tr><td><strong>select</strong></td><td>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</td><td>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</td><td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td></tr><tr><td><strong>poll</strong></td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td><td>同上</td><td>同上</td></tr><tr><td><strong>epoll</strong></td><td>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</td><td>epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</td><td>epoll通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><h1><span id="aio"> AIO</span><a href="#aio" class="header-anchor">#</a></h1><p>aio  on linux比较费劲，因为linux希望更多的CPU运行在用户空间，内核空间保证安全。</p><p>如果AIO如何搞定系统级别异步？linux  kernel去执行应用定义的callback？在哪里启动callback的线程？这个callback在哪里执行？kernel执行的话安全性？</p><h1><span id="tcp-ji-chu"> TCP基础</span><a href="#tcp-ji-chu" class="header-anchor">#</a></h1><h2><span id="osi-ji-chu-mo-xing"> OSI基础模型</span><a href="#osi-ji-chu-mo-xing" class="header-anchor">#</a></h2><p>提到IO，首先是OSI参考模型，计算机网络基础，一共七层</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521180941467.png" alt="image-20200521180941467"></p><p>这7层是一个虚的东西，是一个规范。TCP/IP协议给精简到4层，把上面的<code>应用层-表示层-会话层</code>统一归结到新的<code>应用层</code>是<code>用户称</code>，把下面<code>的传输控制层-网络层-链路层-物理层</code>视为<code>内核层</code>。</p><table><thead><tr><th>OSI七层网络模型</th><th>TCP/IP四层概念模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层（Application）</td><td>应</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td>表示层（Presentation）</td><td>用</td><td>Telnet, Rlogin, SNMP, Gopher</td></tr><tr><td>会话层（Session）</td><td>层</td><td>SMTP, DNS</td></tr><tr><td>传输层（Transport）</td><td>传输层</td><td>TCP, UDP</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP, ICMP, ARP, RARP, AKP, UUCP</td></tr><tr><td>数据链路层（Data Link）</td><td>数据</td><td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td></tr><tr><td>物理层（Physical）</td><td>链路层</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802.11</td></tr></tbody></table><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521181257025.png" alt="image-20200521181257025"></p><h2><span id="linux-ming-ling-ce-shi-jiang-jie-tcp"> linux命令测试讲解TCP</span><a href="#linux-ming-ling-ce-shi-jiang-jie-tcp" class="header-anchor">#</a></h2><h3><span id="chuang-jian-yi-ge-dao-baidu-de-wen-jian-miao-shu-fu-nei-he-ceng"> 创建一个到baidu的文件描述符（内核层）</span><a href="#chuang-jian-yi-ge-dao-baidu-de-wen-jian-miao-shu-fu-nei-he-ceng" class="header-anchor">#</a></h3><ul><li>linux一切皆文件，每一个程序都有自己的IO流。程序里面的IO流也会被描述成文件（数字）。没一个程序都有3个自带的文件描述符：<ul><li>0：<a href="http://system.in" target="_blank" rel="noopener">system.in</a></li><li>1:   system.out</li><li>2:   system.err</li><li>用户创建的IO就从3开始</li></ul></li></ul><p>**【举例】**执行一个bash命令创建一个到baidu的socket，IO流重定向到当前进程的8号文件描述符中：</p><ul><li><p><code>exec 8&lt;&gt; /dev/tcp/www.baidu.com/80</code></p></li><li><p>上面面创建了一个文件描述符“8”，是一个socket指向了百度，</p></li><li><p>8是文件描述符fd(就像代码的变量)，&lt;&gt;是一个双向输入输出流，可以看到</p></li><li><pre class="highlight"><code class="bash"><span class="hljs-built_in">echo</span> $$  <span class="hljs-comment"># 打印当前命令行的进程号</span>16199<span class="hljs-comment"># 也可以ps -ef 然后grep出来</span>tree     16199  9368  0 4月15 pts/1   00:00:01 /bin/bash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 可以去当前进程的目录看一眼</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;bash</span><br><span class="line">  cd &#x2F;proc&#x2F;16199&#x2F;fd # 进入当前进程的fd目录</span><br><span class="line">  ls # 看一眼</span><br><span class="line">  lrwx------ 1 tree tree 64 5月  21 18:31 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">  lrwx------ 1 tree tree 64 5月  21 18:31 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">  lrwx------ 1 tree tree 64 5月  21 18:31 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">  lrwx------ 1 tree tree 64 5月  21 18:31 255 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">  lrwx------ 1 tree tree 64 5月  21 18:31 8 -&gt; &#39;socket:[1037956]&#39;</span><br><span class="line">  # 每个进程都有0,1,2三个fd文件描述符。分别是stdin、stdout、stderr</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3><span id="xiang-wen-jian-miao-shu-fu-zhong-xie-dong-xi-tong-xin-yong-hu-ceng-tai"> 向文件描述符中写东西通信（用户层态）</span><a href="#xiang-wen-jian-miao-shu-fu-zhong-xie-dong-xi-tong-xin-yong-hu-ceng-tai" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"GET / HTTP/1.0\n"</span> 1&gt;&amp; 8  </span><br><span class="line"><span class="comment"># 打印一个字符串到标准输出（所以是1）重定向&gt;到文件描述符(所以是&amp;，重定向到文件不用&amp;)8中</span></span><br><span class="line"></span><br><span class="line">cat 0&lt;&amp; 8</span><br><span class="line"><span class="comment"># 从文件描述符(所以是&amp;，文件的话不用&amp;)8中标准输入&lt;</span></span><br><span class="line"><span class="comment"># 。。。。。下面打印一大堆百度的html</span></span><br></pre></td></tr></table></figure><h2><span id="chuan-shu-kong-zhi-ceng-tcp-xie-yi"> 传输控制层TCP协议</span><a href="#chuan-shu-kong-zhi-ceng-tcp-xie-yi" class="header-anchor">#</a></h2><p>TCP和UDP是传输控制层协议。</p><h4><span id="shi-me-shi-socket-tao-jie-zi"> 什么是socket套接字？</span><a href="#shi-me-shi-socket-tao-jie-zi" class="header-anchor">#</a></h4><ul><li><p><code>ip+port &lt;---------&gt; ip+port</code> 是一【套】，客户端和服务端的ip+port 4个要素决定唯一的一个socket</p></li><li><p>客户端的ip是B，可以和baidu建立多少个链接？65535个</p></li><li><p>此时客户端B还能继续和163建立链接吗？也可以继续再次建立65535个，因为socket是【一套】4个要素，server换了就是另外一个socket了。</p></li><li><p>对于类似如下<code>netstat -anp</code>出来的socket链接，每一个<code>established</code>都有一个文件描述符(fd目录下)数字和他对应并交给一个进程。程序只用和这个文件描述符进行读写就可以进行socket通信了。<strong>【如果多个socket对应一个进程：就是多路复用器selector或者epoll】</strong></p><p>下面的<code>192.168.150.12:22</code>建立了两个到<code>192.168.150.1</code>的<code>socket</code>：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521191000694.png" alt="image-20200521191000694"></p></li></ul><h3><span id="shi-me-shi-tcp-xie-yi"> 什么是TCP协议？</span><a href="#shi-me-shi-tcp-xie-yi" class="header-anchor">#</a></h3><p>是一个<strong>面向连接</strong>的<strong>可靠的</strong>传输协议。因为三次握手保证了可靠传输。</p><p><strong>连接</strong>：不是物理连接，是三次握手实现的逻辑连接，完成双向确认。</p><p>为啥<strong>可靠</strong>：通信前三次握手双方分配资源，为未来的通讯做好了准备。所有数据包发送的时候有个确认机制保证了可靠。</p><p><strong>DDOS</strong>：发握手包，但是不回。造成服务器有一大堆接受TCP的等待队列。使得真正想进来的连接进不来。</p><h3><span id="san-ci-wo-shou-de-xi-jie"> 三次握手的细节？</span><a href="#san-ci-wo-shou-de-xi-jie" class="header-anchor">#</a></h3><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521185513169.png" alt="image-20200521185513169"></p><p>C-----------syn-----------&gt;S   # “我要跟你连接了，标识是syn”</p><p>C&lt;----------syn+ack-------S # “好的，我知道了” 让客户端知道Server已经响应了</p><p>C------------ack-----------&gt;S # 好的，我知道你知道了。让Server知道发出的消息客户端收到了</p><p>然后双方开始开辟资源（内存，结构体，线程），建立连接。</p><h3><span id="shui-hong-fa-san-ci-wo-shou-mu-de"> 谁触发三次握手？目的？</span><a href="#shui-hong-fa-san-ci-wo-shou-mu-de" class="header-anchor">#</a></h3><p>应用层的程序先告诉内核，我要和一个地址建立连接。内核去尝试三次握手。</p><p>三次握手成功后会在双方服务器开辟资源（线程、内存结构体等等）来为对方提供响应服务。</p><p>三次握手完毕后，双方才有资源开辟，才能开始传输。</p><h3><span id="tcpdump-cha-kan-san-ci-wo-shou"> tcpdump 查看三次握手</span><a href="#tcpdump-cha-kan-san-ci-wo-shou" class="header-anchor">#</a></h3><p><code>tcpdump</code>   -nn 显示ip断开   -i 显示哪个网卡接口 port 显示哪个端口</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521194049682.png" alt="image-20200521194049682"></p><h3><span id="si-ci-fen-shou-de-xi-jie-wei-sha-yao-si-ci"> 四次分手的细节，为啥要四次？</span><a href="#si-ci-fen-shou-de-xi-jie-wei-sha-yao-si-ci" class="header-anchor">#</a></h3><p>因为握手是三次，开辟了资源。<strong>分手是双方一起释放资源，对对方有义务的</strong>，所以是四次（双方都要同时释放，不能轻易单方面释放了）</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200521192102157.png" alt="image-20200521192102157"></p><p>分手的C只是先说断开的人</p><p>C-----------fin-----------&gt;S   # “我要跟你分手了，标识是fin”给Server一个结束标识</p><p>C&lt;----------fin+ack-------S # “好的，我知道了” 让客户端知道Server已经响应了（但是我要确认一下真的没事儿了）</p><p>C&lt;-----------fin------------S   # “好吧，分吧，标识是fin”确认真的没事儿了，给客户端一个结束标识</p><p>C------------ack-----------&gt;S #  “好的，”让Server知道发出的消息客户端收到了</p><p>然后双方把给对方准备的资源都释放了。</p><h3><span id="san-ci-wo-shou-he-si-ci-fen-shou-shi-bu-ke-fen-ge-de-zui-xiao-li-du"> 三次握手和四次分手是不可分割的最小粒度</span><a href="#san-ci-wo-shou-he-si-ci-fen-shou-shi-bu-ke-fen-ge-de-zui-xiao-li-du" class="header-anchor">#</a></h3><ul><li><p>LVS作为一个工作在四层的负载均衡，是无法知晓数据包的具体内容的！</p></li><li><p>LVS是否可以随意把数据给后端进行负载？-可以负载，但是受制于协议约束！</p><ul><li>C  ----- lvs   ----- S1/S2 的时候，LVS必须要把握手的三次给到一对C—S，不能给到另外一个S，否则无法建立连接。</li></ul></li></ul><h2><span id="wang-luo-he-lu-you"> 网络和路由</span><a href="#wang-luo-he-lu-you" class="header-anchor">#</a></h2><p>上面的TCP协议只管<strong>传输和控制</strong>，也就是发什么内容，怎么发。但是发送的路径不管，是下层寻址ARP协议管理的。</p><p>网络设置要<code>ip</code>、<code>gateway</code>、<code>mask</code>、<code>dns</code>4个东西</p><ul><li>如果几个设备ip：<code>192.168.1.10</code>、<code>192.168.1.11</code>，他们只要成功联网，肯定知道他们的下一跳路由器地址（静态或者DHCP），如<code>192.168.1.1</code></li><li>客户端向发送一个ARP广播包，带着路由器的ip和全<code>FFFFFFFFFF</code>的mac地址，路由器收到后看到是自己的ip，就把自己的mac地址返回给客户机。</li><li>然后客户端才知道路由器的mac，包装后就能往百度发了三次握手的包了。</li><li>通过路由表往下一跳发</li></ul><p>【测试】``</p><p>下面会先去请求ARP，收到路由器返回mac后，包装三次握手的包发出去。最后四次分手。</p><p>每次发送的包和接受的包都有一个seq和seq+1的关系，保证了不会错乱。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200610234329384.png" alt="image-20200610234329384"></p><h1><span id="qi-ta"> 其他：</span><a href="#qi-ta" class="header-anchor">#</a></h1><h2><span id="guan-yu-directbuffer"> 关于DirectBuffer</span><a href="#guan-yu-directbuffer" class="header-anchor">#</a></h2><p>每个进程都有堆内存，JVM是C写的，启动的时候有堆空间。我们可以堆外分配空间直接给JVM访问。这个堆外空间除了内核共享，还可以接到磁盘文件上。</p><p>RandomAccessFile里面有<code>direct</code>分配空间和<code>map(4096)</code>：可以使用RandomAccessFile打开文件，对着这个文件对象调用map。JVM就有堆外空间接到磁盘上了。map返回一个buffer，JVM直接把文件存到磁盘上了。不用调用kernel的write，减少一次<code>系统调用</code>。</p><h2><span id="mmap"> mmap</span><a href="#mmap" class="header-anchor">#</a></h2><p>内核和应用共同访问的共享内存。mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。这样直接对内存的读写就完成了之前的系统调用<code>read</code>、<code>write</code>，速度更快，<strong>而且内核空间也可以对这个文件直接修改，可以完成进程间文件共享</strong>。</p><p>mongoDB （3.0以前版本） 、rocketMQ 都用到了 mmap</p><blockquote><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p></blockquote><h2><span id="kafka-de-io-you-hua"> Kafka的IO优化？</span><a href="#kafka-de-io-you-hua" class="header-anchor">#</a></h2><p>kafka是基于JVM的消息队列，读取消息的时候Client到Kernel调用系统调用<code>read</code>，再到kafka去解析。kafka优化对这个文件开启mmap映射，写文件的时候就像写buffer一样，越过系统调用直接落到磁盘。少了一次write系统调用。</p><p>kafka启动的时候有一个segment01段文件，就是mmap开辟的内存映射的大小，默认1G。对这1G的内存哪个位置放了，就会出现在文件的哪个位置。</p><p>segment把1G文件填满之后移动，再创建一个segment，再mmap一下得到第二个文件。</p><p>读：正常是程序调动kernel，kernel去读取文件到文件偏移量，拷贝到用户空间。用户空间把数据再发出去的时候又要调用kernel，多copy了一次。</p><p><strong>如果数据是不需要kafka再加工的</strong>，就可以触发<strong>零拷贝</strong>：</p><p>程序调用sendfile，把输入输出的fd传进去，sendfile是在内核里实现的，所以直接零拷贝了。</p><p><code>man 2 sendfile</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">SENDFILE(<span class="number">2</span>)               Linux Programmer<span class="number">'</span><span class="function">s Manual               <span class="title">SENDFILE</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">NAME</span></span><br><span class="line">       sendfile - transfer data between file descriptors</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       sendfile()  copies  data  between  one  file  descriptor  <span class="keyword">and</span> another.</span><br><span class="line">       Because <span class="keyword">this</span> copying is done within the  kernel,  sendfile()  is  more</span><br><span class="line">       efficient  than  the  combination of read(2) and write(2), which would</span><br><span class="line">       require transferring data to <span class="keyword">and</span> from user space.</span><br><span class="line"></span><br><span class="line">       in_fd should be a file descriptor opened <span class="keyword">for</span> reading <span class="keyword">and</span> out_fd should</span><br><span class="line">       be a descriptor opened <span class="keyword">for</span> writing.</span><br><span class="line"></span><br><span class="line">       If  offset  is <span class="keyword">not</span> <span class="literal">NULL</span>, then it points to a variable holding the file</span><br><span class="line">       offset from which sendfile() will start reading data from in_fd.  When</span><br><span class="line">       sendfile()  returns,  <span class="keyword">this</span>  variable  will be <span class="built_in">set</span> to the offset of the</span><br><span class="line">       <span class="keyword">byte</span> following the last <span class="keyword">byte</span> that was <span class="built_in">read</span>.  If offset  is  <span class="keyword">not</span>  <span class="literal">NULL</span>,</span><br><span class="line">       <span class="function">then  <span class="title">sendfile</span><span class="params">()</span>  does  <span class="keyword">not</span> modify the file offset of in_fd</span>; otherwise</span><br><span class="line">       the file offset is adjusted to reflect the number of bytes  <span class="built_in">read</span>  from</span><br><span class="line">       in_fd.</span><br><span class="line"></span><br><span class="line">       If  offset  is <span class="literal">NULL</span>, then data will be <span class="built_in">read</span> from in_fd starting at the</span><br><span class="line">       file offset, <span class="keyword">and</span> the file offset will be updated by the call.</span><br><span class="line"></span><br><span class="line">       count is the number of bytes to copy between the file descriptors.</span><br><span class="line"></span><br><span class="line">       The  in_fd  argument  must  correspond  to  a  file   which   supports</span><br><span class="line">       mmap(2)-like operations (i.e., it cannot be a socket).</span><br><span class="line"></span><br><span class="line">       In  Linux kernels before <span class="number">2.6</span><span class="number">.33</span>, out_fd must refer to a socket.  Since</span><br><span class="line">       Linux <span class="number">2.6</span><span class="number">.33</span> it can be any file.  If it is a regular file, then  send‐</span><br><span class="line">       file() changes the file offset appropriately.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       If  the <span class="built_in">transfer</span> was successful, the number of bytes written to out_fd</span><br><span class="line">       is returned.  <span class="function">Note that a successful  call  to  <span class="title">sendfile</span><span class="params">()</span>  may  <span class="built_in">write</span></span></span><br><span class="line"><span class="function">       fewer bytes than requested</span>; the caller should be prepared to retry the</span><br><span class="line">       call <span class="keyword">if</span> there were unsent bytes.  See also NOTES.</span><br></pre></td></tr></table></figure><p>所以kafka用到mmap、零拷贝、epoll，性能高。redis底层也是epoll.</p><p>nginx也是epoll，还有sendfile的零拷贝，配置文件里面就有sendfile。</p><p>参考资料</p><blockquote><p><a href="https://www.cnblogs.com/jjzd/p/6540148.html" target="_blank" rel="noopener">https://www.cnblogs.com/jjzd/p/6540148.html</a></p><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--toc--&gt;
&lt;h1&gt;&lt;span id=&quot;ji-suan-ji-zu-cheng-yuan-li&quot;&gt; 计算机组成原理&lt;/span&gt;&lt;a href=&quot;#ji-suan-ji-zu-cheng-yuan-li&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="IO" scheme="https://blog.sofunnyai.com/categories/IO/"/>
    
    
      <category term="网络" scheme="https://blog.sofunnyai.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="基础" scheme="https://blog.sofunnyai.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一文讲透springboot的入门、原理</title>
    <link href="https://blog.sofunnyai.com/article/springboot.html"/>
    <id>https://blog.sofunnyai.com/article/springboot.html</id>
    <published>2018-09-11T08:17:53.000Z</published>
    <updated>2020-08-04T10:19:39.596Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#springboot-ru-men">Springboot入门</a><ul><li><a href="#bei-jing">背景</a></li><li><a href="#yan-jin-guo-cheng">演进过程：</a></li><li><a href="#kuai-su-kai-shi">快速开始</a></li><li><a href="#springbootstarter">SpringbootStarter</a></li></ul></li><li><a href="#springboot-qi-dong-liu-cheng">SpringBoot启动流程</a><ul><li><a href="#springapplication-lei">SpringApplication类</a></li></ul><ul><li><a href="#bei-jing">背景：</a></li><li><a href="#import-zhu-jie-de-shi-yong">Import注解的使用</a><ul><li><a href="#zhi-jie-zai-import-zhong-lie-ju-xu-yao-dao-ru-de-lei">直接在Import中列举需要导入的类</a></li><li><a href="#dao-ru-importselector-lei">导入ImportSelector类</a></li><li><a href="#dao-ru-importbeandefinitionregistrar">导入ImportBeanDefinitionRegistrar</a></li></ul></li><li><a href="#qi-dong-liu-cheng">启动流程</a></li><li><a href="#gong-ju-fang-fa">工具方法</a><ul><li><a href="#gong-ju-fang-fa-getspringfactoriesinstances">工具方法<code>getSpringFactoriesInstances</code></a></li><li><a href="#duo-bo-qi-fa-bu-shi-jian">多拨器发布事件</a></li></ul></li><li><a href="#preparecontext">prepareContext：</a></li><li><a href="#fu-lu">附录</a><ul><li><a href="#spring-boot-2-3-1-release-jar-meta-inf-spring-factories">spring-boot-2.3.1.RELEASE.jar # META-INF/spring.factories</a></li><li><a href="#spring-boot-autoconfigure-2-3-1-release-jar-spring-factories">spring-boot-autoconfigure-2.3.1.RELEASE.jar#spring.factories</a></li><li><a href="#spring-beans-5-2-7-release-jar-spring-factories">spring-beans-5.2.7.RELEASE.jar#spring.factories</a></li></ul></li></ul></li><li><a href="#springboot-zi-dong-zhuang-pei-yuan-li">SpringBoot自动装配原理</a><ul><li><a href="#qi-dong-guo-cheng">启动过程：</a></li><li><a href="#he-xin-pei-zhi-zhu-qi-dong-lei-springbootapplication">核心配置主启动类 @SpringBootApplication</a></li><li><a href="#springbootconfiguration">@SpringBootConfiguration</a></li><li><a href="#enableautoconfiguration">@EnableAutoConfiguration</a></li><li><a href="#autoconfigurationpackage">@AutoConfigurationPackage</a></li><li><a href="#configuration">@Configuration</a></li></ul></li><li><a href="#springboot-jing-dian-wen-ti">SpringBoot经典问题</a></li></ul><!-- tocstop --></div><h1><span id="springboot-ru-men"> Springboot入门</span><a href="#springboot-ru-men" class="header-anchor">#</a></h1><h2><span id="bei-jing"> 背景</span><a href="#bei-jing" class="header-anchor">#</a></h2><h2><span id="yan-jin-guo-cheng"> 演进过程：</span><a href="#yan-jin-guo-cheng" class="header-anchor">#</a></h2><ul><li><p>传统web开发（servlet2.5以下），web项目必须要一个<code>web.xml</code>，里面配置</p><ul><li><p><code>&lt;listener&gt;</code>：配置一个在web容器启动时可以执行的类（如<code>ContextLoadListener</code>去初始化spring，需要制定参数去加载类似<code>applicatoinContext.xml</code>文件，扫描业务service、dao，或者<code>&lt;bean&gt;</code>单个定义）</p></li><li><p>在<code>ContextLoadListener</code>参数中要去指定加载的配置文件，如<code>applicationContext.xml</code>，里面通过<code>&lt;bean&gt;</code>去指定对象装配注入，或通过<componentscan>去批量扫描业务类</componentscan></p></li><li><p><code>&lt;servlet&gt;</code>、<code>&lt;servlet-mapping&gt;</code>：配置web容器从接管的请求处理类和对应请求映射规则（<code>DispatherServlet</code>去接管请求到springMVC），参数扫描<code>springMvc.xml</code>去批量扫描<code>Controller</code>，配置产生<code>HttpMessageConverter</code>、<code>ViewResovler</code>。</p></li><li><p><code>&lt;filter&gt;</code>、<code>&lt;filter-mapping&gt;</code>：配置对请求的过滤类和映射规则</p></li></ul></li><li><p>以上配置繁琐，第二种方式：</p><ul><li>@WebServlet(urlmapping)、</li></ul></li><li><p>第三种，JavaConfig方式：</p></li><li><p>spring使用servlet3.1的SPI机制，在<code>META-INF/services/javax.servlet.ServletContainerInitializer</code>下面的文件里面配置了Spring的initial类，是ServletApi的一个实现。web容器启动会去执行他，这个Spring的初始化器又会找到所有<code>WebApplicationInitializer</code>接口实现，挨着执行OnStartup（委托代理）</p></li></ul><p>springboot是建立在spring framework上的。传统我们的spring framework最开始是<code>xml-based</code>，然后<code>annotation-based</code>，最后<code>javaconfig-based</code>。</p><h2><span id="kuai-su-kai-shi"> 快速开始</span><a href="#kuai-su-kai-shi" class="header-anchor">#</a></h2><ul><li>新建一个maven项目，然后去<code>spring.io</code>的<code>https://spring.io/quickstart</code>官方会指引到<code>https://start.spring.io</code>选择springboot版本，即可生成pom文件甚至Java基础启动文件。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200711162055034.png" alt="image-20200711162055034"></p><p>点击下方<code>EXPLORECTRL + SPACE</code>会给你展示生成的项目结构和pom文件预览。点击<code>GENERATECTRL + ⏎</code>则会下载一个生成的zip包。</p><p>一般我们选用前者，我们在右边添加了<code>web（springboot-web）</code>、<code>lombok</code>后，copy一段生成的pom.xml即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里是依赖了一个springboot的父项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sam<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bootdemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>bootdemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看起来只有很简单的<code>web-starter</code>、<code>lombok</code>甚至连版本号都没有指定，但其实有很核心的一个父项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的项目点进去可以发现他又依赖于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- t同时约定了配置文件的名称和目录--&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个再点进<code>spring-boot-dependencies</code>去可以看到一大堆默认的约定配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.12<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.80<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.10.11<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caffeine.version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">caffeine.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cassandra-driver.version</span>&gt;</span>4.6.1<span class="tag">&lt;/<span class="name">cassandra-driver.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classmate.version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">classmate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.14<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.10<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ....... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，我们的springboot为何能自动选择合适的版本去启动原因就在这里，父项目默认为我们选择好了合适的集成版本。之后导入项目依赖，默认是不用写版本的，除非在<code>spring-boot-dependencies</code>中不包含的项目。</p><p>也就是SpringBoot将常用的场景抽取出来作为starter启动器，使用组件的时候直接引用这些starter即可。</p><h2><span id="springbootstarter"> SpringbootStarter</span><a href="#springbootstarter" class="header-anchor">#</a></h2><p>sprinbboot的场景启动器，如<code>springboot-starter-web</code>点击进去：</p><p>可以看到他依赖了一些默认的web项目所需的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- boot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--tomcat--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--web,以来了beans和core--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- springMVC，里面依赖了beans、context、core、aop、expression --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1><span id="springboot-qi-dong-liu-cheng"> SpringBoot启动流程</span><a href="#springboot-qi-dong-liu-cheng" class="header-anchor">#</a></h1><p>Spring主要关注：</p><ul><li><p>IOC容器创建过程</p></li><li><p>Bean实例化过程，生命周期</p></li><li><p>循环依赖解决</p></li><li><p>AOP</p></li><li><p>事件发布和监听</p></li></ul><h3><span id="springapplication-lei"> SpringApplication类</span><a href="#springapplication-lei" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常我们使用上面几行看起来巨简单的代码，就一个注解 + 一行<code>SpringApplication.run(当前类.class)</code>，通过这个<code>run</code>方法入口。</p><p>我们调用的<code>SpringApplication.run</code>先看看这个类是个啥，注释告诉我们：</p><ul><li>这是用来启动SpringApplication的一个类，默认以下步骤：<ul><li>根据环境不同，创建合适的<code>ApplicationContext</code>（）</li><li>注册一个<code>CommandLinePropertySource</code>命令行的参数解析器，来解析我们的命令行参数暴露到spring中</li><li><strong>刷新</strong>我们第一步的<code>ApplicationContext</code>，并创建加载所有的单例对象</li><li>触发所有的<code>CommandLineRunner</code></li></ul></li><li>这个类可以从各种来源读取bean，建议使用<code>@Configuration</code>类来启动我们的应用，也就是AnnotatedBeanDefinitionReader。（其他的还有XmlBeanDefinitionReader、GroovyBeanDefinitionReader）</li><li><code>ClassPathBeanDefinitionScanner</code>会去扫描我们制定的包</li></ul><p>我们看看这个启动流程。</p><h2><span id="bei-jing"> 背景：</span><a href="#bei-jing" class="header-anchor">#</a></h2><p>springboot有很多Listener，会发布一系列事件：</p><ul><li>ApplicationStartingEvent</li><li>ApplicationEnvironmentPreparedEvent</li><li>ApplicationStartedEvent</li><li>ApplicationReadyEvent</li></ul><h2><span id="import-zhu-jie-de-shi-yong"> Import注解的使用</span><a href="#import-zhu-jie-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="zhi-jie-zai-import-zhong-lie-ju-xu-yao-dao-ru-de-lei"> 直接在Import中列举需要导入的类</span><a href="#zhi-jie-zai-import-zhong-lie-ju-xu-yao-dao-ru-de-lei" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;A<span class="class">.<span class="keyword">class</span>, <span class="title">B</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">XXXConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="dao-ru-importselector-lei"> 导入ImportSelector类</span><a href="#dao-ru-importselector-lei" class="header-anchor">#</a></h3><p><code>@Configuration + @Import(ImportSelectorXXXImpl.class</code> 即可实现动态导入、动态插拔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先看一个接口ImportSelector，我们一般要导入的是这个接口的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回需要导入的类名。参数importingClassMetadata给传入了注解的信息，可以根据注解信息在逻辑里面动态导入</span></span><br><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除的exclude逻辑</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;String&gt; <span class="title">getExclusionFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现动态插拔例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承的SessionConfigurationImportSelector其实就是一个 ImportSelector，里面根据WebApplicationType返回不同的类名数组而已</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyXXXConfigurationImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">            <span class="comment">// 根据 importingClassMetadata里面的信息：被修饰的类名、方法名、其他注解的信息，来动态返回一个字符串数组</span></span><br><span class="line">            <span class="comment">// 也可以去拿到BF中的bean定义、env等信息来决定返回哪些</span></span><br><span class="line">            <span class="keyword">if</span>(xxxxx)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;com.xxx.XXXXService, com.xxx.YYYYService&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;com.xxx.XXXXService&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@YYYConfig</span>(yyyyy)</span><br><span class="line"><span class="meta">@Import</span>(MyXXXConfigurationImportSelector<span class="class">.<span class="keyword">class</span>) // <span class="title">MyXXXConfigurationImportSelector</span>中就可以根据<span class="title">YYYConfig</span>的信息、当前类的信息、<span class="title">BF</span>、<span class="title">env</span>信息决定导入哪些</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">XXXConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="dao-ru-importbeandefinitionregistrar"> 导入ImportBeanDefinitionRegistrar</span><a href="#dao-ru-importbeandefinitionregistrar" class="header-anchor">#</a></h3><p>自己手动包装一个BeanDefinition，注册到registry里面，同时给一BeanName</p><p>相当与给BF开后门，直接生成bd并注入进去，还可以修改bd信息。（用来做代理、 FactoryBean的实现等等，如mapper实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment"> * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment"> * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class processing.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation delegates to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importBeanNameGenerator the bean name generator strategy for imported beans:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurationClassPostProcessor#IMPORT_BEAN_NAME_GENERATOR&#125; by default, or a</span></span><br><span class="line"><span class="comment"> * user-provided one if &#123;<span class="doctag">@link</span> ConfigurationClassPostProcessor#setBeanNameGenerator&#125;</span></span><br><span class="line"><span class="comment"> * has been set. In the latter case, the passed-in strategy will be the same used for</span></span><br><span class="line"><span class="comment"> * component scanning in the containing application context (otherwise, the default</span></span><br><span class="line"><span class="comment"> * component-scan naming strategy is &#123;<span class="doctag">@link</span> AnnotationBeanNameGenerator#INSTANCE&#125;).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 重载注册Bean定义，有默认实现</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanNameGenerator importBeanNameGenerator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">registerBeanDefinitions(importingClassMetadata, registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register bean definitions as necessary based on the given annotation metadata of</span></span><br><span class="line"><span class="comment"> * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span></span><br><span class="line"><span class="comment"> * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * class processing.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry current bean definition registry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 注册类定义,默认为空，啥都没干，子类要实现</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="dian-xing-ying-yong-aop"> 典型应用AOP：</span><a href="#dian-xing-ying-yong-aop" class="header-anchor">#</a></h4><p>(或者Mybatis的Mapper代理生成并注入到BF也是<code>ImportBeanDefinitionRegistrar</code>实现的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment"> * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 重写了2个参数的注册方法，拿到register，自己创建RootBeanDefinition，往里面添加注册。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// registry.registerBeanDefinition("internalAutoProxyCreator", new RootBeanDefinition(cls));</span></span><br><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;  <span class="comment">// 强制CGLib代理，去注册一个CGLib的</span></span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;   <span class="comment">// 暴露ThreadLocal的AOPContext</span></span><br><span class="line">AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式，再定义一个AOP注解<code>@EnableAspectJAutoProxy</code>来导入刚才的<code>ImportBeanDefinitionRegistrar实现</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入上面的AspectJAutoProxyRegistrar</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment"> * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 是否强制代理，默认false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment"> * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment"> * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// proxy是否通过ThreadLocal暴露到AopContext中</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用，在<code>AopAutoConfiguration</code>这个配置类中有以下内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(Advice<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">class</span> <span class="title">AspectJAutoProxyingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>) <span class="comment">// 这里的false传递给了里面的BDRRegistry，会动态生成不同的Bean定义</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>, matchIfMissing = <span class="keyword">false</span>) </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line">                     <span class="comment">// JDK动态代理spring.aop.proxy-target-class=false的时候才会触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="qi-dong-liu-cheng"> 启动流程</span><a href="#qi-dong-liu-cheng" class="header-anchor">#</a></h2><ol><li><p>我们main方法中的run最终调用了：<code>new SpringApplication(primarySources).run(args)</code></p></li><li><p>new了一个我们上面的SpringApplication类。这个new里面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader; <span class="comment">// null</span></span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));  <span class="comment">// 就是我们当前启动main方法的类</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();  <span class="comment">// 去确认WebApplication的类型，是Servlet还是Reactive还是None</span></span><br><span class="line">       <span class="comment">// getSpringFactoriesInstances是核心工具方法，去加载META-INF/spring.factories所有org.springframework.context.ApplicationContextInitializer</span></span><br><span class="line">       <span class="comment">// 加载回来list放到当前SpringApplication中，默认7个</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// 同上，加载所有jar包META-INF/spring.factories内配置的org.springframework.context.ApplicationListener （详情可以见附录），</span></span><br><span class="line">       <span class="comment">// 默认11个，加载回来list放到当前SpringApplication中</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">       <span class="comment">// new了一个RuntimeException，然后去遍历堆栈，找到main方法的类，真是骚操作。。。</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后继续执行run方法：</p><ul><li><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>{           <span class="hljs-comment">//---------------------准备工作开始</span>StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();  <span class="hljs-comment">// 计时器</span>stopWatch.start();ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// AnnotationConfigServletWebServerApplicationContext和XmlWebApplicationContext都是实现</span>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();configureHeadlessProperty();  <span class="hljs-comment">// headless解决awt</span>        <span class="hljs-comment">// 使用`getSpringFactoriesInstances`工具方法从factories配置文件里面加载并创建的所有`SpringApplicationRunListener`实现。默认只有一个EventPublishingRunListener-------这个类使用来发布所有Spring应用程序事件的，里面有一系列时机去调用多拨器的发布功能。构造方法里面new了一个多拨器Multicaster，并加入配置文件里面的11个默认监听器。</span>SpringApplicationRunListeners listeners = getRunListeners(args);          <span class="hljs-comment">// 迭代所有的启动listener，调用starting方法（其实就一个默认只有一个EventPublishingRunListener）它里面其实是发布了一个启动事件initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));  然后又会去拿着这个事件信息获取所有support这个源的监听类，执行他们的listener.onApplicationEvent(event);方法。</span>listeners.starting();  <span class="hljs-keyword">try</span> {ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);  <span class="hljs-comment">// 解析运行参数</span>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);  <span class="hljs-comment">// 准备环境----见下面</span>configureIgnoreBeanInfo(environment);  <span class="hljs-comment">// 获取env中spring.beaninfo.ignore设置到System.setProperty中</span>Banner printedBanner = printBanner(environment); <span class="hljs-comment">// 打印banner（spring.banner.location）</span>            <span class="hljs-comment">// 根据类型创建不同的Context，这里创建了一个AnnotationConfigServletWebServerApplicationContext，塞进去AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner</span>context = createApplicationContext();            <span class="hljs-comment">// 调用工具类读取jar包内/META-INF/spring.factories，获取所有异常报告器</span>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">new</span> <span class="hljs-title">Class</span>[] </span>{ ConfigurableApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span> }, <span class="hljs-title">context</span>)</span>;            <span class="hljs-comment">// 给上下文设置env、给Context注册参数、执行初始化器的方法、-------发布ApplicationContextInitializedEvent事件、给BeanFactory注册应用的启动参数、load方法new了一个AnnotatedBeanDefinitionReader，把启动类注册进去。--------发布ApplicationPreparedEvent事件。</span>prepareContext(context, environment, listeners, applicationArguments, printedBanner);            <span class="hljs-comment">//---------------------准备工作结束，开始进入spring</span>                        <span class="hljs-comment">// 刷新context，调用applicationContext.refresh()进入AbstractApplicationContext的resresh方法，也就是常规spring流程------------</span>refreshContext(context);afterRefresh(context, applicationArguments);stopWatch.stop();<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) {<span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);}listeners.started(context);callRunners(context, applicationArguments);}<span class="hljs-keyword">catch</span> (Throwable ex) {handleRunFailure(context, ex, exceptionReporters, listeners);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);}<span class="hljs-keyword">try</span> {listeners.running(context);}<span class="hljs-keyword">catch</span> (Throwable ex) {handleRunFailure(context, ex, exceptionReporters, <span class="hljs-keyword">null</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);}<span class="hljs-keyword">return</span> context;}&lt;!--￼<span class="hljs-number">15</span>--&gt;- 先根据运行模式创建一个环境，这里是`StandardServletEnvironment`，也有相应式的`StandardReactiveWebEnvironment`- 解析启动参数到env中，启动参数解析`spring.profiles.active`选择生效的配置文件</code></pre></li><li><p>解析env中的忽略bean设置到System.property中</p></li><li><p>打印banner</p></li><li><p>根据类型创建不同的Context，反射创建一个<strong>AnnotationConfigServletWebServerApplicationContext</strong></p></li><li><p><code>prepareContext</code>准备上下文：</p><ul><li><p>给上下文设置env、给Context注册参数、执行初始化器的方法、发布ApplicationContextInitializedEvent事件、给BeanFactory注册应用的启动参数、load方法new了一个<strong>AnnotatedBeanDefinitionReader</strong>，把启动类注册进去。发布ApplicationPreparedEvent事件。</p></li><li><pre class="highlight"><code class="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>{        <span class="hljs-comment">// 上下文设置env</span>context.setEnvironment(environment);        <span class="hljs-comment">// 给context设置一些属性，类型转换器ConversionService</span>postProcessApplicationContext(context);        <span class="hljs-comment">// 拿到所有的初始化器，执行初始化方法initializer.initialize(context);可以给context进行拓展，如给context添加BeanFactoryPostPocessor</span>applyInitializers(context);listeners.contextPrepared(context);  <span class="hljs-comment">// 发布ApplicationContextInitializedEvent事件----------------------------------第三个事件，进行一堆初始化</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) {logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);logStartupProfileInfo(context);  <span class="hljs-comment">// 打印生效的配置文件</span>}<span class="hljs-comment">// Add boot specific singleton beans   给beanFactory注册springBoot特殊的对象</span>ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        <span class="hljs-comment">// 注册应用参数</span>beanFactory.registerSingleton(<span class="hljs-string">"springApplicationArguments"</span>, applicationArguments);<span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) {beanFactory.registerSingleton(<span class="hljs-string">"springBootBanner"</span>, printedBanner);}        <span class="hljs-comment">// 设置是否允许BeanDefinition覆盖</span><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) {((DefaultListableBeanFactory) beanFactory).setAllowBeanDefinitionOverriding(<span class="hljs-keyword">this</span>.allowBeanDefinitionOverriding);}        <span class="hljs-comment">// 添加一个懒加载的BFPP</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazyInitialization) {context.addBeanFactoryPostProcessor(<span class="hljs-keyword">new</span> LazyInitializationBeanFactoryPostProcessor());}<span class="hljs-comment">// Load the sources</span>Set&lt;Object&gt; sources = getAllSources();Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);        <span class="hljs-comment">// 重要-------------把当前启动类注册到AnnotatedBeanDefinitionReader里面。new了一个AnnotatedBeanDefinitionReader实现，调用其load方法，里面判断了isComponent。是的话就annotatedReader.register(source);source就是启动类。注册到BeanDefinitionReader中。使得我们的主启动类可以被发现。</span>         <span class="hljs-comment">// 我们的@SpringBootApplication也是继承自@Component的，所以上面isComponent才可以。</span>        <span class="hljs-comment">// 后续在spring的resresh的invokeBFPP(beanFactory)中调用postProcessBeanDefinitionRegistry--&gt;processConfigBeanDefinitions,判断对象是否是@Configuration的，是否是@Order，解析每一个用@Configuration标识的类，parse方法内--&gt;doProcessConfigurationClass进行自动装配。</span>load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]));       <span class="hljs-comment">// 发布事件-------------------------------ApplicationPreparedEvent-----------------------------------第四个事件</span>listeners.contextLoaded(context); }&lt;!--￼<span class="hljs-number">16</span>--&gt;</code></pre></li><li></li></ul></li><li></li></ul></li><li><p>springboot的核心功能还是在spring里面：</p><ol><li>自动装配在invokeBeanFactoryPostProcessor完成</li><li>后续spring中的refresh里面，finishrefresh完成tomcat启动</li></ol></li></ol><p>临时参考，自己画后干掉</p><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200714004049743.png" alt="image-20200714004049743"></p><h2><span id="gong-ju-fang-fa"> 工具方法</span><a href="#gong-ju-fang-fa" class="header-anchor">#</a></h2><h3><span id="gong-ju-fang-fa-getspringfactoriesinstances"> 工具方法<code>getSpringFactoriesInstances</code></span><a href="#gong-ju-fang-fa-getspringfactoriesinstances" class="header-anchor">#</a></h3><ul><li><code>private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</code>  传入想获取的类型，如上面的<code>getSpringFactoriesInstances(ApplicationContextInitializer.class)</code>就可以获取所有<code>META-INF/spring.factories</code>文件中配置key为<code>ApplicationContextInitializer</code>的实现。</li><li>ClassLoader从每个jar包的<code>META-INF/spring.factories</code>中读取个个properties，默认的三个见附录。都是一个key，一大串value，然后放到Map缓存中。</li><li>然后反射拿到各个value中的bean名称，使用构造方法创建对象list（一个key对应多个对象）。</li><li>使用@Order对上面的bean进行排序，返回list。</li></ul><h3><span id="duo-bo-qi-fa-bu-shi-jian"> 多拨器发布事件</span><a href="#duo-bo-qi-fa-bu-shi-jian" class="header-anchor">#</a></h3><p><code>SimpleApplicationEventMulticaster#multicastEvent</code>方法用于发布启动、EnvPrepared、：</p><p>如刚开始启动的时候：<code>initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args))</code> 发布了一个启动方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line">        <span class="comment">// getApplicationListeners拿到event和一个resolvableType去拿所有支持这个事件的listener，底层是用event的时间源source类名去各个listener中判断当前listener是否supportEvents支持这个event源，支持的话才能拿到。</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; </span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);  <span class="comment">// 执行所有的listener.onApplicationEvent(event);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources) ，resourceLoader是null，primarySources是当前启动main类</li><li>webApplicationType = WebApplicationType.deduceFromClasspath(); 去决定我们的</li></ul><p>new 的时候完成了prepare</p><p>环境准备好之后，发布environmentPreparedEvent，然后发布事件，listener挨个执行。</p><p>创建上下文对象<code>AnnotationConfigServletWebServerApplicationContext</code></p><ul><li><h2><span id="preparecontext"> prepareContext：</span><a href="#preparecontext" class="header-anchor">#</a></h2></li></ul><h2><span id="fu-lu"> 附录</span><a href="#fu-lu" class="header-anchor">#</a></h2><p><code>org.springframework.context.ApplicationContextInitializer</code>和<code>org.springframework.context.ApplicationListener</code> 在启动并new SpringApplication的时候加载</p><h3><span id="spring-boot-2-3-1-release-jar-meta-inf-spring-factories"> spring-boot-2.3.1.RELEASE.jar # META-INF/spring.factories</span><a href="#spring-boot-2-3-1-release-jar-meta-inf-spring-factories" class="header-anchor">#</a></h3><p><code>spring-boot-2.3.1.RELEASE.jar</code>中的<code>spring.factories</code>文件参考：</p><ul><li>里面有个8个key，功能如下：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PropertySource Loaders-----------加载properties或者yaml配置文件的</span></span><br><span class="line"><span class="meta">org.springframework.boot.env.PropertySourceLoader</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line"><span class="attr">org.springframework.boot.env.YamlPropertySourceLoader</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run Listeners------------启动的监听器，用于事件发布</span></span><br><span class="line"><span class="meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.context.event.EventPublishingRunListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Error Reporters----------------异常报告器</span></span><br><span class="line"><span class="meta">org.springframework.boot.SpringBootExceptionReporter</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.diagnostics.FailureAnalyzers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Context Initializers----------------初始化器</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners-----------------监听器列表，文件编码、配置文件、日志</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.ConfigFileApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line"><span class="attr">org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Environment Post Processors---------------环境处理processor，json环境、等等</span></span><br><span class="line"><span class="meta">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\</span><br><span class="line"><span class="attr">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Failure Analyzers----------------各种异常的失败解析器</span></span><br><span class="line"><span class="meta">org.springframework.boot.diagnostics.FailureAnalyzer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.BeanDefinitionOverrideFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.UnboundConfigurationPropertyFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.NoSuchMethodFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyNameFailureAnalyzer,\</span><br><span class="line"><span class="attr">org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyValueFailureAnalyzer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FailureAnalysisReporters-----------------异常失败分析报告器</span></span><br><span class="line"><span class="meta">org.springframework.boot.diagnostics.FailureAnalysisReporter</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter</span></span><br></pre></td></tr></table></figure><h3><span id="spring-boot-autoconfigure-2-3-1-release-jar-spring-factories"> spring-boot-autoconfigure-2.3.1.RELEASE.jar#spring.factories</span><a href="#spring-boot-autoconfigure-2-3-1-release-jar-spring-factories" class="header-anchor">#</a></h3><p>内容和功能如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initializers----------初始化器</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners----------------后台预初始化器</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Listeners-----------------------自动配置的ImportListener</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Filters------------------------自动配置的ImportFilter条件</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configure-----------------自动配置的核心类EnableAutoConfiguration，可以看到里面集成了ES、JPA、Mongo、Neo4j、Redis、MQ等等</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.r2dbc.R2dbcTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Failure analyzers----------------异常失败解析器</span></span><br><span class="line"><span class="meta">org.springframework.boot.diagnostics.FailureAnalyzer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayMigrationScriptMissingFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.r2dbc.ConnectionFactoryBeanCreationFailureAnalyzer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Template availability providers-------------------模板引擎支持</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span></span><br></pre></td></tr></table></figure><h3><span id="spring-beans-5-2-7-release-jar-spring-factories"> spring-beans-5.2.7.RELEASE.jar#spring.factories</span><a href="#spring-beans-5-2-7-release-jar-spring-factories" class="header-anchor">#</a></h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.beans.BeanInfoFactory</span>=<span class="string">org.springframework.beans.ExtendedBeanInfoFactory</span></span><br></pre></td></tr></table></figure><h1><span id="springboot-zi-dong-zhuang-pei-yuan-li"> SpringBoot自动装配原理</span><a href="#springboot-zi-dong-zhuang-pei-yuan-li" class="header-anchor">#</a></h1><p>首先，一句话描述“在BeanFactoryPostProcessor中完成的。”具体来说：</p><h2><span id="qi-dong-guo-cheng"> 启动过程：</span><a href="#qi-dong-guo-cheng" class="header-anchor">#</a></h2><ul><li>住启动类里面的run方法，底层new了一个<code>SpringApplicatin</code>,执行他的run方法。<ul><li>new这个<code>SpringApplicatin</code>这个过程会推断我们的运行环境，是<code>Sevlet</code>、还是<code>Groovy</code>、还是<code>Reactive</code></li><li>解析<code>/META-INF/spring.factories</code>，从这个文件里面加载初始化器、加载<code>ApplicationListener</code>，放到当前的对象里。</li><li>推断主启动类，new了一个<code>RuntimeException</code>，找到堆栈中<code>main</code>的那个类</li></ul></li><li>继续执行run方法：<ul><li>启动一个计时器<code>stopWatch</code>，配置<code>headless</code></li><li>从<code>/META-INF/spring.factories</code>找到一个<code>SpringRunListener</code>的实现，默认是<code>EventPublishListenr</code>，创建他，并在他里面塞了一个多拨器。多拨器里面是上面的一堆listener。<ul><li>发布第一个事件：<code>ApplicationStartingEvent</code>：<ul><li>有一个<code>BackgrougPreInitListener</code>判断多核就启动一个后台线程去执行初始化（jackson、conversion、messegeConvert）。</li><li><code>DelegatingApplicatoinListener</code>转发事件到用户的listener中去，此时为空。</li></ul></li></ul></li><li><strong>准备系统环境参数<code>prepareEnvironment</code></strong>：将请求参数封装，拿出来系统参数、<code>serlvet-init param</code>封装、获取<code>active-profiles</code>，发布<code>EnvironmentPreparedEvent</code>：<ul><li><code>ConfigFileApplicationListener</code>从env拿到<code>active-profiles</code>，读取配置文件</li><li><code>LoggingApplicationListener</code>env拿到参数，设置日志文件、等级</li><li><strong>DelegatingApplicationListener</strong>—解析配置文件**<code>context.listener.classes</code>**参数的类名，把用户实现了ApplicationListener的类都拿出来。</li></ul></li><li>打印banner</li><li>**创建上下文<code>createApplicationContext</code>：**既然是创建，先要知道类型。根据构造方法里面的运行环境是servlet，new了一个<code>AnnocationConfigSevletWebServerApplicationContext</code>对象，反射创建，作为我们的核心context对象。构造方法里：<ul><li>创建了<code>DefaultListableBeanFactory</code>，new了两个核心对象塞进去：<ul><li><strong>AnnotatedBeanDefinitionReader(this)传入当前context作为BeanDefinitionRegistry</strong>注册中心。里面创建并注册了核心的<strong>Annocation PostProcessor的BeanDefinition</strong>：<ul><li><code>ConfigurationClassPostProcessor</code>：后续自动装配的核心类</li><li><code>AutowiredAnnotationBeanPostProcessor</code>：后续IOC注入的一个核心类</li></ul></li><li><strong>ClassPathBeanDefinitionScanner</strong>(this)同样传入context、env、resourceLoader</li></ul></li></ul></li><li><strong>准备上下文<code>prepareContext(context, environment, listeners, applicationArguments, printedBanner)</code></strong>：<ul><li><strong><code>postProcessingContext(ctx)</code></strong>：给BF塞进去一堆conversionService（数字、字符、日期转换服务）</li><li><strong><code>applyInitializers</code></strong>：应用所有的初始化器：<ul><li><strong><code>DelegatingApplicationContextInitializer</code></strong>:又是一个委托代理，把配置文件的<strong>context.initializer.classes</strong>解析出来实例化，执行，默认空的。</li></ul></li><li><strong>发布ApplicationContextInitializedEvent事件</strong>,同样由EventPublishingRunListener使用多拨器发布事件:<ul><li><code>DelegatingApplicationListener</code>：转发请求到用户自定义的listener中去</li></ul></li><li><strong>load方法</strong>：加载资源、识别注解，使得当前启动类是可以被识别到：<ul><li>创建<code>BeanDefinitionLoader</code>，里面塞了<code>AnnotatedBeanDefinitionReader(registry)</code></li><li>进入重载的load(启动类)方法，判断<code>isComponent(启动类)</code>，当前启动类的继承接口中是否<code>@Component</code>修饰（必然是，因为<code>@Configuration</code>是）：<ul><li><strong>去给启动类创建一个Definitio（解析了@Lazy、@Primary、@DependsOn）</strong>，然后把启动类的definition注册到context中去</li><li>把启动类注册到annocationReader中去------把我们的主启动类让Spring注解能扫描到</li></ul></li></ul></li></ul></li><li><strong>发布ApplicationPreparedEvent事件</strong>：<ul><li><code>DelegatingApplicacationListener</code>转发给用户自定义listener</li><li>其他的没啥了，<code>PrepareContext</code>的事件业务，实现类大多都在上一步的<code>ApplicationContextInitializedEvent</code>做了</li></ul></li><li><strong>刷新上下文<code>application.refreshContext(context)</code></strong>：<br>super.refresh()中调用了**ConfigurableApplicationContext#refresh()**进入<code>AbstractApplicationContext.refresh()</code>方法，也就是经典springframework流程。</li></ul></li></ul><hr><p>下面就开始真正的<code>refresh()</code>过程，分割一下更清晰：</p><ul><li><p><strong>prepareRefresh()</strong>：没啥用，设置启动时间、启动停止标志位</p></li><li><p><strong>obtainFreshBeanFactory()</strong>：直接拿到<code>DefaultListableBeanFactory</code>，经典springframework此处是new的</p></li><li><p><strong>prepareBeanFactory(BF)</strong>：</p><ul><li>给BF设置参数,BF里面注册env，</li><li>添加一个BPP：<code>ApplicationContextAwareProcessor</code>，处理各种Aware，后续创建Bean的时候可以根据Bean实现的<code>Aware</code>的类型塞进去context、env、ApplicationEventPublisher等。</li><li>BF添加一个BPP：<code>ApplicationListenerDetector</code>，用来识别所有的<code>ApplicationListener</code></li></ul></li><li><p>**postProcessBeanFactory(BF)**给BF设置参数、初始化SCOPE、初始化Ruquest、Response、Session各自的ObjectFactory</p></li><li><p><strong>invokeBeanFactoryPostProcessors(BF)实例化并执行所有已经注册的BFPP，有顺序的话按照顺序执行，自动装配在此实现</strong>：</p><ul><li><p>**PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(BF, getBeanFactoryPostProcessors());**熟悉的委托思想，里面的逻辑几块都是重复的：</p><ul><li><p>从BF中拿出所有的BFPP，然后将<strong>子类BDRPP放到一个list</strong>中，<strong>BPP放到一个list中</strong>：</p></li><li><p>依次先找@PriorityOrdered、再@Ordered、再others去寻找<code>BeanDefinitionRegistryPostProcessor</code>和<code>BeanFactoryPostProcessor</code>,创建、排序后执行。</p></li><li><p><strong>1）<strong>先执行子类</strong>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry)</strong>:</p><ul><li><p><strong>其中最终要的：ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(BF)核心方法，实现了自动装配：</strong></p><ul><li><p>**<code>processConfigBeanDefinitions()</code>**方法做了：</p><ul><li><p>拿出BF所有的类定义，找到<code>@Configuration</code>修饰的（此时默认只有启动类）</p></li><li><p><strong>new ConfigurationClassParser().parse(ConfigurationBeanNames)</strong>：参数也只有启动类。</p><ul><li><p><code>parse</code>方法进入一个核心干活的**<code>ClassPathBeanDefinitionScanner#doScan</code>**会去扫描子包，解析所有子包的<code>@Component</code>的类，判断<code>Scope</code>、生成<code>BeanName</code>、设置<code>AutoWire类型</code>、<code>initMethodName</code>、<code>destroyMethodName</code>、解析<code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>然后生成一个<code>Set&lt;BeanDefinitionHolder&gt;</code>类定义。</p></li><li><p><strong>同时记录下了所有的@Configuration类</strong></p></li><li><p>上面<code>parse</code>的<code>doScan</code>扫描完毕后，会拿到2个默认的<code>@Import</code>类就是我们启动类配置文件上面的。使用<code>processImports</code>方法处理@Import，完成自动装配。准备工作：</p><ul><li>循环<code>Set&lt;BeanDefinitionHolder&gt;</code>（扫描来的每个类定义），检查是否配置类，检查逻辑：</li><li><strong>是<code>@Configuration</code>，且类定义元数据中的proxyBeanMethods不存在，设置类定义的configurationClass=full，返回true。</strong></li><li><strong>是 @Configuration且有proxyBeanMethods、或者非@Configuration的@Import、@Component、@ImportResource、@ComponentScan，设置类定义的configurationClass=lite。塞进去order，返回true</strong></li><li><strong>其他普通类返回false</strong></li><li>对上面每个确认通过的(可能的)配置类调用parse(className,beanName),又递归调用processConfigurationClass递归分类处理。</li></ul></li><li><p><strong><code>ConfigurationClassParser#processImports</code>方法</strong>，核心中的核心：</p><ul><li>判断循环import报错</li><li><code>importStack(配置类)</code>入栈</li><li>循环判断需要导入的类的类型：<ul><li><p><strong>[第一种]</strong>判断是ImportSelector的子类，默认也就是启动类的 <code>@EnableAutoConfiguration</code>里面的<code>@Import(AutoConfigurationImportSelector.class)</code>  ,又分两种情况：</p><pre><code>- ① 用户自定义的`ImportSelector` 先执行：      - `selector.selectImports(MetaData)`拿到用户要导入的类的class名称列表，包装为sourceClass的列表。（返回的class是啥，bd就是啥，是死的）     - **递归调用`processImports(sourceClass列表)`继续解析**    -  ② spring内置的`DeferredImportSelector`的子类，如`AutoConfigurationImportSelector`会延迟到普通`ImportSelector`之后运行：  - 加载`AutoConfigurationImportSelector`类并实例化selector  - **deferredImportSelectorHandler.handle(启动类Class、selector)完成自动装配，下面是细节-----递归，也会出入栈**    - 又创建了一个**DeferredImportSelectorGroupingHandler**，处理过程见下面。    - 先`register`，把导入的类放到`configurationClasses`list中    - 再`processGroupImports`，去执行类似`selector.selectImports(MetaData)`拿到类列表       - **递归调用`processImports(sourceClass列表)`继续解析**</code></pre><ul><li><strong>[第二种]</strong>判断是 <strong>ImportBeanDefinitionRegistrar</strong>的实现类：<ul><li>反射创建，对象视为<code>ImportBeanDefinitionRegistrar</code>，给当前配置类configClass里面add一个创建的<code>registrar</code>，最后在外面统一进行注册。（可以动态生成class，动态创建bd，非常灵活。Mybatis的Mapper就是这样的）<ul><li>如是启动类的 <code>@Import(AutoConfigurationPackages.Registrar.class)</code>判断是ImportBeanDefinitionRegistrar的子类：</li><li>实例化一个<code>AutoConfigurationPackages.Registrar</code>对象，塞进去BF、env、<code>resourceLoader</code><br>- <code>importBeanDefinitionRegistrars.put(registrar, 启动类MetaData)</code>放进去这个对象</li></ul></li></ul></li><li><strong>[第三种]</strong>import普通类，视为普通<code>@Configuration</code>，进行<code>processConfigurationClass(clz,filter)</code>调用</li></ul></li><li><p>上面三种情况处理的结果都放到<code>configClass</code>这个list中</p></li></ul></li></ul></li></ul></li></ul></li><li><p><code>importStack(配置类)</code>出栈<br>- 最后调用<code>deferredImportSelectorHandler.process()</code>去处理所有的import</p><pre><code>- **`ConfigurationClassParser$DeferredImportSelectorHandler#handle(configClass,selector)`处理`DeferredImportSelector`：----------递归逻辑**        - 大体是解析`META-INF/spring.factories`中的自动配置类，筛选满足Condition的对象`deferredImportSelectorHandler.process()`：                - `handler`的`deferredImportSelectors`对象里面有上面启动类`@EnableAutoConfiguration`上面的 `@AutoConfigurationImportSelector`对象(env,BF)，多个的话是list，排序。             - **handler.processGroupImports()**,执行分组导入，先执行grouping.getImports()方法去真正获取配置类：             - **grouping.getImports()**会调用到`group.select()`会进入到**`AutoConfigurationImportSelector#process(annoMetaData, selector)`**方法。            - 最后落地调用了**`AutoConfigurationImportSelector#getAutoConfigurationEntry(annocationMetaData)`**方法去加载配置文件：**`SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class)`**去拿到`META-INF/spring.factories`里面所有的`EnableAutoConfiguration`自动配置类。(springboot2默认拿出来124个所有的自动装配类)             - 处理`@ConditionOnBean、@ConditionOnMissingBean、@OnWebApplicationCondition`，删掉不符合的，剩下的就是有效的自动装配类（默认29个）</code></pre><ul><li>最后**<code>Selector.selectImports()</code>**，筛选我们配置文件上配置的exclude排除的配置类。（默认没有）</li></ul></li></ul><p>然后grouping.getImports().forEach(eachAotuConfiduration-&gt;{processImports(启动类,当前配置AnnotationMetaData)})-----开始递归一次解析当前自动装配类：<br><code>importStack入栈---&gt;processConfigurationClass---&gt;doProcessConfigurationClass(解析@Component和递归内嵌方法@Configuration)---&gt;importStack出栈</code></p><pre><code>  后面依次再来上面的流程。</code></pre></li></ul><p>上面子类<code>BeanDefinitionRegistryPostProcessor</code>流程走完之后，所有的配置类的<code>BeanDefinition</code>就被加载到<code>BeanFactory</code>中了。接下来开始执行各种父类的<code>BeanFactoryPostProcessor</code>去插手BeanFactory创建。</p></li></ul></li><li><p><strong>2）<strong>再把子类当作普通<code>BeanFactoryPostProcessor</code>执行一遍类</strong>invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</strong></p><ul><li>又到了我们上面的<code>CinfigurationClassPostProcessor</code>类的<code>postProcessBeanFactory</code>，这里面干了两件事：</li><li><strong>CGLib代理我们的<code>@Configuration</code>类、给BF添加一个<code>ImportAwareBeanPostProcessor</code></strong><ul><li><strong>enhanceConfigurationClasses(beanFactory)</strong>：这一行代码<strong>遍历所有的类定义，判断是否full还是lite</strong>，full的使用CGlib的<code>Enhancer</code>进行增强创建代理，新增了一个接口<code>EnhancerConfiguration</code>，其实是一个<code>BeanFactoryAware</code>并给代理类创建了一个<code>public 的 $$beanFactory</code>属性用来存放BF。同时传入一个<code>MethodInterceptor</code>，来拦截方法调用，防止因为@Bean方法的互相调用来导致多次new对象。（在拦截器里面有判断是否初次调用，不是的话就new，否则从$$beanFactory拿出来一个引用。判断是根据代理方法名和调用方法名是否一致），具体见 《<a href="proxy_jdk_cglib.html">关于代理的一切</a>》里面有CGlib那一块，摘录了spring此处的实现。</li><li><code>beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory))</code>给BF手动添加一个BPP。</li></ul></li></ul></li><li><p>**3）**再执行普通的父类<code>BeanFactoryPostProcessor</code>，也是按照<code>@PriorityOrderd</code>、<code>@Ordered</code>、<code>none普通</code>的顺序执行BFPP（都不太重要）：<strong>invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</strong></p><ul><li>PropertySourceOrderingPostProcessor，调用postProcessBeanFactory，里面给environment.getPropertySources()的defaultProperties重新排序到最后，没啥意思。</li><li><strong>ErrorMvcAutoConfiguration$$PreserveErrorControllerTargetClassPostProcessor#postProcessBeanFactory(BF)： 从BF拿出ErrorController的实现类，设置必须Aop代理</strong></li><li><strong>EventListenerMethodProcessor#postProcessBeanFactory(BF):拿出EventListenerFactory.class的</strong>bean设置到自己中。（EventListenerMethodProcessor还是一个SmartInitializingSingleton的实现，在afterSingletonsInstantiated回调中）,这里面有一个TransactionalEventListenerFactory</li></ul></li></ul></li><li><p><strong>registerBeanPostProcessors(beanFactory)</strong>： 对BPP进行注册</p><ul><li><p>进入的时候已经有了之前程序塞的4个BPP:<br>ApplicationContextAwareProcessor、ApplicatonListnerDetector、<strong>WebApplicationContextSevletContextAwareProcessor、ConfigurationClassPostProcessor的内部类ImportAwareBeanPostProcessor（4个）</strong><br>然后：<br>BF.getBeanNamesForType(BeanPostProcessor.class); 拿到所有的BPP给BF添加一个<strong>BeanPostProcessorChecker</strong>去校和打印信息，当BeanPostProcessor创建的时候bean就创建了，或者BPP处理bean有错误不合格。（5个）</p><p>类似BFPP，也是先注册@PriorityOrdered BPP，再注册@Ordered,最后是其他的。另外如果BPP是MergedBeanDefinitionPostProcessor类型，收集到一个internalPostProcessors中排序后注册到BF。</p></li></ul></li></ul><h2><span id="he-xin-pei-zhi-zhu-qi-dong-lei-springbootapplication"> 核心配置主启动类 @SpringBootApplication</span><a href="#he-xin-pei-zhi-zhu-qi-dong-lei-springbootapplication" class="header-anchor">#</a></h2><p>标明这是一个主启动类，是一个聚合注解，会同时触发<code>@Configuration</code> ，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>，参数有</p><ul><li><code>exclude/excludeName</code>要排除的自动装配的类/类名数组，从<code>@EnableAutoConfiguration</code>继承而来</li><li><code>scanBasePackages/scanBasePackageClasses</code>要扫描<code>@Components</code>的包和类集合</li><li><code>nameGenerator</code>:beanName生成器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates a &#123;<span class="doctag">@link</span> Configuration configuration&#125; class that declares one or more</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; methods and also triggers &#123;<span class="doctag">@link</span> EnableAutoConfiguration</span></span><br><span class="line"><span class="comment"> * auto-configuration&#125; and &#123;<span class="doctag">@link</span> ComponentScan component scanning&#125;. This is a convenience</span></span><br><span class="line"><span class="comment"> * annotation that is equivalent to declaring &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@EnableAutoConfiguration</span>&#125; and &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Andy Wilkinson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">//  </span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components. Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses&#125;</span></span><br><span class="line"><span class="comment"> * for a type-safe alternative to String-based package names.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;Note:&lt;/strong&gt; this setting is an alias for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ComponentScan <span class="doctag">@ComponentScan</span>&#125; only. It has no effect on &#123;<span class="doctag">@code</span> <span class="doctag">@Entity</span>&#125;</span></span><br><span class="line"><span class="comment"> * scanning or Spring Data &#123;<span class="doctag">@link</span> Repository&#125; scanning. For those you should add</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.boot.autoconfigure.domain.EntityScan <span class="doctag">@EntityScan</span>&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Enable</span>...Repositories&#125; annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackages"</span>)</span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment"> * scan for annotated components. The package of each class specified will be scanned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;Note:&lt;/strong&gt; this setting is an alias for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ComponentScan <span class="doctag">@ComponentScan</span>&#125; only. It has no effect on &#123;<span class="doctag">@code</span> <span class="doctag">@Entity</span>&#125;</span></span><br><span class="line"><span class="comment"> * scanning or Spring Data &#123;<span class="doctag">@link</span> Repository&#125; scanning. For those you should add</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.boot.autoconfigure.domain.EntityScan <span class="doctag">@EntityScan</span>&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Enable</span>...Repositories&#125; annotations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> base packages to scan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackageClasses"</span>)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; class to be used for naming detected components</span></span><br><span class="line"><span class="comment"> * within the Spring container.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The default value of the &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; interface itself indicates that</span></span><br><span class="line"><span class="comment"> * the scanner used to process this &#123;<span class="doctag">@code</span> <span class="doctag">@SpringBootApplication</span>&#125; annotation should</span></span><br><span class="line"><span class="comment"> * use its inherited bean name generator, e.g. the default</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnnotationBeanNameGenerator&#125; or any custom instance supplied to the</span></span><br><span class="line"><span class="comment"> * application context at bootstrap time.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> BeanNameGenerator&#125; to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SpringApplication#setBeanNameGenerator(BeanNameGenerator)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"nameGenerator"</span>)</span><br><span class="line">Class&lt;? extends BeanNameGenerator&gt; nameGenerator() <span class="keyword">default</span> BeanNameGenerator<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify whether &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; methods should get proxied in order to enforce</span></span><br><span class="line"><span class="comment"> * bean lifecycle behavior, e.g. to return shared singleton bean instances even in</span></span><br><span class="line"><span class="comment"> * case of direct &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method calls in user code. This feature requires</span></span><br><span class="line"><span class="comment"> * method interception, implemented through a runtime-generated CGLIB subclass which</span></span><br><span class="line"><span class="comment"> * comes with limitations such as the configuration class and its methods not being</span></span><br><span class="line"><span class="comment"> * allowed to declare &#123;<span class="doctag">@code</span> final&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The default is &#123;<span class="doctag">@code</span> true&#125;, allowing for 'inter-bean references' within the</span></span><br><span class="line"><span class="comment"> * configuration class as well as for external calls to this configuration's</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods, e.g. from another configuration class. If this is not needed</span></span><br><span class="line"><span class="comment"> * since each of this particular configuration's &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods is</span></span><br><span class="line"><span class="comment"> * self-contained and designed as a plain factory method for container use, switch</span></span><br><span class="line"><span class="comment"> * this flag to &#123;<span class="doctag">@code</span> false&#125; in order to avoid CGLIB subclass processing.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Turning off bean method interception effectively processes &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> * individually like when declared on non-&#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; classes, a.k.a.</span></span><br><span class="line"><span class="comment"> * "<span class="doctag">@Bean</span> Lite Mode" (see &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>'s javadoc&#125;). It is therefore behaviorally</span></span><br><span class="line"><span class="comment"> * equivalent to removing the &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; stereotype.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether to proxy &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Configuration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="springbootconfiguration"> @SpringBootConfiguration</span><a href="#springbootconfiguration" class="header-anchor">#</a></h2><p>是上面<code>SpringBootApplication</code>引用的一个注解，就是表明我是一个<code>@Configuration</code>，可以被扫描加载。起一个别名，是因为是启动类的，需要特殊一点，所需的时候可以找到。</p><ul><li><code>proxyBeanMethods</code>是@Configuration里面的一个注解。决定我们是否@Bean标注的方法应该使用CGlib进行代理，用来保证bean的生命周期行为。</li><li>例如，即使在直接的情况下返回共享单例bean实例获得代理@Bean用户代码的方法调用。</li><li>该功能要求的方法的拦截，通过它配有限制的运行时生成的CGLIB子类实现如配置类及其方法不被允许声明final 。</li><li>默认为true ，允许配置类内部以及外部调用该配置的“bean间引用”  @Bean 方法之间没有调用关系的话可以把 proxyBeanMethods 设置为 false以免CGLIB子类的处理。</li><li>关闭bean方法拦截有效地处理@Bean方法来单独像非申报时@Configuration班，又名“@Bean精简版模式”（见@Bean’s javadoc ）。 因此，它是行为上等同于除去@Configuration版本。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify whether &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; methods should get proxied in order to enforce</span></span><br><span class="line"><span class="comment"> * bean lifecycle behavior, e.g. to return shared singleton bean instances even in</span></span><br><span class="line"><span class="comment"> * case of direct &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method calls in user code. This feature requires</span></span><br><span class="line"><span class="comment"> * method interception, implemented through a runtime-generated CGLIB subclass which</span></span><br><span class="line"><span class="comment"> * comes with limitations such as the configuration class and its methods not being</span></span><br><span class="line"><span class="comment"> * allowed to declare &#123;<span class="doctag">@code</span> final&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The default is &#123;<span class="doctag">@code</span> true&#125;, allowing for 'inter-bean references' within the</span></span><br><span class="line"><span class="comment"> * configuration class as well as for external calls to this configuration's</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods, e.g. from another configuration class. If this is not needed</span></span><br><span class="line"><span class="comment"> * since each of this particular configuration's &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods is</span></span><br><span class="line"><span class="comment"> * self-contained and designed as a plain factory method for container use, switch</span></span><br><span class="line"><span class="comment"> * this flag to &#123;<span class="doctag">@code</span> false&#125; in order to avoid CGLIB subclass processing.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Turning off bean method interception effectively processes &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> * individually like when declared on non-&#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; classes, a.k.a.</span></span><br><span class="line"><span class="comment"> * "<span class="doctag">@Bean</span> Lite Mode" (see &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>'s javadoc&#125;). It is therefore behaviorally</span></span><br><span class="line"><span class="comment"> * equivalent to removing the &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; stereotype.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether to proxy &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Configuration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="enableautoconfiguration"> @EnableAutoConfiguration</span><a href="#enableautoconfiguration" class="header-anchor">#</a></h2><ul><li>这个注解用来启用Spring应用程序上下文自动配置，尝试推断和自动配置bean。</li><li>自动配置类通常采用基于你的classpath中已有的bean定义。</li><li>举例来说，如果你有tomcat-embedded.jar在classpath中，你可能会想TomcatServletWebServerFactory （除非您已经定义了自己ServletWebServerFactorybean）。</li><li>当使用@SpringBootApplication ，自动配置上下文的，因此添加这个注解没有额外的效果。</li><li>自动配置尝试将智能地实现我们自己的配置， 您可以随时手动exclude()的任何配置，（使用excludeName()如果您没有访问它们）。或者通过spring.autoconfigure.exclude配置来排除无需引入的配置类。</li><li>通常通过@SpringBootApplication来使用 此注解。<br>如果你不使用@SpringBootApplication， 通常建议您将@EnableAutoConfiguration放在根目录，它会去搜索所有子包和类。</li><li>被自动配置类是普通的Spring @Configurationbean。 他们使用的是位于SpringFactoriesLoader机制（键控对这个类）。<br>一般的自动配置bean类@Conditionalbean（最常使用@ConditionalOnClass和@ConditionalOnMissingBean注释）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enable auto-configuration of the Spring Application Context, attempting to guess and</span></span><br><span class="line"><span class="comment"> * configure beans that you are likely to need. Auto-configuration classes are usually</span></span><br><span class="line"><span class="comment"> * applied based on your classpath and what beans you have defined. For example, if you</span></span><br><span class="line"><span class="comment"> * have &#123;<span class="doctag">@code</span> tomcat-embedded.jar&#125; on your classpath you are likely to want a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> TomcatServletWebServerFactory&#125; (unless you have defined your own</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ServletWebServerFactory&#125; bean).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When using &#123;<span class="doctag">@link</span> SpringBootApplication <span class="doctag">@SpringBootApplication</span>&#125;, the auto-configuration</span></span><br><span class="line"><span class="comment"> * of the context is automatically enabled and adding this annotation has therefore no</span></span><br><span class="line"><span class="comment"> * additional effect.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Auto-configuration tries to be as intelligent as possible and will back-away as you</span></span><br><span class="line"><span class="comment"> * define more of your own configuration. You can always manually &#123;<span class="doctag">@link</span> #exclude()&#125; any</span></span><br><span class="line"><span class="comment"> * configuration that you never want to apply (use &#123;<span class="doctag">@link</span> #excludeName()&#125; if you don't</span></span><br><span class="line"><span class="comment"> * have access to them). You can also exclude them via the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> spring.autoconfigure.exclude&#125; property. Auto-configuration is always applied</span></span><br><span class="line"><span class="comment"> * after user-defined beans have been registered.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The package of the class that is annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@EnableAutoConfiguration</span>&#125;,</span></span><br><span class="line"><span class="comment"> * usually via &#123;<span class="doctag">@code</span> <span class="doctag">@SpringBootApplication</span>&#125;, has specific significance and is often used</span></span><br><span class="line"><span class="comment"> * as a 'default'. For example, it will be used when scanning for &#123;<span class="doctag">@code</span> <span class="doctag">@Entity</span>&#125; classes.</span></span><br><span class="line"><span class="comment"> * It is generally recommended that you place &#123;<span class="doctag">@code</span> <span class="doctag">@EnableAutoConfiguration</span>&#125; (if you're</span></span><br><span class="line"><span class="comment"> * not using &#123;<span class="doctag">@code</span> <span class="doctag">@SpringBootApplication</span>&#125;) in a root package so that all sub-packages</span></span><br><span class="line"><span class="comment"> * and classes can be searched.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Auto-configuration classes are regular Spring &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * beans. They are located using the &#123;<span class="doctag">@link</span> SpringFactoriesLoader&#125; mechanism (keyed</span></span><br><span class="line"><span class="comment"> * against this class). Generally auto-configuration beans are</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Conditional <span class="doctag">@Conditional</span>&#125; beans (most often using</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConditionalOnClass <span class="doctag">@ConditionalOnClass</span>&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConditionalOnMissingBean <span class="doctag">@ConditionalOnMissingBean</span>&#125; annotations).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="autoconfigurationpackage"> @AutoConfigurationPackage</span><a href="#autoconfigurationpackage" class="header-anchor">#</a></h2><p>注册配置的<code>basePackageClasses</code>或<code>basePackageClasses</code>数组。如果没有指定这两个参数，那就注册当前配置的这个类（主启动类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers packages with &#123;<span class="doctag">@link</span> AutoConfigurationPackages&#125;. When no &#123;<span class="doctag">@link</span> #basePackages</span></span><br><span class="line"><span class="comment"> * base packages&#125; or &#123;<span class="doctag">@link</span> #basePackageClasses base package classes&#125; are specified, the</span></span><br><span class="line"><span class="comment"> * package of the annotated class is registered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> AutoConfigurationPackages</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages that should be registered with &#123;<span class="doctag">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to String-based package</span></span><br><span class="line"><span class="comment"> * names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the back package names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages&#125; for specifying the packages to be</span></span><br><span class="line"><span class="comment"> * registered with &#123;<span class="doctag">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class="line"><span class="comment"> * serves no purpose other than being referenced by this attribute.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the base package classes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="configuration"> @Configuration</span><a href="#configuration" class="header-anchor">#</a></h2><p>是Spring定义的一个注解，而不是Springboot才有的。<code>@Configuration</code> 又依赖于 <code>@Component</code>，是一个Spring中就有的配置类，用来标记我们的一个Class是一个类似传统xml配置文件，里面有很多<code>Bean</code>。在Springboot中，它是被自动装配的对象。</p><p>Spring容器启动中@Configuration的过程：</p><p>`AbstractApplicationContext::refresh–&gt;AbstractApplicationContext::invokeBeanFactoryPostProcessors</p><p>–&gt;ConfigurationClassPostProcessor::postProcessBeanFactory–&gt;ConfigurationClassPostProcessor::enhanceConfigurationClasses`</p><ul><li>ConfigurationClassPostProcessor::enhanceConfigurationClasses这个方法是Configuration注解工作的核心方法，</li><li>spring应用启动时所有的被@Configuration注解的类都会被spring cglib库生成cglib动态代理，</li><li>然后其他地方通过@Autowired注解引入业务Bean类对象就会被生成的configuration配置类生成的动态代理拦截，</li><li>处理完后再调用原configuration注解类的业务Bean方法获取到业务实例。</li></ul><p>原文链接：<a href="https://blog.csdn.net/john1337/java/article/details/86544214" target="_blank" rel="noopener">https://blog.csdn.net/john1337/java/article/details/86544214</a></p><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200723101852798.png" alt="image-20200723101852798"></p><h1><span id="springboot-jing-dian-wen-ti"> SpringBoot经典问题</span><a href="#springboot-jing-dian-wen-ti" class="header-anchor">#</a></h1><p>都搞定了，才能说熟练掌握<code>SpringBoot</code></p><ul><li>BeanDefinition的定义，在spring体系当中beanDefinition的和bean的产生过程有什么关系， sping当中的各种BeanDefinition的作用</li><li>BeanDefinition有什么作用？如果来改变一个bean的行为， spring当中有哪些扩展点开源来修改beanDefinition<ul><li>标记一个类的属性，包括class、singleton、lazy、constructor、depenedson</li></ul></li><li>BeanDefinitionRegistry的作用，源码分析，哪些开源框架利用了这个类<ul><li>mybatis动态创建mapper的实现，注入到里面去。</li></ul></li><li>BeanNameGenerator如何改变beanName的生成策略、如何自己写一个beanName的生成策略</li><li>BeanPostProcessor如何插手bean的实例化过程 经典的应用场景有哪些？ spring内部哪里用到了这个接口<ul><li>程序员使用BPP接口实现类，可以在创建Bean之前改变bd的行为和属性，进行修改、增强。</li><li>会形成一个列表，依次执行，返回null就截至不再执行了</li><li>如AOP就在此时</li></ul></li><li>BeanFactoryPostProcessor和BeanPostProcessor的区别、经典应用场景spring内部如何把他应用起来的</li><li></li><li>BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor的关系已经区别, spring底层如何调用他们<ul><li>BDRPP是BFPP的子类</li></ul></li><li>ConfigurationClassPostProcessor这个类如何完成bean的扫描，如何完成@Bean的扫描，如何完成对@Import的解析</li><li>@lmoprt的三种类型，普通类，配置类ImportSelector， sprinq在底层源码当中如何来解析这三种importe<ul><li>@import普通类，只是加载</li><li>@import一个<code>ImportSelector</code>实现，这个实现会返回一个string[]，里面是选中的类名。反射得到对象</li><li>@import一个<code>ImportBeanDefinitionRegistrar</code>实现，在这个类中，可以拿到resigtry自己生成bd往里面注入。</li><li>上面的@Import注解最终都是在<code>ConfigurationClassParser#processImports</code>中进行解析。使用了一个ImportStarck的栈数据结构进行递归的链式import。细节如：</li><li></li></ul></li><li>如何利用ImportSelector来完成寸spring的扩展？你所用的其他框架或者技术递明地方体现了这个类的使用<ul><li>aop、mybatis</li></ul></li><li>@Confiauration这注解为什么可以不加？加了和不加的区别，底层为什么使用calib<ul><li>full，lite，后续增强</li></ul></li><li>@Bean的方法是如何保证单例的？如果不需要单例需要这么配置？为什么需要这么配置</li><li>springFacoryBean和BeanFacory的区别，有哪些经典应用场景？ sprina的factoryMethod的经典应用场景？</li><li>ImportBeanDefinitionRegistrar这个接口的作用，其他主流框架如何利用这个类来完成和spring的结合的？</li><li>spring是什么时候来执行后置处理器的？有哪些重要的后置处理器，比如CommonAnnotationBeanPostProcessor</li><li>CommonAnnotationBeanPostProcessor如何来完成spring初始化方法的回调。sprinq内部的各种Procesor的作用分别是什么</li><li>spring和springBoot当中的各种@Enablexx的原理是什么？如何自己实现一个？比如动态开启某某些自定义功能</li><li>spring如何来完成bean的循环依赖并且实例化的，什么是sprina的1OC容器，怎么通过源码来理解？</li><li>其他，比如Bean的实例化过程，源码中的两次gegetSingleton的不同和相比如SpringMvc的源码分t等等…</li></ul><p>springboot里面有大量的listener，在meta-inf里面可以看到</p><p>springcloud的fegin实现使用的是FactoryBean</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#springboot-ru-men&quot;&gt;Springboot入门&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#bei-jing&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="Spring" scheme="https://blog.sofunnyai.com/tags/Spring/"/>
    
      <category term="SpringBoot" scheme="https://blog.sofunnyai.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>AQS原理、Condition、ReentrantLock和ReentrantReadWriteLock</title>
    <link href="https://blog.sofunnyai.com/article/aqs.html"/>
    <id>https://blog.sofunnyai.com/article/aqs.html</id>
    <published>2018-09-02T05:24:15.000Z</published>
    <updated>2020-07-28T16:21:16.502Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#suo-de-qian-shi-jin-sheng">锁的前世今生</a><ul><li><a href="#le-guan-suo-yu-bei-guan-suo">乐观锁与悲观锁</a></li></ul></li><li><a href="#aqs">AQS</a><ul><li><a href="#aqs-shi-sha">AQS是啥</a></li><li><a href="#tong-bu-de-chou-xiang-yu-ge-chong-shi-xian">同步的抽象与各种实现：</a></li></ul></li><li><a href="#cong-reentrantlock-shuo-qi">从ReentrantLock说起</a><ul><li><a href="#reentrantlock-de-yuan-ma">ReentrantLock的源码</a></li><li><a href="#aqs-de-nei-bu">AQS的内部</a></li><li><a href="#shuang-xiang-lian-biao-shi-xian-de-tong-bu-dui-lie">双向链表实现的同步队列</a></li><li><a href="#aqs-jia-suo-de-yuan-ma">AQS加锁的源码</a><ul><li><a href="#acquire-ru-kou-he-xin-fang-fa">acquire入口—核心方法</a></li><li><a href="#tryacquire-zi-lei-shi-xian-de-mo-ban">tryAcquire子类实现的模板</a></li><li><a href="#addwaiter-xian-cheng-ru-he-pai-dui-zi-xuan-tian-jia-dao-wei-bu-zhi-dao-cheng-gong-wei-zhi">addWaiter-线程如何排队— 自旋添加到尾部，直到成功为止</a></li><li><a href="#suo-yi-reentrantlock-pai-dui-de-guo-cheng-shi">所以ReentrantLock排队的过程是：</a></li><li><a href="#acquirequeued-wei-ru-dui-huo-qu-suo">acquireQueued—尾入队获取锁</a></li><li><a href="#shouldparkafterfailedacquire-pan-duan-huo-qu-suo-shi-bai-hou-shi-fou-ying-gai-park-zu-duan">shouldParkAfterFailedAcquire 判断获取锁失败后是否应该park阻断</a></li><li><a href="#gong-ping-suo-he-fei-gong-ping-suo-de-ti-xian">公平锁和非公平锁的体现</a></li></ul></li></ul></li><li><a href="#aqs-suo-shi-fang-de-yuan-ma">AQS锁释放的源码</a></li><li><a href="#reentrantreadwritelock-du-xie-suo-gong-xiang-suo">ReentrantReadWriteLock读写锁（共享锁）</a><ul><li><a href="#du-xie-suo-de-status-she-ji">读写锁的status设计</a></li><li><a href="#xie-suo-de-dai-ma">写锁的代码</a></li><li><a href="#jie-zhao-shi-du-suo-de-dai-ma">接着是读锁的代码：</a></li></ul></li><li><a href="#aqs-de-conditionobject-await-signal">AQS的ConditionObject、await/signal</a><ul><li><a href="#api-shi-li">API示例</a></li><li><a href="#condition-de-deng-dai-dui-lie">Condition的等待队列</a></li><li><a href="#await-deng-dai">await等待</a></li><li><a href="#signal-huan-xing">signal唤醒</a></li></ul></li><li><a href="#can-kao">参考</a></li></ul><!-- tocstop --></div><h1><span id="suo-de-qian-shi-jin-sheng"> 锁的前世今生</span><a href="#suo-de-qian-shi-jin-sheng" class="header-anchor">#</a></h1><p>先来一个镇楼图，来自美团技术：</p><p>锁的升级过程可以参见<a href="../volatile-and-synchronized.html">《多线程之volatile和synchronized》</a></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615024301986.png" alt="image-20200615024301986"></p><h2><span id="le-guan-suo-yu-bei-guan-suo"> 乐观锁与悲观锁</span><a href="#le-guan-suo-yu-bei-guan-suo" class="header-anchor">#</a></h2><ul><li>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候<strong>一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<strong>Java中，synchronized关键字和Lock的实现类都是悲观锁。（不能并发修改，只能排队顺序）-------适合</strong>写操作多</strong>的场景，先加锁可以保证<strong>写操作时数据正确</strong>。</li><li>乐观锁：而乐观锁认为自己在使用数据时<strong>不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</strong> （可能并发修改，如果真并发修改了，再议）--------------适合读操作多(写少)的场景，不加锁的特点能够使其<strong>读操作的性能大幅提升</strong>。(没有加锁开销)</li><li>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</li></ul><h1><span id="aqs"> AQS</span><a href="#aqs" class="header-anchor">#</a></h1><h2><span id="aqs-shi-sha"> AQS是啥</span><a href="#aqs-shi-sha" class="header-anchor">#</a></h2><p>如果从来没有听说过AQS的同学要知道这个，可以先看下<code>ReentrantLock</code>，<code>ReentrantLock</code>实现了一个<code>Lock</code>接口，并持有一个私有抽象静态<code>Sync</code>对象，这个抽象<code>Sync</code>又有两个实现，分别是公平锁<code>FairLock</code>和非公平锁<code>NonFiarLock</code>。缺省是非公平锁。</p><ul><li><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，后申请锁的线程需要排队，等它之前的线程获得锁并释放后，它才能获得锁；</li><li><strong>非公平锁</strong>：线程获得锁的顺序于申请锁的顺序无关，申请锁的线程可以直接尝试获得锁，谁抢到就是谁的；</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200614222312482.png" alt="image-20200614222312482"></p><p>具体的结构代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7373984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;   <span class="comment">// 实际ReentrantLock到底是公平还是非公平是new的时候指定的实现类。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">         * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>而抽象类<code>Sync</code>继承的<code>AbstractQueuedSynchronizer</code>类（简称AQS，抽象队列同步器）是是一个可以用来实现线程同步的基础工具。也就是说我们常用的<code>ReentrantLock</code>底层是由<code>AQS</code>实现的。</p><p>也就是说：AQS是一个提供了同步功能的<strong>基础设施</strong>，可以用它来完成锁同步等功能。在Java的并发包中大量使用。</p><h2><span id="tong-bu-de-chou-xiang-yu-ge-chong-shi-xian"> 同步的抽象与各种实现：</span><a href="#tong-bu-de-chou-xiang-yu-ge-chong-shi-xian" class="header-anchor">#</a></h2><p><strong>器AQS是公共逻辑，各种Lock的实现算是自定义的业务逻辑：</strong></p><p>AQS和Sync、FairSync、NonfairSync都是公共的抽象逻辑，而Lock、ReadLock、ReentrantLock都算是业务逻辑。这些业务逻辑是有各个场景的特点，给予我们的公共抽象逻辑基础设施来实现的。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200608153944872.png" alt="image-20200608153944872"></p><p>比如CountdownLatch里面也是有AQS和实现的。</p><p>此外<code>ReentrantLock</code>底层的Lock接口还保证了<code>ReentrantLock</code>的行为具有以下方法实现：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200607134100117.png" alt="image-20200607134100117"></p><h1><span id="cong-reentrantlock-shuo-qi"> 从ReentrantLock说起</span><a href="#cong-reentrantlock-shuo-qi" class="header-anchor">#</a></h1><p>ReentrantLock作为JUC包提供的可重入锁，和Synchronized关键字的区别如下：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615023855502.png" alt="image-20200615023855502"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 2.可用于代码块</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.手动释放锁</span></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p></blockquote><h2><span id="reentrantlock-de-yuan-ma"> ReentrantLock的源码</span><a href="#reentrantlock-de-yuan-ma" class="header-anchor">#</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="comment">// 继承AQS，有一些默认实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="comment">//......  一些AQS的抽象方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一些Sync抽象方法的实现（主要是非公平加锁和公平加锁，这里以非公平为例）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))  <span class="comment">// CAS修改爷爷类AQS的state，去加锁--------------保证原子性</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());  <span class="comment">// 修改成功的话去设置AQS当前锁的独占线程是我</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);  <span class="comment">// 修改失败的就去AQS执行aquire尝试获得锁，看下面AQS</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现AQS报错的源码获取一次锁，公平和非公平是两个实现，此处是非公平</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);   <span class="comment">// nonfairTryAcquire的实现：判断状态为0，独占是当前线程就重入+1返回true。不是重入的话就CAS抢占锁并设置AQS独占线程是我返回true，state=1或者没抢到返回false。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ReentrantLock内部使用了一个AQS的模板实现Sync，这个Sync又针对公平锁和非公平锁有两种实现。</li><li>非公平锁一上来就先CAS去修改AQS的锁状态state（unsafe用内存偏移量去修改，保证原子性），再去<code>acquire(1)</code></li><li>公平的是上来就去<code>acquire(1)</code></li><li><code>acquire(1)</code>可以看下面AQS的部分</li></ul><h2><span id="aqs-de-nei-bu"> AQS的内部</span><a href="#aqs-de-nei-bu" class="header-anchor">#</a></h2><p>开门见山：</p><ul><li>AQS内部有一个双向链表实现一个FIFO的同步队列来维护当前获取锁失败的线程。</li><li>使用一个<strong>volatile的int类型的同步状态state</strong>和一系列方法实现同步。（state的各个值什么含义是给子类去实现的）</li><li>AQS内部还有一个当前独占线程，来标识谁在占用同步状态</li></ul><p><code>AbstractQueuedSynchronizer</code>使用了模板方法的设计模式，把大部分的流程都实现了，但关键步骤使用抽象方法、抛异常的方式，交给子类去强制实现个性化定制。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占地获取锁和释放锁(非共享读写锁)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有更多，见下图</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200607143948752.png" alt="image-20200607143948752"></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200607144001939.png" alt="image-20200607144001939"></p><p><code>AQS</code>提供的模板方法主要分为三类：</p><ul><li>独占式地获取和释放锁；</li><li>共享式地获取和释放锁；</li><li>查询<code>AQS</code>的同步队列中正在等待的线程情况；</li></ul><h2><span id="shuang-xiang-lian-biao-shi-xian-de-tong-bu-dui-lie"> 双向链表实现的同步队列</span><a href="#shuang-xiang-lian-biao-shi-xian-de-tong-bu-dui-lie" class="header-anchor">#</a></h2><ul><li>AQS里面有一个volatile int类型的锁状态<code>state</code>，多线程CAS竞争修改。</li><li>AQS同步器内部有一个同步队列，每次线程获取锁失败就会增加一个Node到队尾，释放锁成功就会唤起队列最前面的Node中的线程，这个线程再去尝试。</li><li>队列中的头节点<code>head</code>就是当前已经获取了锁，正在执行的线程对应的节点；而之后的这些节点，则对应着获取锁失败，正在排队的线程。</li><li>AQS持有链表的<code>head</code>和<code>tail</code>节点，每个Node节点里面除了<code>pre</code>和<code>next</code>还有当前的线程。</li><li>当一个线程获取锁失败，它会被封装成一个<code>Node</code>，加入同步队列的尾部排队，同时线程会进入阻塞状态。</li><li>而当头节点对应的线程释放锁时，它会唤醒它的下一个节点。</li><li>被唤醒的节点对应的线程开始尝试获取锁，若获取成功，它就会将自己置为<code>head</code>，然后将原来的<code>head</code>移出队列。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200607152436844.png" alt="image-20200607152436844"></p><h2><span id="aqs-jia-suo-de-yuan-ma"> AQS加锁的源码</span><a href="#aqs-jia-suo-de-yuan-ma" class="header-anchor">#</a></h2><h3><span id="acquire-ru-kou-he-xin-fang-fa"> acquire入口—核心方法</span><a href="#acquire-ru-kou-he-xin-fang-fa" class="header-anchor">#</a></h3><p><code>ReentrantLock</code>的<code>lock()</code>方法调用了<code>AQS</code>的下面方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原文注释说：这是一个独占模式、忽略被打断。通过至少一次成功的tryAcquire就能拿到锁。</span></span><br><span class="line"><span class="comment">// 否则线程入队，反复调用tryAcquire被阻塞、解阻塞，直到返回true。</span></span><br><span class="line"><span class="comment">// 这个方法可以用来实现Lock.lock()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    <span class="comment">// FiarSync这里直接传了1进来调用</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;   <span class="comment">// tryAcquire成功则啥也没干地结束，失败继续，公平锁实现的时候如果有等的更久的会不去抢--------只有自己的时候不会排队</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">// 先包装Node，addWriter续尾，再acquireQueued去阻塞</span></span><br><span class="line">            selfInterrupt();  <span class="comment">// 如果里面在队列等待锁的过程中，被别人interrupt了是无法响应的。解锁后这里要继续处理响应interruput方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用<code>tryAcquire</code>尝试获取一次锁，若返回<code>true</code>，表示获取成功，则<code>acquire</code>方法将直接返回（没有构建同步队列）；若返回<code>false</code>，则会继续向后执行<code>acquireQueued</code>方法；-------公平和非公平此处tryAcquire的实现有差异，非公平先去CAS竞争state了一次再去判断重入，公平的直接判断没有等待的(hasQueuedPredecessors)的线程才acquire。</li><li><code>tryAcquire</code>返回<code>false</code>后，将执行<code>acquireQueued</code>，但是这个方法传入的参数调用了<code>addWaiter</code>方法；</li><li><code>addWaiter</code>方法的作用是将当前线封装成同步队列的节点，然后加入到同步队列的尾部进行排队，并返回此节点；（CAS去设置head、tail，失败则for死循环再来一轮。第一个head是一个空节点）</li><li><code>addWaiter</code>方法执行完成后，将它的返回值作为参数，调用<code>acquireQueued</code>方法。<code>acquireQueued</code>方法的作用是让当前线程在同步队列中阻塞，然后在被其他线程唤醒时去获取锁；-----这里会阻塞park</li><li>若线程被唤醒并成功获取锁后，将从<code>acquireQueued</code>方法中退出，同时返回一个<code>boolean</code>值表示当前线程是否被中断，若被中断，则会执行下面的<code>selfInterrupt</code>方法，响应中断；</li></ul><h3><span id="tryacquire-zi-lei-shi-xian-de-mo-ban"> tryAcquire子类实现的模板</span><a href="#tryacquire-zi-lei-shi-xian-de-mo-ban" class="header-anchor">#</a></h3><p><code>tryAcquire</code>是一个模板方法，留给子类的公平锁、非公平锁按场景去实现。不同的场景根据这个arg去修改state字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板方法，留给子类去实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁实现的时候如果有等的更久的会不去抢，非公平锁上来就CAS抢state从0为1。成功就返回，没成功判断重入，重入返回true，否则false。</p><p>如果tryAcquire没竞争到锁，下面开始排队：</p><h3><span id="addwaiter-xian-cheng-ru-he-pai-dui-zi-xuan-tian-jia-dao-wei-bu-zhi-dao-cheng-gong-wei-zhi"> addWaiter-线程如何排队— 自旋添加到尾部，直到成功为止</span><a href="#addwaiter-xian-cheng-ru-he-pai-dui-zi-xuan-tian-jia-dao-wei-bu-zhi-dao-cheng-gong-wei-zhi" class="header-anchor">#</a></h3><p>获取锁失败后到达<code>addWaiter</code>添加一个等待者：</p><p>将当前线程new 一个Node放到队列尾部，如果队列为空创建一个傀儡节点再添加尾部（傀儡节点就代表现在正在运行的那个线程）。如果加入失败就自旋(enq)直到添加成功，最后返回此节点。</p><p>（CAS去setTail一遍，失败的话后面<code>enq</code>循环一遍一遍CAS保证成功入队续上）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 拿出尾，作为前序节点，第一次是null</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;  <span class="comment">// 如果有尾，说明不是第一次，否则是第一次队列未初始化执行下面enq循环再试</span></span><br><span class="line">            node.prev = pred;      <span class="comment">// 新节点的前指针，指向上一个尾</span></span><br><span class="line">            <span class="comment">// CAS将新节点node设置为新尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;   <span class="comment">// 设置成功，前尾的后指针指向当前新尾</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;  <span class="comment">// 尾为空，执行下面enq初始化队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);   <span class="comment">// 初始化并CAS续尾（CAS设置head、tail）</span></span><br><span class="line">        <span class="keyword">return</span> node;  <span class="comment">// 返回</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没初始化则初始化，然后入队尾，注意初始化的时候new了一个空的傀儡节点作为header，然后再来一轮for循环CAS续上的。（如果没抢到就再来for循环，直到CAS抢到再返回）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary  把node进行一次入队，需要的时候进行初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;   <span class="comment">// 拿出尾</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize   没有尾，说明是第一次，需要初始化一个空的head再往后排</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))   <span class="comment">// head使用CAS初始化了一个虚拟的傀儡节点！这里是重点！！！！此时多线程的锁会竞争</span></span><br><span class="line">                    tail = head; <span class="comment">// 初始化首尾都是同一个，然后重新来for一次添加尾</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//第二轮以上for，初始化过，往最后排</span></span><br><span class="line">                node.prev = t;  <span class="comment">// 当前节点的前一个设置为前尾</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;   <span class="comment">// CAS去看前尾变化没，没变化就变更新尾，此时多线程的锁会竞争</span></span><br><span class="line">                    t.next = node;   <span class="comment">// 前尾的next指向新尾，尾巴成功修改</span></span><br><span class="line">                    <span class="keyword">return</span> t;   <span class="comment">// CAS续成功才会返回，否则永远来续-----------------------唯一出口</span></span><br><span class="line">                &#125;<span class="comment">// CAS失败，说明前尾变更，被别的线程抢先续尾了，重新来入队续尾</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="suo-yi-reentrantlock-pai-dui-de-guo-cheng-shi"> 所以ReentrantLock排队的过程是：</span><a href="#suo-yi-reentrantlock-pai-dui-de-guo-cheng-shi" class="header-anchor">#</a></h3><ul><li>AQS使用一个双向链表来代表线程的先后顺序，head永远是空。AQS内部有status，0-free，&gt;0-lock。Node内部有线程信息和waitStatus(CANCLE/SIGNAL/CONDITION/和共享锁的PROPAGATE)。</li><li>初始状态（也就是锁未被任何线程占用的时候）线程A申请锁<strong>此时，成功获取到锁，无排队线程</strong>（tryAcquire直接拿到true并返回）</li><li>线程B申请该锁，且上一个线程未释放：enq方法的for循环先创建一个<strong>空的Head(只有next指向)初始化队列</strong>，<strong>再来一个for循环添加当前Node</strong>（包含自身线程信息，和pre指向，模式独占或者共享）。</li><li>再来一个线程C申请该锁，且占有该锁的线程未释放：CAS来续尾成功就返回，失败的话去enq里面for的CAS续尾到成功为止。(成功后修改pre和自己的互相指向)</li></ul><p>上面加入到队尾后，返回节点，传入下面的方法去获取锁。</p><h3><span id="acquirequeued-wei-ru-dui-huo-qu-suo"> acquireQueued—尾入队获取锁</span><a href="#acquirequeued-wei-ru-dui-huo-qu-suo" class="header-anchor">#</a></h3><p>acquireQueued方法就是把获取锁失败的Node放入队列中，让这个线程不断进行“获锁”,直到它**“成功获锁”**或者“<strong>不再需要锁（如被中断）</strong>”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对队列里的节点node进行独占的、不可打断的获取锁。</span></span><br><span class="line"><span class="comment">    *  acquire()中和condition对象的各种await方法中被使用。</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;  <span class="comment">// acquire方法传入了刚刚加入队尾的一个节点，await方法传入的是一个节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;   <span class="comment">// 是否被打断的标识</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// 拿到当前Node的前序节点</span></span><br><span class="line">                <span class="comment">// 如果前序是head才会去CAS抢占锁。(现在这个线程解锁后也成为新的head了)</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">//(tryAcquire是模板方法，子类FairSync等实现的，去尝试CAS修改state获取锁后，下面再来把自己变成head)</span></span><br><span class="line">                    <span class="comment">// 到这里就是已经获取到锁了，旧头换新头（上面是CAS的，这里没有线程安全问题）</span></span><br><span class="line">                    setHead(node);   <span class="comment">// 这个是把当前节点设置为傀儡节点头，删除里面的thread等信息（已经拿到锁了，放thread没有意义，无助于GC）</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC   释放之前的傀儡头引用，帮助回收</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;   <span class="comment">//----------------------------唯一出口。 返回打断标识</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 自己不是老二（前序不是head）或者老二获取锁tryAcquire失败了，踏踏实实的先看是否应该park</span></span><br><span class="line">                <span class="comment">// 如果可以的话park等待，然后阻塞检查是否打断。打断了进入if内，没打断就结束这一轮获取。（不可能让一直死循环for来判断，CPU该爆炸了）</span></span><br><span class="line">                <span class="comment">// 不应该park的话就继续下一轮for再来抢占</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire方法判断当前线程是否能够进入等待状态，</span></span><br><span class="line">            <span class="comment">// 若当前线程的节点不是头节点的下一个节点，则需要进入等待状态，</span></span><br><span class="line">            <span class="comment">// 在此方法内部，当前线程会找到它的前驱节点中，第一个还在正常等待或执行的节点，</span></span><br><span class="line">            <span class="comment">// 让其作为自己的直接前驱，然后在需要时将自己唤醒（因为其中有些线程可能被中断），</span></span><br><span class="line">            <span class="comment">// 若找到，则返回true，表示自己可以进入等待状态了；</span></span><br><span class="line">            <span class="comment">// 则继续调用parkAndCheckInterrupt方法，当前线程在这个方法中等待，</span></span><br><span class="line">            <span class="comment">// 直到被其他线程唤醒，或者被中断后返回，返回时将返回一个boolean值，</span></span><br><span class="line">            <span class="comment">// 表示这个线程是否被中断，若为true，则将执行下面一行代码，将中断标志置为true</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">// 前面节点是SIGNAL，返回true可以阻塞自己</span></span><br><span class="line">                    parkAndCheckInterrupt()) <span class="comment">// 阻塞等待被唤醒，使用LockSupport.park()------------------------------------此时外面lock.lock()会阻塞，业务代码等待。</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 上面代码中只有一个return语句，且return的前一句就是failed = false;</span></span><br><span class="line">        <span class="comment">// 所以只有当异常发生时，failed才会保持true的状态运行到此处；</span></span><br><span class="line">        <span class="comment">// 异常可能是线程被中断，也可能是其他方法中的异常，</span></span><br><span class="line">        <span class="comment">// 比如我们自己实现的tryAcquire方法</span></span><br><span class="line">        <span class="comment">// 此时将取消线程获取锁的动作，将它从同步队列中移除</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法的主流程如下：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615014513513.png" alt="image-20200615014513513"></p><h3><span id="shouldparkafterfailedacquire-pan-duan-huo-qu-suo-shi-bai-hou-shi-fou-ying-gai-park-zu-duan"> shouldParkAfterFailedAcquire 判断获取锁失败后是否应该park阻断</span><a href="#shouldparkafterfailedacquire-pan-duan-huo-qu-suo-shi-bai-hou-shi-fou-ying-gai-park-zu-duan" class="header-anchor">#</a></h3><p>首先记着这个方法是在一个死循环中，获取锁失败就来执行一遍。为了方式for死循环大量占用CPU，可以想象绝大部分节点必然是返回true，然后park的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 检查并更新无法获取锁的节点的状态。在所有循环里返回true就阻塞。要求传入的pred 就是node的前序Node.pre指向的那个</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 前序节点等待状态</span></span><br><span class="line">        <span class="comment">// Node的WaitStatus，这里的SIGNAL是release方法写入的，下面再说</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)   <span class="comment">// 前序节点已经release，发出信号了，返回true标识可以park阻塞---------------这是唯一一个可以阻塞的true返回</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// 前序节点是取消状态，一直往前反向找到一个非取消的，这些Cancelled都被删掉了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;         <span class="comment">//--------------其实是删掉了所有中途取消的节点，继续外面的for死循环来进下一轮</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 前一节点是0或者传播状态，我们需要一个信号，但是还没park阻塞，此轮CAS设置把前一节点为SIGNAL状态，让调用者重新再来一遍就会阻塞他。</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);   <span class="comment">// pre设置为SIGNAL，下一轮来入口返回true，会阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//-----------删掉了cancel节点，或者SIGNAL了0或者传播节点，下一轮来阻塞</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面方法的流程图如下：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/54297968" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54297968</a></p></blockquote><p><img src="https://gitee.com/radio/pics/raw/master/img/v2-a9f87db22807c9c435b61975055b3d58_r.jpg" alt="preview"></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200608160739853.png" alt="image-20200608160739853"></p><h3><span id="gong-ping-suo-he-fei-gong-ping-suo-de-ti-xian"> 公平锁和非公平锁的体现</span><a href="#gong-ping-suo-he-fei-gong-ping-suo-de-ti-xian" class="header-anchor">#</a></h3><p>“不管<strong>公平</strong>还是<strong>非公平</strong>模式下，ReentrantLock对于排队中的线程都能保证，排在前面的一定比排在后面的线程优先获得锁”<strong>但是</strong>，非公平模式<strong>不保证</strong>“队列中的第一个线程一定就比新来的（未加入到队列）的线程优先获锁”因为队列中的第一个线程尝试获得锁时，可能刚好来了一个线程也要获取锁，而这个刚来的线程都还未加入到等待队列，此时两个线程同时随机竞争，很有可能，队列中的第一个线程竞争失败（而该线程等待的时间其实比这个刚来的线程等待时间要久）。</p><p>因为非公平锁上来就CAS开抢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);  <span class="comment">//AQS,会调用下面的方法，直接开枪，可能和队列最前面那个一起竞争。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而公平锁<code>hasQueuedPredecessors()</code>返回false，没有排在自己前面的才能去抢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;       <span class="comment">// 没有排在自己前面的，才能抢</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  线程的等待被取消</span></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// SIGNAL后继节点即将被唤醒（表示该线程一切都准备好了,就等待锁空闲出来给我）</span></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 线程在等待某一个条件（Condition）被满足</span></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//下一个共享获取应该是 无条件传播（当线程处在“SHARED”模式时，该字段才会被使用上，EXCLUSIVE独占模式不会）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values</span></span><br><span class="line"><span class="comment">             后继节点正在被park block，所以当前节点释放锁或者取消的时候必须要unpark唤醒后继。</span></span><br><span class="line"><span class="comment">             为了避免竞争，获取方法必须首先表明他们需需要一个信号，</span></span><br><span class="line"><span class="comment">             然后会尝试原子性的获取锁，如果失败才会block。</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         这个节点因为超时或者打断被取消，节点再也不会离开这个状态</span></span><br><span class="line"><span class="comment">         特别是一个线程取消后再也不会block</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         条件：这个节点正在一个条件队列中，他不会用作同步队列的节点，直到被transfer，这时候状态会被设置为0</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         传播：一个释放锁应该被传播到其他节点，在doReleaseShared中被设置来保证连续传播，除非其他操作介入。</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         waitStatus以数值型排列以简化使用，非负数代表节点不需要signal</span></span><br><span class="line"><span class="comment">         大多数代码不想要检查特定的数值（只用判断符号）</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         正常同步代码初始化为0，contidion节点的时候设置为CONDITION(-2),使用CAS修改。</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure><p>Node 的类注释机翻</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">等待队列是“ CLH”（Craig，Landin和Hagersten）锁定队列的变体。 </span><br><span class="line">CLH锁通常用于自旋锁。相反，我们将它们用于阻塞同步器，但是使用相同的基本策略，将有关线程的某些控制信息保存在其节点的前身中。</span><br><span class="line">每个节点中的“状态”字段将跟踪线程是否应阻塞。</span><br><span class="line">节点的前任释放时会发出信号。</span><br><span class="line">否则，队列的每个节点都充当一个特定通知样式的监视器，其中包含一个等待线程。虽然状态字段不控制是否授予线程锁等。</span><br><span class="line">线程可能会尝试获取它是否在队列中的第一位。</span><br><span class="line">但是先行并不能保证成功。它只赋予了抗辩的权利。</span><br><span class="line">因此，当前发布的竞争者线程可能需要重新等待。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;要加入CLH锁，您可以自动将其作为新尾部拼接。</span><br><span class="line">要出队，您只需设置头字段。</span><br><span class="line"></span><br><span class="line">&lt;p&gt;插入到CLH队列中，只需要对“ tail”执行一次原子操作，因此有一个从非排队到排队的简单原子分界点。</span><br><span class="line">同样，出队仅涉及更新“头”。但是，节点需要花费更多的精力来确定其后继者是谁，部分原因是要处理由于超时和中断而可能导致的取消。</span><br><span class="line">&lt;p&gt;“ prev”链接（在原始CLH锁中未使用）主要用于处理取消。</span><br><span class="line">如果取消某个节点，则其后继节点（通常）会重新链接到未取消的前任节点。有关自旋锁情况下类似机制的解释，请参见Scott和Scherer的论文，网址为http:&#x2F;&#x2F;www.cs.rochester.edu&#x2F;u&#x2F;scott&#x2F;synchronization&#x2F;。&lt;p&gt;</span><br><span class="line"></span><br><span class="line">我们还使用“下一个”链接来实现阻止机制。</span><br><span class="line">每个节点的线程ID保留在其自己的节点中，因此，前任通过遍历下一个next以确定它是哪个线程，来发信号给下一个节点唤醒。</span><br><span class="line">确定后继者必须避免与新排队的节点竞争以设置其前任节点的“ next”字段。----？ Determination of  successor must avoid races with newly queued nodes to set the &quot;next&quot; fields of their predecessors.</span><br><span class="line"></span><br><span class="line">    在必要时，可以通过在节点的后继者似乎为空时从原子更新的“尾部”反向检查来解决此问题。 </span><br><span class="line">（或者换句话说，next是一种优化，因此我们通常不需要反向扫描。）</span><br><span class="line">&lt;p&gt;Cancellation  对基本算法引入了一些保守性。由于我们必须轮询其他节点的取消，因此我们可能会遗漏没有注意到已取消的节点在我们前面还是后面。要解决此问题，必须始终在取消时取消后继者，使他们能够稳定在新的前任者身上，除非我们能确定一个未取消的前任者将承担这一责任。 &lt;p&gt; CLH队列需要一个虚拟标头节点才能开始。但是，我们不会在构建过程中创建它们，因为如果没有争执，那将是浪费时间。取而代之的是，构造节点，并在第一次争用时设置头和尾指针。 &lt;p&gt;等待条件的线程使用相同的节点，但是使用附加的链接。条件只需要在简单（非并行）链接队列中链接节点，因为仅当它们专用时才可以访问它们。等待时，将节点插入条件队列。收到信号后，该节点将转移到主队列。状态字段的特殊值用于标记节点所在的队列。 &lt;p&gt;感谢Dave Dice，Mark Moir，Victor Luchangco，Bill Scherer和Michael Scott以及JSR-166专家组的成员，对本课程的设计提供了有益的想法，讨论和批评。</span><br></pre></td></tr></table></figure><h1><span id="aqs-suo-shi-fang-de-yuan-ma"> AQS锁释放的源码</span><a href="#aqs-suo-shi-fang-de-yuan-ma" class="header-anchor">#</a></h1><p><code>AbstractQueuedSynchronizer#release()</code> 释放锁的方法，是底层释放锁的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unlock的实现,就一行代码调用这个AQS的release</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 尝试释放锁，子类ReentrantLock实现了，如见下面（就是看独占线程ok，state-1，清除独占线程，返回free==0。）</span></span><br><span class="line">            Node h = head; <span class="comment">// 拿到head，head不为空，而且不是刚初始化</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// waitStatus != 0 说明刚刚释放的过程中，又有一个新的来了，被后代把自己的waitStatus改成了SIGNAL</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 解除后继的阻塞</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock#tryRelease(1)</code>释放锁，不用CAS，因为线程不一样释放不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 锁的总数-释放数量    0的话就释放完了，&gt;0的话说明有重入没释放完</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <span class="comment">// 解锁线程不是当前正在独占的线程就抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 释放完了，清空独占线程</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c); <span class="comment">// 给stat设置剩余量，返回是否释放完了</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>解锁时唤醒后代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁时唤醒后代</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)  <span class="comment">// SIGNAL的，修改自己的wait状态为0</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">    <span class="comment">// 后代为空（可能是队列从前往后唤醒到最后一个了，或者后代被取消）</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;   <span class="comment">// 从尾巴反向往前走，如果队列是右边这种，就一直往前捋到一个正常的为止(head--cancle---cancle--...---node---tail)</span></span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 后代不为空，解除park</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后继节点唤醒之后，又回到上面的<code>acquireQueued()</code>方法，去进行下一轮死循环，判断pre是不是head，是不是已经解锁了，CAS抢占锁。</p><p>抢到后：head的next置为null，GC回去干掉head。把唤起的自己这个node变成新head，清理新head里面的thread信息和head里的pre信息。</p><p>然后当前唤起节点获取到锁的线程开始继续执行后面的业务方法。。。</p><h1><span id="reentrantreadwritelock-du-xie-suo-gong-xiang-suo"> ReentrantReadWriteLock读写锁（共享锁）</span><a href="#reentrantreadwritelock-du-xie-suo-gong-xiang-suo" class="header-anchor">#</a></h1><p><strong>独享锁</strong>：也叫排他锁，是指该<strong>锁一次只能被一个线程所持有。<strong>如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的</strong>synchronized</strong>和JUC中<strong>Lock</strong>的实现类就是互斥锁。</p><p><strong>共享锁</strong>：是指该锁可被多个线程所持有。如果<strong>线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁</strong>。获得<strong>共享锁的线程只能读数据，不能修改</strong>数据。</p><p>下面是JDK的读写分离锁代码实现：</p><p>读写分离锁,在读比较多(耗时)的场合比常规的重入锁更加有效率。</p><ul><li>读-读线程互不阻塞,多少各线程都可以并行一起读。</li><li>但是当<code>读-写</code>或者<code>写-写</code>线程相互竞争的时候会阻塞获取锁才可以操作</li></ul><p><strong>ReentrantReadWriteLock内部：</strong></p><ul><li><p>持有一个int类型的status锁状态。</p></li><li><p>一个Sync同步器，同步器继承自AQS，并有公平非公平两种实现。</p></li><li><p>持有一个共享的ReadLock，一个独占的WriteLock。</p></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615143328743.png" alt="image-20200615143328743"></p><p>可以看到ReentrantReadWriteLock有两把锁：<strong>ReadLock和WriteLock</strong>，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。<strong>读锁是共享锁</strong>，<strong>写锁是独享锁</strong>。<strong>读锁的共享锁可保证并发读非常高效</strong>，<strong>而读写、写读、写写的过程互斥，因为读锁和写锁是分离的</strong>。所以ReentrantReadWriteLock的并发性<strong>相比一般的互斥锁有了很大提升。</strong></p><p>类图如下：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615150705528.png" alt="image-20200615150705528"></p><h2><span id="du-xie-suo-de-status-she-ji"> 读写锁的status设计</span><a href="#du-xie-suo-de-status-she-ji" class="header-anchor">#</a></h2><p>AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><ul><li>在<strong>独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数）</strong>，在<strong>共享锁中state就是持有锁的数量</strong>。</li><li>但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。</li><li>于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615151414084.png" alt="image-20200615151414084"></p><p>代码中搞了一个<code>EXCLUSIVE_MASK</code>，是2^16-1。</p><p>通过和state求&amp;可以拿到低16位的数据。</p><p>通过和state&gt;&gt;16位拿到高16位的读锁数据。</p><h2><span id="xie-suo-de-dai-ma"> 写锁的代码</span><a href="#xie-suo-de-dai-ma" class="header-anchor">#</a></h2><p>了解了概念之后我们再来看代码，先看<strong>写锁</strong>的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero  and owner is a different thread, fail.   //读锁非0，写锁非0，或线程非当前，返回失败</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only happen if count is already nonzero.)         // 数据超max，返回失败（max是2^16-1，因为status的int劈成两半一半给读，一半给写了）</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if   // 其他情况则可以获取锁并设置占有线程</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();                                                                                <span class="comment">// 获得锁的个数</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);                                                              <span class="comment">// 获取写锁的个数</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;                                                                                              <span class="comment">// 已经有线程获取锁了</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())         <span class="comment">// 写锁为0，即读锁不为0. 或 非当前线程持有写锁，就返回失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)              <span class="comment">// 超过2^16-1个写线程最大数量，失败</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// w=0，且当前线程需要阻塞，返回失败false（非公平writerShouldBlock永远返回false不用阻塞，公平锁看队列有没有排队，有就true排队）</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||                                                                  </span><br><span class="line">                !compareAndSetState(c, c + acquires))                                   <span class="comment">// 否则CAS增加写线程数量失败也返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);                                             <span class="comment">// c=0,w=0 或者 c&gt;0,w&gt;0重入，设置当前线程占有，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c（这个数可能很大，是由高16位和低16位组合起来的），然后再通过c来获取写锁的个数w。：<ul><li>因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; <code>return c &amp; EXCLUSIVE_MASK;</code>这个EXCLUSIVE_MASK是2^16-1，是全1 ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li></ul></li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了任何锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有写锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果本轮写后，写入锁的地位数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当前写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；（非公平writerShouldBlock永远返回false，公平锁看队列有没有排队，有就true）如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>后面的添加队列阻塞和唤醒与ReentrantLock相同。</p><p>上面可以看到<strong>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取</strong>，原因在于：<strong>必须确保写锁的操作对读锁可见</strong>，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，<strong>只有等待其他读线程都释放了读锁，写锁才能被当前线程获取</strong>，而<strong>写锁一旦被获取，则其他读写线程的后续访问均被阻塞</strong>。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><h2><span id="jie-zhao-shi-du-suo-de-dai-ma"> 接着是读锁的代码：</span><a href="#jie-zhao-shi-du-suo-de-dai-ma" class="header-anchor">#</a></h2><p>读锁的lock()方法调用了这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 上来先去try获取共享锁一下</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是获取一次共享锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.                 写锁再用，fail</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for                         写锁没用，就直接去看队列是否应该排队阻塞。不用的话直接CAS改读锁数量。</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant           没有检查重入，推迟到后面的全版本doAcquireShared中</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread                           如果写锁占有，或者CAS失败，就去doAcquireShared里面轮循加锁</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;                                                                                 <span class="comment">// 其他线程占用写锁，返回-1</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;                                                 </span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>获取一次读锁失败，进入下面进入队列阻塞，循环获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);   <span class="comment">// 添加节点</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();  </span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);              <span class="comment">// 前一个是头，获取一次</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;                                                       <span class="comment">// 成功了</span></span><br><span class="line">                        setHeadAndPropagate(node, r);      <span class="comment">// 从前往后叫醒所有的节点</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC                        // 删掉头</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)                                          <span class="comment">// 响应park时候的interrupt</span></span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;                                                           <span class="comment">// 返回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 前一个SIGNAL了才true阻塞，否则删掉前面所有CANCLE的，CAS修改pre的状态为SIGNAL，返回false再来一轮阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;      </span><br><span class="line">                    parkAndCheckInterrupt())   <span class="comment">// 阻塞</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615164128985.png" alt="image-20200615164128985"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。</p><p>根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。</p><p>而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h1><span id="aqs-de-conditionobject-await-signal"> AQS的ConditionObject、await/signal</span><a href="#aqs-de-conditionobject-await-signal" class="header-anchor">#</a></h1><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，它实现了<code>java.util.concurrent.locks.Condition</code>接口。（下文的Condition都指的是ConditionObject）</p><p>Condition的实现，主要包括：<strong>等待队列、等待和通知</strong>。</p><p>Condition使用了一个<strong>等待队列</strong>来记录wait的节点们（和之前的同步队列不是一个）</p><h2><span id="api-shi-li"> API示例</span><a href="#api-shi-li" class="header-anchor">#</a></h2><p><code>lock.newCondition();</code>给一个锁创建一个条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用lock构造condition</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition fullCondition = lock.newCondition();</span><br><span class="line">Condition emptyCondition  = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();    <span class="comment">// 先获取锁</span></span><br><span class="line"><span class="keyword">if</span>(queue.isEmpty())&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 通知因队列满而阻塞到fullCondition上的线程唤起</span></span><br><span class="line">fullCondition.signalAll();   <span class="comment">// 唤醒等待在Condition上所有的线程。</span></span><br><span class="line">                <span class="comment">// 队列空的condition开始挂起</span></span><br><span class="line">emptyCondition.await();  <span class="comment">// 当前线程进入等待状态，直到被通知（signal）或者被中断时，当前线程进入运行状态，从await()返回；</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// take元素</span></span><br><span class="line">T obj = queue.remove();</span><br><span class="line"><span class="comment">//通知因队列满而阻塞到fullCondition上的线程唤起</span></span><br><span class="line">fullCondition.signalAll();</span><br><span class="line">lock.unlock();   <span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="condition-de-deng-dai-dui-lie"> Condition的等待队列</span><a href="#condition-de-deng-dai-dui-lie" class="header-anchor">#</a></h2><p>FIFO的队列，每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程。并不复杂。</p><p>如果一个线程调用了**Condition.await()**方法，那么该线程将会：</p><ul><li><strong>构造节点加入等待队列</strong>（没有CAS设置尾巴，因为前面必然获取到锁了）</li><li><strong>释放当前线程的同步状态，唤醒后继节点，且当前线程进入WATING等待状态</strong></li><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615174451189.png" alt="image-20200615174451189"></p><p>节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;  <span class="comment">// 头</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;  <span class="comment">// 尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加waiter到队列</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;  </span><br><span class="line">            <span class="comment">// 整理尾巴,删掉CANCLE的</span></span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构造一个节点，续到tail后面即可</span></span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2><span id="await-deng-dai"> await等待</span><a href="#await-deng-dai" class="header-anchor">#</a></h2><p>需要先lock.lock()  然后 condition.await()，await会释放掉锁，线程进入等待队列，状态变成Wating。</p><p>下次唤醒后再重新获取锁（不一定能获取到，获取不到再次for死循环获取进入同步队列，park）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// await核心API</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="comment">// 添加一个尾巴</span></span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="comment">// 释放当前线程节点的同步状态，唤醒后继节点；</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 线程进入等待状态；</span></span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;   <span class="comment">// 线程被【唤醒后】，从while循环中退出，继续执行后面的方法去获取锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用acquireQueued尝试获取同步状态；（ReentrantLock也使用了这个方法，就是获取一次，然后for死循环获取，或者park等待）</span></span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p><code>await</code>具体执行流程如下：</p><ul><li>调用addConditionWaiter将当前线程加入等待队列；</li><li>调用fullRelease释放当前线程节点的同步状态，唤醒后继节点；</li><li>线程进入等待状态；</li><li>线程被唤醒后，从while循环中退出，调用acquireQueued尝试获取同步状态；</li><li>同步状态获取成功后，线程从await方法返回。</li></ul><p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。（获取锁的时候，同步队列的一个header必然释放了。然后等待队列尾巴新增加了一个Node，线程是当前线程。但从内容上讲几乎相当于移动。）</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615184534526.png" alt="image-20200615184534526"></p><h2><span id="signal-huan-xing"> signal唤醒</span><a href="#signal-huan-xing" class="header-anchor">#</a></h2><p>调用Condition的signal()方法将会唤醒再等待队列中的首节点，该节点也是到目前为止等待时间最长的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">// 当前运行线程t1是否是获取了锁的线程，如果不是抛出异常IllegalMonitorStateException</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)   <span class="comment">// 取得等待队列的头结点，头结点不为空执行doSignal</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step1：前置检查，判断当前线程是否是获取了锁的线程，如果不是抛出异常IllegalMonitorStateException，否则，执行step2；</p><p>step2：取得等待队列的头结点，头结点不为空执行doSignal，否则，signal结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="comment">// 调用transferForSignal将节点从等待队列的first移动到同步队列.将该节点从等待队列删除。</span></span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>整个doSignal完成了这两个操作：调用transferForSignal将节点从等待队列移动到同步队列，并且，将该节点从等待队列删除。</p><p>怎么transfer的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment"> * Returns true if successful.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment"> * cancelled before signal)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))            <span class="comment">//CAS修改CONDITION</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p = enq(node);                    <span class="comment">// 这里和上面ReentrantLock的enq方法是一样的，初始化队列，或者加入同步队列尾巴，for死循环去续尾巴成功为止，没有park</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);   <span class="comment">// 到达这里unpark去唤醒这个节点里面的线程t2。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>step1：将节点waitStatus设置为0，设置成功执行step2，否则(CANCLE)返回false；</li><li>step2：调用enq方法将该节点加入同步队列；</li><li>step3：使用LockSuppor.unpark()方法唤醒该节点的线程。</li></ul><p>再次回顾我们AQS的enq方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary  node节点进行一次入队，需要的时候进行初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;   <span class="comment">// 拿出尾</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize   没有尾，说明是第一次，需要初始化一个空的head再往后排</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))   <span class="comment">// head使用CAS初始化了一个虚拟的傀儡节点！这里是重点！！！！此时多线程的锁会竞争</span></span><br><span class="line">                    tail = head; <span class="comment">// 初始化首尾都是同一个，然后重新来for一次添加尾</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//第二轮以上for，初始化过，往最后排</span></span><br><span class="line">                node.prev = t;  <span class="comment">// 当前节点的前一个设置为前尾</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;   <span class="comment">// CAS去看前尾变化没，没变化就变更新尾，此时多线程的锁会竞争</span></span><br><span class="line">                    t.next = node;   <span class="comment">// 前尾的next指向新尾，尾巴成功修改</span></span><br><span class="line">                    <span class="keyword">return</span> t;   <span class="comment">// CAS续成功才会返回，否则永远来续-----------------------唯一出口</span></span><br><span class="line">                &#125;<span class="comment">// CAS失败，说明前尾变更，被别的线程抢先续尾了，重新来入队续尾</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个signal系列方法将线程从等待队列移动到同步队列可以总结为下图：</p><p>就是把等待队列（wait队列）的第一个节点transfer，通过enq方法丢到同步队列的tail上，更新tail。然后再unpark这个tail里面的线程。</p><p>被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。<br>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615184552315.png" alt="image-20200615184552315"></p><p>Condition的signalAll()方法，将等待队列中的所有节点全部唤醒，相当于将等待队列中的每一个节点都执行一次signal()。</p><h1><span id="can-kao"> 参考</span><a href="#can-kao" class="header-anchor">#</a></h1><blockquote><p>《Java并发编程的艺术》</p><p><a href="https://www.cnblogs.com/tuyang1129/p/12670014.html" target="_blank" rel="noopener">https://www.cnblogs.com/tuyang1129/p/12670014.html</a></p><p>美团技术公众号的共享锁部分</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#suo-de-qian-shi-jin-sheng&quot;&gt;锁的前世今生&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#le-guan-suo-yu-bei-
      
    
    </summary>
    
    
      <category term="多线程" scheme="https://blog.sofunnyai.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://blog.sofunnyai.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="https://blog.sofunnyai.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq</title>
    <link href="https://blog.sofunnyai.com/article/rocketmq-1.html"/>
    <id>https://blog.sofunnyai.com/article/rocketmq-1.html</id>
    <published>2018-07-03T05:02:08.000Z</published>
    <updated>2020-08-04T10:17:08.659Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#rocketmq-jian-jie">RocketMQ简介</a><ul><li><a href="#he-xin-gai-nian">核心概念：</a><ul><li><a href="#zhu-yao-you-producer-broker-consumer-san-bu-fen-zu-cheng">主要由 Producer、Broker、Consumer 三部分组成：</a></li></ul></li><li><a href="#liang-chong-xiao-fei-fang-shi-push-pull">两种消费方式（push/pull）：</a><ul><li><a href="#la-qu-shi-xiao-fei-pull-consumer">拉取式消费（Pull Consumer）</a></li></ul></li><li><a href="#tui-dong-shi-xiao-fei-push-consumer">推动式消费（Push Consumer）</a></li><li><a href="#shun-xu">顺序:</a><ul><li><a href="#pu-tong-shun-xu-xiao-xi-normal-ordered-message">普通顺序消息（Normal Ordered Message）</a></li><li><a href="#yan-ge-shun-xu-xiao-xi-strictly-ordered-message">严格顺序消息（Strictly Ordered Message）</a></li></ul></li><li><a href="#xiao-xi-msg-te-dian">消息Msg特点：</a><ul><li><a href="#xiao-xi-message">消息（Message）</a></li><li><a href="#biao-qian-tag">标签（Tag）</a></li></ul></li><li><a href="#zu-group-de-gai-nian">组group的概念：</a></li></ul></li><li><a href="#bu-shu-jia-gou">部署架构</a></li><li><a href="#te-xing">特性</a><ul><li><a href="#producer-de-te-xing">Producer的特性</a><ul><li><a href="#fa-song-fang-shi">发送方式</a></li><li><a href="#fa-song-jie-guo-sendstatus">发送结果SendStatus</a></li></ul></li><li><a href="#xiao-xi-lei-xing">消息类型</a><ul><li><a href="#pu-tong-xiao-xi"><strong>普通消息</strong>：</a></li><li><a href="#ding-shi-xiao-xi"><strong>定时消息</strong>：</a></li><li><a href="#shun-xu-xiao-xi"><strong>顺序消息</strong>：</a></li><li><a href="#shi-wu-xiao-xi"><strong>事务消息</strong>：</a></li></ul></li><li><a href="#jie-shou-te-xing">接收特性</a><ul><li><a href="#xiao-xi-mi-deng-xing">消息幂等性</a></li><li><a href="#xiao-xi-guo-lu">消息过滤：</a></li><li><a href="#push-he-pull"><strong>PUSH和PULL：</strong></a></li></ul></li></ul></li><li><a href="#gao-xing-neng">高性能</a><ul><li><a href="#cun-chu-jia-gou-de-gao-xing-neng-commitlog-ding-chang-nei-cun-ying-she-consumequeue-dui-topic-de-huan-cun-ye-shun-xu-du-qu">存储架构的高性能：CommitLog定长内存映射+ConsumeQueue对Topic的缓存页顺序读取</a></li><li><a href="#ye-huan-cun-yu-nei-cun-ying-she">页缓存与内存映射</a></li><li><a href="#shua-pan-ji-zhi">刷盘机制</a></li><li><a href="#xiao-xi-zhu-cong-fu-zhi-bao-zheng-gao-ke-yong">消息主从复制保证高可用</a><ul><li><a href="#tong-bu-fu-zhi-he-yi-bu-fu-zhi">同步复制和异步复制</a></li></ul></li></ul></li><li><a href="#fu-zai-jun-heng">负载均衡</a><ul><li><a href="#topic-he-queue">Topic和Queue</a></li></ul></li><li><a href="#yuan-dai-ma-liu-cheng">源代码流程</a><ul><li><a href="#fa-song-pu-tong-xiao-xi-de-liu-cheng">发送普通消息的流程</a></li></ul></li></ul><!-- tocstop --></div><!--下面是latex渲染框架katex样式所需的css，不使用latex的话可以删掉--><link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet"><h1><span id="rocketmq-jian-jie"> RocketMQ简介</span><a href="#rocketmq-jian-jie" class="header-anchor">#</a></h1><p>**消息队列：**一句话解释消息队列就是提供了包含远程通讯、发送消息、存储消息、消费消息等功能的一个中间件。可以使得我们的发送方和接受方进行解耦、异步通讯。一般用在系统解耦、广播、流量销峰、分布式事务、异步消息传递等场景。</p><p>RocketMQ没有完全遵守JMS标准，JMS标准可能在吞吐或者设计上有一些不太好的要求，导致了性能不及预期。RocketMQ进行了修改。</p><h2><span id="he-xin-gai-nian"> 核心概念：</span><a href="#he-xin-gai-nian" class="header-anchor">#</a></h2><p><em>下面这块搬运总结自官方readme，只为快速查阅</em></p><h3><span id="zhu-yao-you-producer-broker-consumer-san-bu-fen-zu-cheng"> 主要由 Producer、Broker、Consumer 三部分组成：</span><a href="#zhu-yao-you-producer-broker-consumer-san-bu-fen-zu-cheng" class="header-anchor">#</a></h3><ul><li>其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。</li></ul><p>其他组件：</p><ul><li><p>Broker：</p><ul><li>在实际部署过程中对应一台服务器，每个 <strong>Broker 可以存储多个Topic的消息</strong>，<strong>每个Topic的消息也可以分片存储于不同的 Broker。</strong></li><li>消息中转角色，负责<strong>存储</strong>消息、<strong>转发</strong>消息。代理服务器在RocketMQ系统中负责<strong>接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备</strong>。代理服务器也存储消息相关的元数据，包括消费者组、<strong>消费进度偏移</strong>和主题和<strong>队列消息</strong>等。</li></ul></li><li><p>名称服务（Name Server）</p></li><li><p>名称服务充当<strong>路由消息的提供者</strong>。生产者或消费者能够<strong>通过名字服务查找</strong>各<strong>主题相应的Broker IP</strong>列表。<strong>多个Namesrv实例组成集群，但相互独立，没有信息交换。</strong> （类似与FastDFS的Tracker，或者SpringCloud的注册中心）</p></li><li><p>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p></li></ul><h2><span id="liang-chong-xiao-fei-fang-shi-push-pull"> 两种消费方式（push/pull）：</span><a href="#liang-chong-xiao-fei-fang-shi-push-pull" class="header-anchor">#</a></h2><h3><span id="la-qu-shi-xiao-fei-pull-consumer"> 拉取式消费（Pull Consumer）</span><a href="#la-qu-shi-xiao-fei-pull-consumer" class="header-anchor">#</a></h3><p>Consumer消费的一种类型，应用通常主动调用<strong>Consumer的拉消息</strong>方法**从Broker服务器拉消息、主动权由应用控制。**一旦获取了批量消息，应用就会启动消费过程。</p><h2><span id="tui-dong-shi-xiao-fei-push-consumer"> 推动式消费（Push Consumer）</span><a href="#tui-dong-shi-xiao-fei-push-consumer" class="header-anchor">#</a></h2><p>Consumer消费的一种类型，该模式下<strong>Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</strong></p><h2><span id="shun-xu"> 顺序:</span><a href="#shun-xu" class="header-anchor">#</a></h2><h3><span id="pu-tong-shun-xu-xiao-xi-normal-ordered-message"> 普通顺序消息（Normal Ordered Message）</span><a href="#pu-tong-shun-xu-xiao-xi-normal-ordered-message" class="header-anchor">#</a></h3><p>普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p><h3><span id="yan-ge-shun-xu-xiao-xi-strictly-ordered-message"> 严格顺序消息（Strictly Ordered Message）</span><a href="#yan-ge-shun-xu-xiao-xi-strictly-ordered-message" class="header-anchor">#</a></h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p><h2><span id="xiao-xi-msg-te-dian"> 消息Msg特点：</span><a href="#xiao-xi-msg-te-dian" class="header-anchor">#</a></h2><h3><span id="xiao-xi-message"> 消息（Message）</span><a href="#xiao-xi-message" class="header-anchor">#</a></h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统<strong>提供了通过Message ID和Key查询消息的功能。</strong></p><h3><span id="biao-qian-tag"> 标签（Tag）</span><a href="#biao-qian-tag" class="header-anchor">#</a></h3><p>为消息设置的标志，用于<strong>同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者<strong>可以根据Tag实现对不同子主题的不同消费逻辑</strong>，实现更好的扩展性。</p><h2><span id="zu-group-de-gai-nian"> 组group的概念：</span><a href="#zu-group-de-gai-nian" class="header-anchor">#</a></h2><p>生产者、消费者都有group的概念。</p><p>一个topic下面可以有多个组生产组、消费组，可以根据组进行业务隔离、消息过滤（MessageFilter）</p><p>出现问题也可以根据组名去排查</p><h1><span id="bu-shu-jia-gou"> 部署架构</span><a href="#bu-shu-jia-gou" class="header-anchor">#</a></h1><ul><li>有2m2s，两主两从的集群模式。配置文件有异步的<code>2m-2s-async</code>和同步的<code>2m-2s-sync</code></li><li>2m-noslave，2主没有从模式</li></ul><p>一个经典的RocketMQ的网络部署图：</p><p>有一个NameServer集群用于处理Broker的IP寻址等命名服务</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200803130631460.png" alt="image-20200803130631460"></p><ul><li><p>如client</p></li><li><p>remoting是远程服务，如netty</p></li><li><p>Producer和Cunsomer相对于Broker都是Client</p></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200803130341795.png" alt="image-20200803130341795"></p><h1><span id="te-xing"> 特性</span><a href="#te-xing" class="header-anchor">#</a></h1><h2><span id="producer-de-te-xing"> Producer的特性</span><a href="#producer-de-te-xing" class="header-anchor">#</a></h2><h3><span id="fa-song-fang-shi"> 发送方式</span><a href="#fa-song-fang-shi" class="header-anchor">#</a></h3><h4><span id="sync"> sync：</span><a href="#sync" class="header-anchor">#</a></h4><p>同步发送，需要一个响应</p><h4><span id="async"> async：</span><a href="#async" class="header-anchor">#</a></h4><p>异步发送，给一个callback，发送完毕会来回调。可以指定timeout。</p><h4><span id="oentway"> oentway：</span><a href="#oentway" class="header-anchor">#</a></h4><p>发出去后不管，直接返回。如日志等不重要的数据。</p><h3><span id="fa-song-jie-guo-sendstatus"> 发送结果SendStatus</span><a href="#fa-song-jie-guo-sendstatus" class="header-anchor">#</a></h3><p><code>org.apache.rocketmq.client.producer.SendStatus</code></p><ul><li><strong>SEND-OK</strong>：消息发送成功</li><li><strong>FLUSH_DISK_TIMEOUT</strong>:消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失.（消息在broker内存中）</li><li><strong>FLUSH_SLAVE_TIMEOUT</strong>:消息发送成功，但是服务器同步到Slave时超时，消息已经进入务器队列，只有此时服务器宕机，消息才会丢</li><li><strong>SLAVE_NOT_AVAILABLE</strong>:消息发送成功，但是此时slave不可用，消息已经进入服务器队列，只有此时服务器宕机消息才会丢</li></ul><p><strong>消息过滤：</strong></p><p>给同一个topic发送的时候可以带着tag，</p><h2><span id="xiao-xi-lei-xing"> 消息类型</span><a href="#xiao-xi-lei-xing" class="header-anchor">#</a></h2><h3><span id="pu-tong-xiao-xi"> <strong>普通消息</strong>：</span><a href="#pu-tong-xiao-xi" class="header-anchor">#</a></h3><h3><span id="ding-shi-xiao-xi"> <strong>定时消息</strong>：</span><a href="#ding-shi-xiao-xi" class="header-anchor">#</a></h3><p>发送到broker之后不能立刻消费，需要特定的时间之后才可以消费。如和第三方对接的回调延时。</p><p>原理和普通消息一样，只是多了一个定时参数。由服务器去决定。</p><h3><span id="shun-xu-xiao-xi"> <strong>顺序消息</strong>：</span><a href="#shun-xu-xiao-xi" class="header-anchor">#</a></h3><p>强一致性的先进先出，普通消息只能每个queue里面先进先出。</p><ul><li>底层原理：一个订单下面的不同状态消息发送到同一个queue里面，就能保证严格个先进先出。需要实现<code>MessageQueueSelector</code>，</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804163215333.png" alt="image-20200804163215333"></p><h3><span id="shi-wu-xiao-xi"> <strong>事务消息</strong>：</span><a href="#shi-wu-xiao-xi" class="header-anchor">#</a></h3><p>经典的两阶段提交、或者三阶段提交：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804164014890.png" alt="image-20200804164014890"></p><p>整个流程：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804164117815.png" alt="image-20200804164117815"></p><p><strong>官方说明：</strong></p><blockquote><p><a href="http://rocketmq.apache.org/rocketmq/the-design-of-transactional-message/" target="_blank" rel="noopener">http://rocketmq.apache.org/rocketmq/the-design-of-transactional-message/</a></p></blockquote><p><img src="https://gitee.com/radio/pics/raw/master/img/transaction-execute-flow.png" alt="img"></p><p>官方描述的整个过程</p><ol><li>生产者将一<strong>半消息</strong>(HalfMessage，其实是message里面设置了一个属性，transaction=true)发送到MQ服务器。</li><li>发送成功一半消息后，执行本地事务。</li><li>根据本地事务结果将提交或回滚消息发送到MQ Server。</li><li>如果在本地事务执行过程中缺少提交/回退消息或生产者处于等待状态，MQ服务器将向同一组中的每个生产者发送检查消息，以获取交易状态。</li><li>生产者根据本地事务状态回复提交/回退消息。</li><li>提交的消息将传递给使用者，但是回滚的消息将被MQ服务器丢弃。</li></ol><p><img src="https://gitee.com/radio/pics/raw/master/img/transaction-outline-design.png" alt="screenshot"></p><p>为了掩盖存储的基础实现，所有事务性消息操作都集中在事务服务接口上。 RocketMQ提供了自己的存储系统的默认实现，我们使用事务桥来实现事务存储逻辑，而不是直接修改RocketMQ的存储层。</p><p><strong>要注意noslave模式是不支持事务消息的。</strong></p><h2><span id="jie-shou-te-xing"> 接收特性</span><a href="#jie-shou-te-xing" class="header-anchor">#</a></h2><h3><span id="xiao-xi-mi-deng-xing"> 消息幂等性</span><a href="#xiao-xi-mi-deng-xing" class="header-anchor">#</a></h3><p>rocketMQ没有实现消息去重，需要业务自己实现。当消费方因为网络闪断没有及时返回ACK消息，可能会导致重复消费。</p><p>终极解决方案是给message的key用redis incr实现一个全局唯一标识。然后消费的时候搞一个redis set看看有没有消费过，没有再使用。</p><h3><span id="xiao-xi-guo-lu"> 消息过滤：</span><a href="#xiao-xi-guo-lu" class="header-anchor">#</a></h3><p>订阅的时候实现一个MesageSelector，可以bySQL，使用类SQL语句进行过滤如<code>MesageSelector.bySQL(&quot;TAGS is not null and TAGS in('TAGA', 'TAGB')&quot;)</code></p><p>也可以subscribe的时候自己实现一个MessageFilter接口，有一个Match方法，可以根据msg信息进行过滤。</p><h3><span id="push-he-pull"> <strong>PUSH和PULL：</strong></span><a href="#push-he-pull" class="header-anchor">#</a></h3><p>PULL是由业务系统自己去决定何时进行去拉取消息。<code>DefaultMQPullConsumer</code></p><p>PUSH方式消费，需要注册一个消息监听器。在start方法中启动了一个线程池去死循环在里面长轮询take拉取消息。<code>DefaultMQPushConsumer</code></p><p>也就是底层核心都是使用pull实现的，调用broker。可以简化应用使用MQ的方式。</p><p>源码目录</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200803130440835.png" alt="image-20200803130440835"></p><h1><span id="gao-xing-neng"> 高性能</span><a href="#gao-xing-neng" class="header-anchor">#</a></h1><p>一般来说，MQ作为一个中间件需要有一个持久化过程来保证高可用，以防万一宕机可以从持久化文件恢复数据。（纯内存型的ZeroMQ等除外）。</p><ul><li>ActiveMQ可以使用JDBC持久化到数据库，也可以使用NFS进行持久化来保证高可用。</li><li>Redis和RockDB使用KV数据库的方式进行持久化</li><li>RocketMQ、RabbitMQ、Kafka使用文件系统持久化，磁盘坏了就挂了。</li></ul><h2><span id="cun-chu-jia-gou-de-gao-xing-neng-commitlog-ding-chang-nei-cun-ying-she-consumequeue-dui-topic-de-huan-cun-ye-shun-xu-du-qu"> 存储架构的高性能：CommitLog定长内存映射+ConsumeQueue对Topic的缓存页顺序读取</span><a href="#cun-chu-jia-gou-de-gao-xing-neng-commitlog-ding-chang-nei-cun-ying-she-consumequeue-dui-topic-de-huan-cun-ye-shun-xu-du-qu" class="header-anchor">#</a></h2><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804122939317.png" alt="image-20200804122939317"></p><p>RocketMQ的消息存储架构如上图所示，可以看到主要由三个跟消息存储相关的文件构成。</p><ul><li><p><strong>CommitLog</strong>：<strong>消息及元数据的存储主体</strong>。消息内容<strong>不是定长</strong>的，同时单个文件大小默认1G，文件名长度为20位，左边补零，剩余为起始偏移量。比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当第一个文件满了，再写入下一个文件。</p></li><li><p>-----存储消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commitlog&#x2F;</span><br><span class="line">├── 00000000000000000000</span><br><span class="line">└── 00000000001073741824</span><br></pre></td></tr></table></figure></li><li><p><strong>ConsumeQueue</strong>：**消息消费队列。<strong>RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要</strong>根据topic在commitlog文件中进行检索消息，效率将会非常低效。**ConsumeQueue（<strong>逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset、消息大小size和消息Tag的HashCode值。</strong> **所以ConsumeQueue文件可以看成是基于topic的CommitLog索引文件。**ConsumeQueue文件夹的组织方式如下：<strong>topic/queue/file</strong>三层组织结构。而ConsumeQueue存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。与Commitlog一样，<strong>ConsumeQueue文件采取了定长设计，单个文件由30W个条目组成</strong>，每一个条目共20个字节，分别为8字节的CommitLog物理偏移量、4字节的消息长度、8字节tag hashcode，<strong>Comsumer可以像数组一样随机访问每一个条目</strong>，每个ConsumeQueue文件大小约5.72M。</p></li><li><p>-----作为Topic的索引去CommieLog拿数据，里面是CommitLog的偏移量，消费的时候使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">consumequeue&#x2F;</span><br><span class="line">└── TopicTest</span><br><span class="line">    ├── 0</span><br><span class="line">    │   └── 00000000000000000000</span><br><span class="line">    ├── 1</span><br><span class="line">    │   └── 00000000000000000000</span><br><span class="line">    ├── 2</span><br><span class="line">    │   └── 00000000000000000000</span><br><span class="line">    └── 3</span><br><span class="line">        └── 00000000000000000000</span><br></pre></td></tr></table></figure></li><li><p><strong>IndexFile：</strong>（索引文件）**提供了一种可以通过key或时间区间来查询消息的方法。**Index文件的存储位置是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>O</mi><mi>M</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">HOME /store/index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">/</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathrm">/</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">x</span></span></span></span>{fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存2000W个索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index&#x2F;</span><br><span class="line">└── 20190804112308158</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804181344806.png" alt="image-20200804181344806"></p><p>index文件里面存放的每一个节点如最上面所示，是定长的。有<code>keyHash</code>-<code>CommitLog Offset</code>-</p><h2><span id="ye-huan-cun-yu-nei-cun-ying-she"> 页缓存与内存映射</span><a href="#ye-huan-cun-yu-nei-cun-ying-she" class="header-anchor">#</a></h2><ul><li><strong>页缓存（PageCache）是OS对文件的缓存，用于加速对文件的读写。<strong>一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于-OS使用</strong>PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。</strong><ul><li>对于数据的<strong>写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。</strong></li><li>对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</li></ul></li><li>在RocketMQ中，**ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，**即使在有消息堆积情况下也不会影响性能。</li><li>而对于CommitLog消息存储的日志数据文件来说，读取消息内容时会产生较多的<strong>随机访问读取</strong>，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</li><li>另外，<strong>RocketMQ主要通过MappedByteBuffer对文件进行读写操作。<strong>其中，<strong>利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中</strong>（这种Mmap的方式</strong>减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销</strong>），将<strong>对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率</strong></li><li>（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</li></ul><table><thead><tr><th></th><th><strong>顺序读写</strong></th><th><strong>随机读写</strong></th></tr></thead><tbody><tr><td><strong>文件数目</strong></td><td>读取一个大文件</td><td>读取多个小文件</td></tr><tr><td></td><td>**比较：**明显顺序读写只读取一个大文件，耗时更少。而随机读写需要打开多个文件，写进行多次的训导和旋转延迟，标绿远低于顺序读写</td><td></td></tr><tr><td><strong>文件预读</strong></td><td>顺序读写时磁盘会预读文件，即在读取的起始地址连续读取多个页面，若被预读的页面被使用，则无需再去读取</td><td>由于数据不在一起，无法预读</td></tr><tr><td></td><td>**比较：**在大并发的情况下，磁盘预读能够免去大量的读操作，处理速度肯定更快</td><td></td></tr><tr><td><strong>系统的overhead</strong></td><td>只需要找到一个文件，并对这个文件进行属性和权限的检查</td><td>需要找到多个文件，并对每个文件进行属性和权限检查</td></tr><tr><td></td><td>**比较：**只寻找一个文件，并确认属性和权限，肯定优于处理多个文件</td><td></td></tr><tr><td><strong>写入数据</strong></td><td>写入新文件时，需要寻找磁盘可用空间</td><td>写入新文件时，需要寻找磁盘可用空间。但由于一个文件的存储量更小，这个操作触发频率更多</td></tr><tr><td></td><td>**比较：**顺序读写创建新文件，只需要创建一个大文件就可以用很久，而随机读写可能频繁创建文件。创建文件时需要进行寻找磁盘可用空间等一些列操作，肯定更加耗时</td><td></td></tr></tbody></table><h2><span id="shua-pan-ji-zhi"> 刷盘机制</span><a href="#shua-pan-ji-zhi" class="header-anchor">#</a></h2><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804130631825.png" alt="image-20200804130631825"></p><ul><li><p>同步刷盘：如上图左边所示，当消息真正持久化至磁盘后，RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。<strong>同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用。</strong></p></li><li><p>异步刷盘：能够<strong>充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。<strong>消息刷盘采用</strong>后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</strong></p></li><li><pre class="highlight"><code class="properties"><span class="hljs-comment"># 刷盘方式ASYNC_FLUSH/SYNC_FLUSH</span><span class="hljs-attr">flushDiskType</span>=<span class="hljs-string">ASYNC_FLUSH</span><span class="hljs-attr"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">|              | ** 同步刷盘**                                                | **异步刷盘**                                                 |</span><br><span class="line">| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |</span><br><span class="line">| **消息情况** | 在返回写成功状态时，消息已经被写入磁盘中。即消息被写入内存的PAGECACHE 中后，立刻通知刷新线程刷盘，等待刷盘完成，才会唤醒等待的线程并返回成功状态 | 在返回写成功状态时，消息可能只是被写入内存的 PAGECACHE 中。当内存的消息量积累到一定程度时，触发写操作快速写入 |</span><br><span class="line">| **性能**     | 需要等待刷盘才能返回结果                                     | 消息写入内存后立刻返回结果，吞吐量更高                       |</span><br><span class="line">| **可靠性**   | 可以保持MQ的消息状态和生产者&#x2F;消费者的消息状态一致            | Master宕机，磁盘损坏的情况下，会丢失少量的消息, 导致MQ的消息状态和生产者&#x2F;消费者的消息状态不一致 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeroCopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 高可用</span><br><span class="line"></span><br><span class="line">##  NameServer 高可用</span><br><span class="line"></span><br><span class="line">由于 NameServer 节点是无状态的，只是保存了一个BrokerServer的地址，相当于注册中心。且各个节点直接的数据是一致的，故存在多个 NameServer 节点的情况下，部分 NameServer 不可用也可以保证 MQ 服务正常运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## BrokerServer 高可用</span><br><span class="line"></span><br><span class="line">- RocketMQ是通过 Master 和 Slave 的配合达到 BrokerServer 模块的高可用性的</span><br><span class="line">- 一个 Master 可以配置多个 Slave，同时也支持配置多个 Master-Slave 组。如2m2s</span><br><span class="line"></span><br><span class="line">**当其中一个 Master 出现问题时：**</span><br><span class="line"></span><br><span class="line">- 由于Slave只负责读，当 Master 不可用，它对应的 Slave 仍能保证消息被正常消费</span><br><span class="line">- 由于配置多组 Master-Slave 组，其他的 Master-Slave 组也会保证消息的正常发送和消费</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 消息消费高可用</span><br><span class="line"></span><br><span class="line">Consumer 的高可用是依赖于 Master-Slave 配置的，由于 Master 能够支持读写消息，Slave 支持读消息，当 Master 不可用或繁忙时， Consumer 会被自动切换到从 Slave 读取(自动切换，无需配置)。故当 Master 的机器故障后，消息仍可从 Slave 中被消费</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 消息发送高可用</span><br><span class="line"></span><br><span class="line">在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组，就是一个master和一堆slave组成一组。另一个master和一堆slave组成另外一组。2m2s就是2组）。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;properties</span><br><span class="line">#broker名字，名字可重复,为了管理,每个master起一个名字,他的slave同他,eg:Amaster叫broker-a,他的slave也叫broker-a</span><br><span class="line">brokerName&#x3D;broker-a</span><br><span class="line">#0 表示 Master，&gt;0 表示 Slave</span><br><span class="line">brokerId&#x3D;0</span><br></pre></td></tr></table></figure></span></code></pre></li></ul><p>这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ开源版本目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前节点角色，重要</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br></pre></td></tr></table></figure><p><img src="../../../../home/tree/.config/Typora/typora-user-images/image-20200804131932891.png" alt="image-20200804131932891"></p><h2><span id="xiao-xi-zhu-cong-fu-zhi-bao-zheng-gao-ke-yong"> 消息主从复制保证高可用</span><a href="#xiao-xi-zhu-cong-fu-zhi-bao-zheng-gao-ke-yong" class="header-anchor">#</a></h2><h3><span id="tong-bu-fu-zhi-he-yi-bu-fu-zhi"> 同步复制和异步复制</span><a href="#tong-bu-fu-zhi-he-yi-bu-fu-zhi" class="header-anchor">#</a></h3><p>若一个 Broker 组有一个 Master 和 Slave，消息需要从 Master 复制到 Slave 上，有同步复制和异步复制两种方式</p><table><thead><tr><th></th><th><strong>同步复制</strong></th><th><strong>异步复制</strong></th></tr></thead><tbody><tr><td><strong>概念</strong></td><td>即等 Master 和 Slave 均写成功后才反馈给客户端写成功状态</td><td>只要 Master 写成功，就反馈客户端写成功状态</td></tr><tr><td><strong>可靠性</strong></td><td>可靠性高，若 Master 出现故障，Slave 上有全部的备份数据，容易恢复</td><td>若 Master 出现故障，可能存在一些数据还没来得及写入 Slave，可能会丢失</td></tr><tr><td><strong>效率</strong></td><td>由于是同步复制，会增加数据写入延迟，降低系统吞吐量</td><td>由于只要写入 Master 即可，故数据写入延迟较低，吞吐量较高</td></tr></tbody></table><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前节点角色，重要</span></span><br><span class="line"><span class="comment"># 异步复制</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="comment"># SYNC_MASTER：同步复制</span></span><br><span class="line"><span class="comment"># SLAVE：表明当前是从节点，无需配置 brokerRole</span></span><br></pre></td></tr></table></figure><p>一般在实际应用中，由于同步刷盘方式会频繁触发磁盘写操作，明显降低性能，故通常配置为：</p><p>**刷盘方式：**ASYNC_FLUSH(异步刷盘)</p><p>**主从复制：**SYNC_MASTER(同步复制)</p><p>异步刷盘能够避免频繁触发磁盘写操作，除非服务器宕机，否则不会造成消息丢失。</p><p>主从同步复制能够保证消息不丢失，即使 Master 节点异常，也能保证 Slave 节点存储所有消息并被正常消费掉。</p><p>但是金融级应用一般是<code>SYNC_FLUSH</code>同步刷盘，能保证不丢消息。</p><h1><span id="fu-zai-jun-heng"> 负载均衡</span><a href="#fu-zai-jun-heng" class="header-anchor">#</a></h1><p>在实例<strong>发送消息时，默认会轮询所有订阅了改 Topic 的 broker 节点上的 message queue，让消息平均落在不同的 queue 上</strong>，而由于这些 queue 散落在不同的 broker 节点中，即使某个 broker 节点异常，其他存在订阅了这个 Topic 的 message queue 的 broker 依然能消费消息</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804140402905.png" alt="image-20200804140402905"></p><h2><span id="topic-he-queue"> Topic和Queue</span><a href="#topic-he-queue" class="header-anchor">#</a></h2><p>RocketMQ的Topic和Queue与常规如ActiveMQ不同：</p><ul><li><p>ActiveMQ的Queue是用来做点对点的发布订阅，Topic是用来做广播。</p></li><li><p>但是RocketMQ不一样：RocketMQ的Topic内部有很多Queue。如：</p><ul><li><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804134726494.png" alt="image-20200804134726494"></li></ul></li></ul><p>在新建Topic的时候就可以选择哪些borker来处理，<strong>并可以制定每个Broker内部开多少个读和写的队列数量</strong>，所以上图看到的就是每个broker内有多个queue：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804134901653.png" alt="image-20200804134901653"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 轮询每个broker下面的每个queue进行处理</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;0,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;1,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;2,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;3,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;4,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;5,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;6,getQueueOffset&#x3D;148</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;7,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;8,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;9,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;10,getQueueOffset&#x3D;150</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;11,getQueueOffset&#x3D;150</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;12,getQueueOffset&#x3D;151</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;13,getQueueOffset&#x3D;151</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;14,getQueueOffset&#x3D;152</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;15,getQueueOffset&#x3D;151</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;0,getQueueOffset&#x3D;152</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;1,getQueueOffset&#x3D;152</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;2,getQueueOffset&#x3D;152</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;3,getQueueOffset&#x3D;152</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;4,getQueueOffset&#x3D;151</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;5,getQueueOffset&#x3D;151</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;6,getQueueOffset&#x3D;150</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;7,getQueueOffset&#x3D;150</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;8,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;9,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;10,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;11,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;12,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;13,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;14,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-b, getQueueId&#x3D;15,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;0,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;1,getQueueOffset&#x3D;149</span><br><span class="line">发送一个消息,status&#x3D;SEND_OK,BrokerName&#x3D;broker-a, getQueueId&#x3D;2,getQueueOffset&#x3D;149</span><br><span class="line">&#x2F;。。。。</span><br></pre></td></tr></table></figure><h1><span id="yuan-dai-ma-liu-cheng"> 源代码流程</span><a href="#yuan-dai-ma-liu-cheng" class="header-anchor">#</a></h1><h2><span id="fa-song-pu-tong-xiao-xi-de-liu-cheng"> 发送普通消息的流程</span><a href="#fa-song-pu-tong-xiao-xi-de-liu-cheng" class="header-anchor">#</a></h2><ul><li>准备工作：构建message、网络相关、线程相关</li><li>从namesev拿到topic路由，缓存到map中</li><li>组装数据，broker需要的序列化数据（json）</li><li>netty发送</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804161635352.png" alt="image-20200804161635352"></p><p>详细来说：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200804144830052.png" alt="image-20200804144830052"></p><blockquote><p><a href="https://yq.aliyun.com/articles/763218" target="_blank" rel="noopener">https://yq.aliyun.com/articles/763218</a></p><p><a href="https://blog.csdn.net/qq_34416331/article/details/107310833" target="_blank" rel="noopener">https://blog.csdn.net/qq_34416331/article/details/107310833</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rocketmq-jian-jie&quot;&gt;RocketMQ简介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#he-xin-gai-nian&quot;&gt;核心概念：&lt;
      
    
    </summary>
    
    
      <category term="xx" scheme="https://blog.sofunnyai.com/categories/xx/"/>
    
    
      <category term="tag1" scheme="https://blog.sofunnyai.com/tags/tag1/"/>
    
      <category term="tag2" scheme="https://blog.sofunnyai.com/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>BeanFactory和FactoryBean</title>
    <link href="https://blog.sofunnyai.com/article/BeanFactory-and-FactoryBean.html"/>
    <id>https://blog.sofunnyai.com/article/BeanFactory-and-FactoryBean.html</id>
    <published>2018-06-19T15:32:42.000Z</published>
    <updated>2020-07-24T17:22:03.845Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#beanfactory">BeanFactory</a><ul><li><a href="#beanfactory-de-zi-jie-kou-listablebeanfactory">BeanFactory的子接口ListableBeanFactory</a></li><li><a href="#zi-jie-kou-applicationcontext">子接口ApplicationContext</a></li><li><a href="#spring-shi-xian-defaultlistablebeanfactory">Spring实现DefaultListableBeanFactory</a></li></ul></li><li><a href="#factorybean">FactoryBean</a><ul><li><a href="#dian-xing-an-li-mybatis-de-sqlsessionfactorybean">典型案例—mybatis的SqlSessionFactoryBean</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="beanfactory"> BeanFactory</span><a href="#beanfactory" class="header-anchor">#</a></h1><p>是访问spring的IOC容器核心接口，提供访问spring容器中对象的功能，给IOC容器提供了基础规范。他里面有：</p><ul><li>BeanDefinition信息，根据这些BeanDefinition，Spring可以创建这些对象。</li><li>注册中心，创建的各种Bean都注册在这里</li><li>Spring的依赖注入功能使用这个BeanFactory接口和子接口来实现。</li><li>会加载XML、注解，来配置Bean</li><li><strong>核心方法</strong>有：各种重载的<code>getBean</code>、 <code>getBeanProvider(Class)</code>、   <code>getType(name)</code>、<code>isSingleton(name)/isPrototype(name)</code>、<code>isTypeMatch(name, ResolvableType)</code></li><li>实现Bean生命周期回，全套的初始化方法以及它们的标准顺序是：<ul><li>BeanNameAware的setBeanName</li><li>BeanClassLoaderAware的setBeanClassLoader</li><li>实现BeanFactoryAware的setBeanFactory</li><li>EnvironmentAware的setEnvironment</li><li>EmbeddedValueResolverAware的setEmbeddedValueResolver</li><li>ResourceLoaderAware的setResourceLoader （仅适用于应用程序上下文中运行时）</li><li>ApplicationEventPublisherAware的setApplicationEventPublisher （仅适用于应用程序上下文中运行时）</li><li>MessageSourceAware的setMessageSource （仅适用于应用程序上下文中运行时）</li><li>了ApplicationContextAware的setApplicationContext （仅适用于应用程序上下文中运行时）</li><li>ServletContextAware的setServletContext （仅适用于Web应用程序上下文中运行时）</li><li>postProcessBeforeInitialization BeanPostProcessor的方法的InitializingBean的afterPropertiesSet自定义的初始化方法定义</li><li>postProcessAfterInitialization BeanPostProcessor的方法</li></ul></li><li>在一个bean工厂的关闭，下列生命周期方法适用于：</li><li>posProcessBeforeDestruction DestructionAwareBeanPostProcessors的方法</li><li>DisposableBean的destroy方法</li></ul><h2><span id="beanfactory-de-zi-jie-kou-listablebeanfactory"> BeanFactory的子接口ListableBeanFactory</span><a href="#beanfactory-de-zi-jie-kou-listablebeanfactory" class="header-anchor">#</a></h2><p>是BeanFactory的一个拓展，可以<strong>枚举所有的bean实例</strong>，所以是<strong>listable</strong></p><p>下面是一堆可以<strong>listable</strong>的方法，一次可以拿出来一大堆bean的名称或者对象</p><ul><li><code>String[] getBeanDefinitionNames();</code></li><li>各种重载的<code>String[] getBeanNamesForType(ResolvableType type);</code></li><li><code>Map getBeansOfType( Class&lt;T&gt; type)</code></li><li><code>Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; annotationType)</code></li></ul><h2><span id="zi-jie-kou-applicationcontext"> 子接口ApplicationContext</span><a href="#zi-jie-kou-applicationcontext" class="header-anchor">#</a></h2><p><code>ApplicationContext</code>作为<code>ListableBeanFactory</code>的子接口（还有一大堆别的接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>又有一大堆功能，提供了配置application的功能，还有</p><ul><li>工厂方法来访问应用程序组件。 继承自ListableBeanFactory 。</li><li>以通用的方式的能力，加载文件资源。 继承了org.springframework.core.io.ResourceLoader接口。</li><li>发布事件注册的侦听器的能力。 继承了ApplicationEventPublisher接口。</li><li>有能力解决的消息，支持国际化。 继承了MessageSource接口。</li><li>继承自父上下文。 在子上下文定义将始终优先。 这意味着，例如，单个父上下文可以被整个web应用程序被使用，而每个servlet有其自己的子上下文无关的任何其他的servlet。</li><li>除了标准的org.springframework.beans.factory.BeanFactory生命周期的能力，ApplicationContext实现检测并调用ApplicationContextAware Bean以及ResourceLoaderAware ， ApplicationEventPublisherAware和MessageSourceAware。</li></ul><h2><span id="spring-shi-xian-defaultlistablebeanfactory"> Spring实现DefaultListableBeanFactory</span><a href="#spring-shi-xian-defaultlistablebeanfactory" class="header-anchor">#</a></h2><p>BeanFactory，以Factory结尾，表示它是一个工厂类(接口)， <strong>它负责生产和管理bean的一个工厂</strong>。在Spring中，<strong>BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</strong></p><p><strong>BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，其中****XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系</strong>。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。</p><p>都是附加了某种功能的实现。 它为其他具体的IOC容器提供了最基本的规范，例如DefaultListableBeanFactory,XmlBeanFactory,ApplicationContext 等具体的容器都是实现了BeanFactory，再在其基础之上附加了其他的功能。</p><p>BeanFactory和ApplicationContext就是spring框架的两个IOC容器，现在一般使用ApplicationnContext，其不但包含了BeanFactory的作用，同时还进行更多的扩展。</p><h1><span id="factorybean"> FactoryBean</span><a href="#factorybean" class="header-anchor">#</a></h1><p><strong>一般情况下，Spring通过反射机制利用<code>&lt;bean&gt;</code>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<code>&lt;bean&gt;</code>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑,底层是基于<code>FactoryBeanRegistrySupport</code>实现的。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现</strong>。</p><p>它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式。</p><p>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了<code>FactoryBean&lt;T&gt;</code>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</p><p><strong>例如自己实现一个FactoryBean，功能：用来代理一个对象，对该对象的所有方法做一个拦截，在调用前后都输出一行LOG，模仿ProxyFactoryBean的功能</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理一个类，拦截该类的所有方法，在方法的调用前后进行日志的输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;    </span><br><span class="line">    <span class="keyword">private</span> String interfaceName;    </span><br><span class="line">    <span class="keyword">private</span> Object target;    </span><br><span class="line">    <span class="keyword">private</span> Object proxyObj;    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"destroy......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        proxyObj = Proxy.newProxyInstance(</span><br><span class="line">                <span class="keyword">this</span>.getClass().getClassLoader(), </span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; Class.forName(interfaceName) &#125;, </span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;                    </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                logger.debug(<span class="string">"invoke method......"</span> + method.getName());</span><br><span class="line">                logger.debug(<span class="string">"invoke method before......"</span> + System.currentTimeMillis());</span><br><span class="line">                Object result = method.invoke(target, args);</span><br><span class="line">                logger.debug(<span class="string">"invoke method after......"</span> + System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">return</span> result;            &#125;            </span><br><span class="line">        &#125;);</span><br><span class="line">        logger.debug(<span class="string">"afterPropertiesSet......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"getObject......"</span>);</span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return proxyObj == null ? Object.class : proxyObj.getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInterfaceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceName</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProxyObj</span><span class="params">(Object proxyObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyObj = proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFactoryBean</span><span class="params">(ConfigurableApplicationContext context)</span></span>&#123;</span><br><span class="line">        Car car = (Car) context.getBean(Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(car.toString());</span><br><span class="line">        <span class="comment">// 这里拿出来的才是CarFactoryBean</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">"&amp;carFactoryBean"</span>).hashCode());</span><br><span class="line">        <span class="comment">// 这里拿出来的是Car</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">"carFactoryBean"</span>).getClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="dian-xing-an-li-mybatis-de-sqlsessionfactorybean"> 典型案例—mybatis的SqlSessionFactoryBean</span><a href="#dian-xing-an-li-mybatis-de-sqlsessionfactorybean" class="header-anchor">#</a></h2><p>使用来创建<code>SqlSessionFactory</code>对象的一个FactoryBean，如果没有他直接去创建<code>DefaultSqlSessionFactory</code>，里面需要依赖一个<code>Configuration</code>，这个里面又依赖<code>org.apache.ibatis.mapping.Environment</code>， <code>Environment</code>里面才有<code>DataSource</code>和<code>TransactionFactory</code>，这是一个很繁琐的链式依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 便捷创建SqlSessionFactory对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MetadataReaderFactory METADATA_READER_FACTORY = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Resource configLocation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Resource[] mapperLocations;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TransactionFactory transactionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Properties configurationProperties;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// EnvironmentAware requires spring 3.1</span></span><br><span class="line">  <span class="keyword">private</span> String environment = SqlSessionFactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Interceptor[] plugins;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TypeHandler&lt;?&gt;[] typeHandlers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String typeHandlersPackage;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">  <span class="keyword">private</span> Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt;[] typeAliases;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String typeAliasesPackage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LanguageDriver[] scriptingLanguageDrivers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// issue #19. No default provider.</span></span><br><span class="line">  <span class="keyword">private</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;? extends VFS&gt; vfs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在spring的context刷新完毕的时候触发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (failFast &amp;&amp; event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">      <span class="comment">// fail-fast -&gt; check all statements are completed</span></span><br><span class="line">      <span class="keyword">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描包</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; scanClasses(String packagePatterns, Class&lt;?&gt; assignableType) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    String[] packagePatternArray = tokenizeToStringArray(packagePatterns,</span><br><span class="line">        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="keyword">for</span> (String packagePattern : packagePatternArray) &#123;</span><br><span class="line">      Resource[] resources = RESOURCE_PATTERN_RESOLVER.getResources(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX</span><br><span class="line">          + ClassUtils.convertClassNameToResourcePath(packagePattern) + <span class="string">"/**/*.class"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          ClassMetadata classMetadata = METADATA_READER_FACTORY.getMetadataReader(resource).getClassMetadata();</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(classMetadata.getClassName());</span><br><span class="line">          <span class="keyword">if</span> (assignableType == <span class="keyword">null</span> || assignableType.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            classes.add(clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          LOGGER.warn(() -&gt; <span class="string">"Cannot load the '"</span> + resource + <span class="string">"'. Cause by "</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">  核心方法，创建一个SqlSessionFactory</span></span><br><span class="line"><span class="comment">   * Build a &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; instance.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The default implementation uses the standard MyBatis &#123;<span class="doctag">@code</span> XMLConfigBuilder&#125; API to build a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; instance based on a Reader. Since 1.3.0, it can be specified a &#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment">   * instance directly(without config file).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> SqlSessionFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   *           if configuration is failed</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> SqlSessionFactory <span class="title">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Configuration targetConfiguration;</span><br><span class="line"></span><br><span class="line">    XMLConfigBuilder xmlConfigBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.configuration != <span class="keyword">null</span>) &#123;</span><br><span class="line">      targetConfiguration = <span class="keyword">this</span>.configuration;</span><br><span class="line">      <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetConfiguration.setVariables(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configurationProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetConfiguration.getVariables().putAll(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">      xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder(<span class="keyword">this</span>.configLocation.getInputStream(), <span class="keyword">null</span>, <span class="keyword">this</span>.configurationProperties);</span><br><span class="line">      targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(</span><br><span class="line">          () -&gt; <span class="string">"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration"</span>);</span><br><span class="line">      targetConfiguration = <span class="keyword">new</span> Configuration();</span><br><span class="line">      Optional.ofNullable(<span class="keyword">this</span>.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional.ofNullable(<span class="keyword">this</span>.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">    Optional.ofNullable(<span class="keyword">this</span>.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">    Optional.ofNullable(<span class="keyword">this</span>.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasLength(<span class="keyword">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">      scanClasses(<span class="keyword">this</span>.typeAliasesPackage, <span class="keyword">this</span>.typeAliasesSuperType).stream()</span><br><span class="line">          .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">          .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.typeAliases)) &#123;</span><br><span class="line">      Stream.of(<span class="keyword">this</span>.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">        targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Registered type alias: '"</span> + typeAlias + <span class="string">"'"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">      Stream.of(<span class="keyword">this</span>.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">        targetConfiguration.addInterceptor(plugin);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Registered plugin: '"</span> + plugin + <span class="string">"'"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasLength(<span class="keyword">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">      scanClasses(<span class="keyword">this</span>.typeHandlersPackage, TypeHandler<span class="class">.<span class="keyword">class</span>).<span class="title">stream</span>().<span class="title">filter</span>(<span class="title">clazz</span> -&gt; !<span class="title">clazz</span>.<span class="title">isAnonymousClass</span>())</span></span><br><span class="line"><span class="class">          .<span class="title">filter</span>(<span class="title">clazz</span> -&gt; !<span class="title">clazz</span>.<span class="title">isInterface</span>()).<span class="title">filter</span>(<span class="title">clazz</span> -&gt; !<span class="title">Modifier</span>.<span class="title">isAbstract</span>(<span class="title">clazz</span>.<span class="title">getModifiers</span>()))</span></span><br><span class="line">          .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.typeHandlers)) &#123;</span><br><span class="line">      Stream.of(<span class="keyword">this</span>.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">        targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Registered type handler: '"</span> + typeHandler + <span class="string">"'"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">      Stream.of(<span class="keyword">this</span>.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">        targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Registered scripting language driver: '"</span> + languageDriver + <span class="string">"'"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Optional.ofNullable(<span class="keyword">this</span>.defaultScriptingLanguageDriver)</span><br><span class="line">        .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdProvider != <span class="keyword">null</span>) &#123;<span class="comment">// fix #64 set databaseId before parse mapper xmls</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        targetConfiguration.setDatabaseId(<span class="keyword">this</span>.databaseIdProvider.getDatabaseId(<span class="keyword">this</span>.dataSource));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed getting a databaseId"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional.ofNullable(<span class="keyword">this</span>.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlConfigBuilder.parse();</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">"Parsed configuration file: '"</span> + <span class="keyword">this</span>.configLocation + <span class="string">"'"</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse config resource: "</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    targetConfiguration.setEnvironment(<span class="keyword">new</span> Environment(<span class="keyword">this</span>.environment,</span><br><span class="line">        <span class="keyword">this</span>.transactionFactory == <span class="keyword">null</span> ? <span class="keyword">new</span> SpringManagedTransactionFactory() : <span class="keyword">this</span>.transactionFactory,</span><br><span class="line">        <span class="keyword">this</span>.dataSource));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">"Property 'mapperLocations' was specified but matching resources are not found."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">            xmlMapperBuilder.parse();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Property 'mapperLocations' was not specified."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面都是一堆设置sqlSessionFactory属性的set方法，类似与&lt;bean&gt;的各个属性</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the ObjectFactory.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   *          a custom ObjectFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectFactory</span><span class="params">(ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the ObjectWrapperFactory.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectWrapperFactory</span></span><br><span class="line"><span class="comment">   *          a specified ObjectWrapperFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjectWrapperFactory</span><span class="params">(ObjectWrapperFactory objectWrapperFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets the DatabaseIdProvider</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.1.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a specified DatabaseIdProvider</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DatabaseIdProvider <span class="title">getDatabaseIdProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> databaseIdProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the DatabaseIdProvider. As of version 1.2.2 this variable is not initialized by default.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.1.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> databaseIdProvider</span></span><br><span class="line"><span class="comment">   *          a DatabaseIdProvider</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseIdProvider</span><span class="params">(DatabaseIdProvider databaseIdProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.databaseIdProvider = databaseIdProvider;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets the VFS.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a specified VFS</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;? extends VFS&gt; getVfs() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.vfs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the VFS.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> vfs</span></span><br><span class="line"><span class="comment">   *          a VFS</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVfs</span><span class="params">(Class&lt;? extends VFS&gt; vfs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vfs = vfs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets the Cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a specified Cache</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the Cache.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cache</span></span><br><span class="line"><span class="comment">   *          a Cache</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = cache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Mybatis plugin list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> plugins</span></span><br><span class="line"><span class="comment">   *          list of plugins</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPlugins</span><span class="params">(Interceptor... plugins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.plugins = plugins;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Packages to search for type aliases.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Since 2.0.1, allow to specify a wildcard such as &#123;<span class="doctag">@code</span> com.example.*.model&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> typeAliasesPackage</span></span><br><span class="line"><span class="comment">   *          package to scan for domain objects</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliasesPackage</span><span class="params">(String typeAliasesPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.typeAliasesPackage = typeAliasesPackage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Super class which domain objects have to extend to have a type alias created. No effect if there is no package to</span></span><br><span class="line"><span class="comment">   * scan configured.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> typeAliasesSuperType</span></span><br><span class="line"><span class="comment">   *          super class for domain objects</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliasesSuperType</span><span class="params">(Class&lt;?&gt; typeAliasesSuperType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.typeAliasesSuperType = typeAliasesSuperType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Packages to search for type handlers.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Since 2.0.1, allow to specify a wildcard such as &#123;<span class="doctag">@code</span> com.example.*.typehandler&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> typeHandlersPackage</span></span><br><span class="line"><span class="comment">   *          package to scan for type handlers</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeHandlersPackage</span><span class="params">(String typeHandlersPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.typeHandlersPackage = typeHandlersPackage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set type handlers. They must be annotated with &#123;<span class="doctag">@code</span> MappedTypes&#125; and optionally with &#123;<span class="doctag">@code</span> MappedJdbcTypes&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> typeHandlers</span></span><br><span class="line"><span class="comment">   *          Type handler list</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeHandlers</span><span class="params">(TypeHandler&lt;?&gt;... typeHandlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.typeHandlers = typeHandlers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the default type handler class for enum.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 2.0.5</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> defaultEnumTypeHandler</span></span><br><span class="line"><span class="comment">   *          The default type handler class for enum</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultEnumTypeHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      @SuppressWarnings(<span class="string">"rawtypes"</span>)</span> Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultEnumTypeHandler = defaultEnumTypeHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * List of type aliases to register. They can be annotated with &#123;<span class="doctag">@code</span> Alias&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> typeAliases</span></span><br><span class="line"><span class="comment">   *          Type aliases list</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeAliases</span><span class="params">(Class&lt;?&gt;... typeAliases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.typeAliases = typeAliases;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If true, a final check is done on Configuration to assure that all mapped statements are fully loaded and there is</span></span><br><span class="line"><span class="comment">   * no one still pending to resolve includes. Defaults to false.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.0.1</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> failFast</span></span><br><span class="line"><span class="comment">   *          enable failFast</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFailFast</span><span class="params">(<span class="keyword">boolean</span> failFast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.failFast = failFast;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the location of the MyBatis &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; config file. A typical value is</span></span><br><span class="line"><span class="comment">   * "WEB-INF/mybatis-configuration.xml".</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configLocation</span></span><br><span class="line"><span class="comment">   *          a location the MyBatis config file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(Resource configLocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set a customized MyBatis configuration.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment">   *          MyBatis configuration</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfiguration</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set locations of MyBatis mapper files that are going to be merged into the &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; configuration</span></span><br><span class="line"><span class="comment">   * at runtime.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This is an alternative to specifying "&amp;lt;sqlmapper&amp;gt;" entries in an MyBatis config file. This property being</span></span><br><span class="line"><span class="comment">   * based on Spring's resource abstraction also allows for specifying resource patterns here: e.g.</span></span><br><span class="line"><span class="comment">   * "classpath*:sqlmap/*-mapper.xml".</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperLocations</span></span><br><span class="line"><span class="comment">   *          location of MyBatis mapper files</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMapperLocations</span><span class="params">(Resource... mapperLocations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperLocations = mapperLocations;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set optional properties to be passed into the SqlSession configuration, as alternative to a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> &amp;lt;properties&amp;gt;&#125; tag in the configuration xml file. This will be used to resolve placeholders in the</span></span><br><span class="line"><span class="comment">   * config file.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionFactoryProperties</span></span><br><span class="line"><span class="comment">   *          optional properties for the SqlSessionFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurationProperties</span><span class="params">(Properties sqlSessionFactoryProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configurationProperties = sqlSessionFactoryProperties;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the JDBC &#123;<span class="doctag">@code</span> DataSource&#125; that this instance should manage transactions for. The &#123;<span class="doctag">@code</span> DataSource&#125; should</span></span><br><span class="line"><span class="comment">   * match the one used by the &#123;<span class="doctag">@code</span> SqlSessionFactory&#125;: for example, you could specify the same JNDI DataSource for</span></span><br><span class="line"><span class="comment">   * both.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A transactional JDBC &#123;<span class="doctag">@code</span> Connection&#125; for this &#123;<span class="doctag">@code</span> DataSource&#125; will be provided to application code accessing</span></span><br><span class="line"><span class="comment">   * this &#123;<span class="doctag">@code</span> DataSource&#125; directly via &#123;<span class="doctag">@code</span> DataSourceUtils&#125; or &#123;<span class="doctag">@code</span> DataSourceTransactionManager&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> DataSource&#125; specified here should be the target &#123;<span class="doctag">@code</span> DataSource&#125; to manage transactions for, not a</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> TransactionAwareDataSourceProxy&#125;. Only data access code may work with</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> TransactionAwareDataSourceProxy&#125;, while the transaction manager needs to work on the underlying target</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> DataSource&#125;. If there's nevertheless a &#123;<span class="doctag">@code</span> TransactionAwareDataSourceProxy&#125; passed in, it will be</span></span><br><span class="line"><span class="comment">   * unwrapped to extract its target &#123;<span class="doctag">@code</span> DataSource&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">   *          a JDBC &#123;<span class="doctag">@code</span> DataSource&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> TransactionAwareDataSourceProxy) &#123;</span><br><span class="line">      <span class="comment">// If we got a TransactionAwareDataSourceProxy, we need to perform</span></span><br><span class="line">      <span class="comment">// transactions for its underlying target DataSource, else data</span></span><br><span class="line">      <span class="comment">// access code won't see properly exposed transactions (i.e.</span></span><br><span class="line">      <span class="comment">// transactions for the target DataSource).</span></span><br><span class="line">      <span class="keyword">this</span>.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the &#123;<span class="doctag">@code</span> SqlSessionFactoryBuilder&#125; to use when creating the &#123;<span class="doctag">@code</span> SqlSessionFactory&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This is mainly meant for testing so that mock SqlSessionFactory classes can be injected. By default,</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> SqlSessionFactoryBuilder&#125; creates &#123;<span class="doctag">@code</span> DefaultSqlSessionFactory&#125; instances.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionFactoryBuilder</span></span><br><span class="line"><span class="comment">   *          a SqlSessionFactoryBuilder</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactoryBuilder</span><span class="params">(SqlSessionFactoryBuilder sqlSessionFactoryBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactoryBuilder = sqlSessionFactoryBuilder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the MyBatis TransactionFactory to use. Default is &#123;<span class="doctag">@code</span> SpringManagedTransactionFactory&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The default &#123;<span class="doctag">@code</span> SpringManagedTransactionFactory&#125; should be appropriate for all cases: be it Spring transaction</span></span><br><span class="line"><span class="comment">   * management, EJB CMT or plain JTA. If there is no active transaction, SqlSession operations will execute SQL</span></span><br><span class="line"><span class="comment">   * statements non-transactionally.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;b&gt;It is strongly recommended to use the default &#123;<span class="doctag">@code</span> TransactionFactory&#125;.&lt;/b&gt; If not used, any attempt at</span></span><br><span class="line"><span class="comment">   * getting an SqlSession through Spring's MyBatis framework will throw an exception if a transaction is active.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> SpringManagedTransactionFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> transactionFactory</span></span><br><span class="line"><span class="comment">   *          the MyBatis TransactionFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionFactory</span><span class="params">(TransactionFactory transactionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionFactory = transactionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; This class &lt;em&gt;overrides&lt;/em&gt; any &#123;<span class="doctag">@code</span> Environment&#125; you have set in the MyBatis config file. This is</span></span><br><span class="line"><span class="comment">   * used only as a placeholder name. The default value is &#123;<span class="doctag">@code</span> SqlSessionFactoryBean.class.getSimpleName()&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">   *          the environment name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(String environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = environment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set scripting language drivers.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> scriptingLanguageDrivers</span></span><br><span class="line"><span class="comment">   *          scripting language drivers</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 2.0.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScriptingLanguageDrivers</span><span class="params">(LanguageDriver... scriptingLanguageDrivers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.scriptingLanguageDrivers = scriptingLanguageDrivers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set a default scripting language driver class.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> defaultScriptingLanguageDriver</span></span><br><span class="line"><span class="comment">   *          A default scripting language driver class</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 2.0.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultScriptingLanguageDriver</span><span class="params">(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultScriptingLanguageDriver = defaultScriptingLanguageDriver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    notNull(dataSource, <span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">    notNull(sqlSessionFactoryBuilder, <span class="string">"Property 'sqlSessionFactoryBuilder' is required"</span>);</span><br><span class="line">    state((configuration == <span class="keyword">null</span> &amp;&amp; configLocation == <span class="keyword">null</span>) || !(configuration != <span class="keyword">null</span> &amp;&amp; configLocation != <span class="keyword">null</span>),</span><br><span class="line">        <span class="string">"Property 'configuration' and 'configLocation' can not specified with together"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;? extends SqlSessionFactory&gt; getObjectType() &#123;</span><br><span class="line">    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/aspirant/p/9082858.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/9082858.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#beanfactory&quot;&gt;BeanFactory&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#beanfactory-de-zi-jie-kou-li
      
    
    </summary>
    
    
      <category term="xx" scheme="https://blog.sofunnyai.com/categories/xx/"/>
    
    
      <category term="tag1" scheme="https://blog.sofunnyai.com/tags/tag1/"/>
    
      <category term="tag2" scheme="https://blog.sofunnyai.com/tags/tag2/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Aop原理</title>
    <link href="https://blog.sofunnyai.com/article/spring-aop.html"/>
    <id>https://blog.sofunnyai.com/article/spring-aop.html</id>
    <published>2018-06-17T08:01:08.000Z</published>
    <updated>2020-07-29T06:00:17.757Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#aop-mian-xiang-qie-mian-bian-cheng">AOP 面向切面编程</a><ul><li><a href="#aop-shi-shi-me">Aop是什么</a></li><li><a href="#aop-de-ying-yong-chang-jing">aop的应用场景</a></li><li><a href="#gai-nian-spring-guan-wang">概念（spring官网）</a></li></ul><ul><li><a href="#spring-shi-xian">Spring实现</a></li><li><a href="#sheng-ming-yi-ge-pointcut-qie-ru-dian-de-fang-shi">声明一个<code>Pointcut</code>切入点的方式:</a></li><li><a href="#qie-ru-dian-biao-da-shi">切入点表达式：</a></li></ul></li><li><a href="#aop-de-shi-xian">AOP的实现</a></li><li><a href="#sheng-ming-shi-shi-wu">声明式事务</a></li><li><a href="#springaop-de-yuan-li">SpringAOP的原理</a></li></ul><!-- tocstop --></div><h1><span id="aop-mian-xiang-qie-mian-bian-cheng"> AOP 面向切面编程</span><a href="#aop-mian-xiang-qie-mian-bian-cheng" class="header-anchor">#</a></h1><h3><span id="aop-shi-shi-me"> Aop是什么</span><a href="#aop-shi-shi-me" class="header-anchor">#</a></h3><ul><li>与OOP对比，传统的OOP开发中的代码逻辑是自上而下的，而这些过程会产生一些<strong>横切性问题</strong>，这些横切性的问题和我们的主业务逻辑关系不大，这些横切性问题不会影响到主逻辑实现的，但是会散落到代码的各个部分，难以维护。</li><li>AOP是处理一些横切性问题，AOP的编程思想就是把这些问题和主业务逻辑分开，达到与主业务逻辑解耦的目的。使代码的重用性和开发效率更高。</li><li><code>AspectJ AOP</code>是一个AOP实现，同样还有<code>Jboos Aop</code>、<code>Spring AOP</code>实现。</li><li>虽然spring本身有springAop实现，但是它的语法太复杂，所以它继承了aspectJ的语法来表现springAop。（使用了aspectJ注解而已，运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或编织器。）</li><li>springAOP是动态织入，也就是运行时织入的。AspectJ是静态织入，编译的时候就织入进去代码了。</li></ul><h3><span id="aop-de-ying-yong-chang-jing"> aop的应用场景</span><a href="#aop-de-ying-yong-chang-jing" class="header-anchor">#</a></h3><p>日志记录、权限验证、效率检查、事务管理、分布式锁、exception…</p><h3><span id="gai-nian-spring-guan-wang"> 概念（spring官网）</span><a href="#gai-nian-spring-guan-wang" class="header-anchor">#</a></h3><ul><li><strong>target</strong> 目标对象，就是aop增强前的<strong>原始对象</strong></li><li><strong>aop Proxy</strong> 代理对象，包含了原始对象的代码和增加后的代码的增强后的对象。（类比装饰模式）</li><li><strong>Joinpoint</strong>:连接点<strong>目标对象</strong>中的方法。springAOP中最小的AOP单元是连接点，也就是方法。一系列连接点的集合称为切点PointCut。 ----------------&gt;    （要关注和增强的方法，也就是我们要作用的点）</li><li><strong>pointcut</strong>:切点表示连接点的集合  -------------------&gt;    （是告诉通知连接点在哪里，切点表达式决定 JoinPoint 的数量）</li><li><strong>Advice</strong>:通知，通知到哪里去，通知什么逻辑。    (位置 + logic)，一般是拦截器实现。<ul><li>advice通知类型:<ul><li>Before 连接点执行之前，但是无法阻止连接点的正常执行，除非该段执行抛出异常</li><li>After  连接点正常执行之后，执行过程中正常执行返回退出，非异常退出</li><li>After throwing  执行抛出异常的时候</li><li>After (finally)  无论连接点是正常退出还是异常退出，都会执行</li><li>Around advice: 围绕连接点执行，例如方法调用。这是最有用的切面方式。around通知可以在方法调用之前和之后执行自定义行为。它还负责选择是继续加入点还是通过返回自己的返回值或抛出异常来快速建议的方法执行。</li></ul></li></ul></li><li><strong>Aspect</strong>: 切面：切点、连接点、通知的一个载体。就是对连接点、通知的逻辑要写到哪里去的一个地方。（aspectJ实现的话是一个类，spring的话是一个xml标签）一定要给spring去管理，是一个抽象。</li><li><strong>Weaving</strong> :把<strong>代理逻辑加入到目标对象方法上的过程</strong>叫做织入。将Aspect切面与其他Class或对象链接以创建Advice的对象的过程。 这可以在编译时（例如，使用AspectJ编译器），加载时或在运行时完成。 Spring AOP在运行时执行编织</li><li>Proceedingjoinpoint 和JoinPoint的区别:</li></ul><p>Proceedingjoinpoint 继承了JoinPoint,proceed()这个是aop代理链执行的方法。并扩充实现了proceed()方法，用于继续执行连接点。JoinPoint仅能获取相关参数，无法执行连接点。</p><ul><li>JoinPoint的方法</li></ul><ol><li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li><li>Signature getSignature() ：获取连接点的方法签名对象；</li><li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li><li>java.lang.Object getThis() ：获取代理对象本身；</li></ol><p>proceed()有重载,有个带参数的方法,可以修改目标方法的的参数</p><p>Introductions</p><p>perthis</p><p>使用方式如下：</p><p>@Aspect(“perthis(this(com.chenss.dao.IndexDaoImpl))”)</p><p>要求：</p><p>\1. AspectJ对象的注入类型为prototype</p><p>\2. 目标对象也必须是prototype的</p><p>原因为：只有目标对象是原型模式的，每次getBean得到的对象才是不一样的，由此针对每个对象就会产生新的切面对象，才能产生不同的切面结果。</p><h2><span id="spring-shi-xian"> Spring实现</span><a href="#spring-shi-xian" class="header-anchor">#</a></h2><ul><li><p>默认使用JDK动态代理实现（但是需要接口），也可以使用CGlib实现。</p></li><li><p>开启<code>AspectJ</code>支持，两种方式：</p><ul><li><p>首先引入<code>aspectjweaver.jar</code></p></li><li><p>xml方式： <code>&lt;aop:aspectj-autoproxy/&gt;</code></p></li><li><p>或者javaconfig方式:</p></li><li><pre class="highlight"><code class="java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>{}&lt;!--￼<span class="hljs-number">0</span>--&gt;</code></pre></li></ul></li><li><p><strong>Aspect</strong>(也就是上面用@Aspect注释的类)可以有方法和字段，还可以包含切入点joinPoint、Advice通知和introduction(inter-type)声明。</p></li><li><p>Aspect本身不能被其他的Aspect进行增强</p></li></ul><h2><span id="sheng-ming-yi-ge-pointcut-qie-ru-dian-de-fang-shi"> 声明一个<code>Pointcut</code>切入点的方式:</span><a href="#sheng-ming-yi-ge-pointcut-qie-ru-dian-de-fang-shi" class="header-anchor">#</a></h2><p>切入点确定了感兴趣的连接点（也就是PointCut是一系列JoinPoint的集合），从而使我们能够控制执行通知<code>Advice</code>的时间。 Spring AOP仅支持Spring Bean的方法执行连接点，因此可以将**<code>PointCut</code>视为Spring Bean上的方法执行**。</p><ul><li>切入点声明由两部分组成：一个包含<strong>名称和任何参数</strong>的签名，以及<strong>一个切入点表达式</strong>，该切入点表达式<strong>准确确定我们感兴趣的方法执行</strong>。在AOP的@AspectJ批注样式中，常规方法定义提供了切入点签名。 并使用@Pointcut批注指示切入点表达式（<strong>用作切入点签名的方法必须具有void返回类型</strong>），一般是一个空方法。</li><li></li></ul><h2><span id="qie-ru-dian-biao-da-shi"> 切入点表达式：</span><a href="#qie-ru-dian-biao-da-shi" class="header-anchor">#</a></h2><ul><li><p><code>execution</code>: For matching method execution join points.匹配方法的表达式，最齐全，是springAOP最重要的匹配符。</p><ul><li><p>下面是<code>execution</code>的一个完整的各部分含义，带<code>？</code>的是可选的，也就是可以省略的</p></li><li><p><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</code></p></li><li><p>其中各项的语义如下</p><ul><li><p><code>modifiers-pattern</code>：方法的可见性，如public，protected；不可是*，可以省略。</p></li><li><p><code>ret-type-pattern</code>：方法的返回值类型，如int，void等；</p></li><li><p><code>declaring-type-pattern</code>：方法所在类的全路径名，如com.spring.Aspect；</p></li><li><p><code>name-pattern</code>：方法名类型，如buisinessService()；</p></li><li><p><code>param-pattern</code>：方法的参数类型，如java.lang.String；</p></li><li><p><code>throws-pattern</code>：方法抛出的异常类型，如java.lang.Exception；</p></li></ul></li><li><pre class="highlight"><code class="java"><span class="hljs-comment">// 案例</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的任意方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.sam.dao.*.*(..))"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * com.sam.dao.*.*())"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的public 无方法参数的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao.*.*(java.lang.String, ..))"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的第一个参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao.*.*(java.lang.String))"</span>)<span class="hljs-comment">//匹配com.sam.dao包下的任意接口和类的只有一个参数，且参数为String类型的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(public * *(..))"</span>)<span class="hljs-comment">//匹配任意的public方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* query*(..))"</span>)<span class="hljs-comment">//匹配任意的以query开头的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao.IndexDao.*(..))"</span>)<span class="hljs-comment">//匹配com.sam.dao.IndexDao接口中任意的方法</span><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* com.sam.dao..*.*(..))"</span>)<span class="hljs-comment">//匹配com.sam.dao包及其子包中任意的方法</span>&lt;!--￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ul></li></ul><p>测试introduction引入机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"================================introduction=============="</span>);</span><br><span class="line">ICBCService icbcService = context.getBean(ICBCService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 原生ICBCService这个类，没有任何接口，只是有一个otherMethod方法</span></span><br><span class="line">icbcService.otherMethod(<span class="string">"param"</span>);</span><br><span class="line"><span class="comment">// ICBCService 没有实现UserBankService接口，但是可以强转为UserBankService，因为AOP使用了introduction为他引入了UserBankService接口的实现：UserServiceImpl</span></span><br><span class="line">UserBankService icbcBankService = (UserBankService) icbcService;</span><br><span class="line"><span class="comment">// 所以此处调用是UserServiceImpl的逻辑</span></span><br><span class="line">icbcBankService.addMoney(<span class="string">"lisi"</span>,<span class="number">300</span>);</span><br><span class="line">System.out.println(<span class="string">"\n================================introduction=============="</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>within</code>: Limits matching to join points within certain types。限定于某些方法内的匹配符表达式。</p><ul><li><pre class="highlight"><code class="java"><span class="hljs-meta">@After</span>(<span class="hljs-string">"within(com.sam.bootdemo.service.impl.UserServiceImpl)"</span>) <span class="hljs-comment">// UserServiceImpl类的所有方法</span>&lt;!--￼<span class="hljs-number">3</span>--&gt;</code></pre></li></ul></li><li><p><code>args</code>：限制参数类型，如：</p><ul><li><pre class="highlight"><code class="java"><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"args(java.lang.String)"</span>)  <span class="hljs-comment">//匹配一个String类型的参数，也常常组合使用</span>&lt;!--￼<span class="hljs-number">4</span>--&gt;</code></pre></li></ul></li><li><p><code>introduction</code>：引入，给一个Bean引入一个接口的实现。使得这个Bean可以当作另外一个接口的实现类使用。</p></li></ul><h1><span id="aop-de-shi-xian"> AOP的实现</span><a href="#aop-de-shi-xian" class="header-anchor">#</a></h1><p>先看一个现象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spring.aop.proxy-target-class= false 时候是JDK动态代理。和UserBankServiceImpl同样接口、具有相同行为，但是不是UserBankServiceImpl，所以下面是false</span></span><br><span class="line"><span class="comment">// spring.aop.proxy-target-class= true 时候是CGlib继承。行为和类型都相同，下面是true</span></span><br><span class="line">System.out.println(bankService <span class="keyword">instanceof</span> UserBankServiceImpl);</span><br></pre></td></tr></table></figure><p>代理的结果默认JDK动态代理通过接口实现，不等于我们的目标对象。</p><h1><span id="sheng-ming-shi-shi-wu"> 声明式事务</span><a href="#sheng-ming-shi-shi-wu" class="header-anchor">#</a></h1><p>上面讲的只是AOP，只能在方法之前之后进行增强，无法在方法代码内部进行插入增强。需要这么做只能<code>advisor</code>实现。</p><p>但是<code>advisor</code>在<code>@AspectJ Support</code>中不能支持，可以使用<code>XML</code>进行实现。非要在Java中实现只能更换一种方式：</p><p>待续…</p><h1><span id="springaop-de-yuan-li"> SpringAOP的原理</span><a href="#springaop-de-yuan-li" class="header-anchor">#</a></h1><p>这里先看一个Spring对<code>@Configuration</code>的代理实现：</p><p>这部分是在<code>invokeBeanFactoryPostProceccer</code>方法中，由<code>ConfigurationClassPostProcessor</code>在扫描到<code>full</code>的<code>@Configuration</code>修饰类后调用<code>ConfigurationClassEnhancer#enhance(claz,clazLoader)</code>进行封装的：</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* CHlib创建子类的核心逻辑</span></span><br><span class="line"><span class="comment"> * Creates a new CGLIB &#123;@link Enhancer&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 一个增强器，是CGlib核心接口ClassGenerator的实现</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       <span class="comment">// 设置父类，就是当前@Configuration修饰的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">       <span class="comment">// 给代理类实现一个实际上是BeanFactoryAware接口，用来注入$$beanFactory</span></span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">       <span class="comment">// 是否实现Factory接口，一般false</span></span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 生成的beanName策略 xxxBySpringCGLIB</span></span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">       <span class="comment">// 自定义CGlib生成策略，里面声明了一个public 的 $$beanFactory用来存放aware注入的bf</span></span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">       <span class="comment">// 设置一个方法调用的过滤器，塞进去了两个：</span></span><br><span class="line">       <span class="comment">//new BeanMethodInterceptor()： </span></span><br><span class="line">       <span class="comment">//拦截@Bean方法,&amp;beanName去BF里面拿一下，判断是否是FactoryBean，是的话对FB里面的getObject进行代理，非inCreation调用时返回引用。容器调用的时候inCreation，才真的getObject</span></span><br><span class="line">       <span class="comment">// 非FactoryBean的代理了@Bean注解方法，非inCreation调用时返回引用。容器调用的时候inCreation，才真的new</span></span><br><span class="line">    <span class="comment">//new BeanFactoryAwareMethodInterceptor(),</span></span><br><span class="line">       <span class="comment">// 代理setBF方法，如果找到$$beanFactory，就在setBF方法里面给bf设置到$$beanFactory上</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整spring代理CGlib的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment">* 这个类使用CGlib来生成<span class="doctag">@Configuration</span>类的子类，使得每一个<span class="doctag">@Bean</span>修饰的方法都会被子类重写，除非容器来调用，否则在其他地方来调用这些<span class="doctag">@Bean</span>方法的时候不会创建对象（会破坏单例性），而是返回一个容器内已有的Bean的引用。</span></span><br><span class="line"><span class="comment"> * Enhances &#123;<span class="doctag">@link</span> Configuration&#125; classes by generating a CGLIB subclass which</span></span><br><span class="line"><span class="comment"> * interacts with the Spring container to respect bean scoping semantics for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; methods. Each such &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method will be overridden in</span></span><br><span class="line"><span class="comment"> * the generated subclass, only delegating to the actual &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method</span></span><br><span class="line"><span class="comment"> * implementation if the container actually requests the construction of a new</span></span><br><span class="line"><span class="comment"> * instance. Otherwise, a call to such an &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method serves as a</span></span><br><span class="line"><span class="comment"> * reference back to the container, obtaining the corresponding bean by name.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #enhance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The callbacks to use. Note that these callbacks must be stateless.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line"><span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line"><span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类里面增强一个BF的属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_FACTORY_FIELD = <span class="string">"$$beanFactory"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ConfigurationClassEnhancer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SpringObjenesis objenesis = <span class="keyword">new</span> SpringObjenesis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">外面ConfigurationClassPostProcessor调用的入口</span></span><br><span class="line"><span class="comment"> * Loads the specified class and generates a CGLIB subclass of it equipped with</span></span><br><span class="line"><span class="comment"> * container-aware callbacks capable of respecting scoping and other bean semantics.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the enhanced subclass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (EnhancedConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">configClass</span>)) </span>&#123;  <span class="comment">// 这里判断是否EnhancedConfiguration接口。这是一个空接口，是BFAware的子接口，</span></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">"Ignoring request to enhance %s as it has "</span> +</span><br><span class="line"><span class="string">"already been enhanced. This usually indicates that more than one "</span> +</span><br><span class="line"><span class="string">"ConfigurationClassPostProcessor has been registered (e.g. via "</span> +</span><br><span class="line"><span class="string">"&lt;context:annotation-config&gt;). This is harmless, but you may "</span> +</span><br><span class="line"><span class="string">"want check your configuration and remove one CCPP if possible"</span>,</span><br><span class="line">configClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> configClass;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，真正开始进行增强</span></span><br><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(String.format(<span class="string">"Successfully enhanced %s; enhanced class name is: %s"</span>,</span><br><span class="line">configClass.getName(), enhancedClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* CGlib创建子类的核心逻辑</span></span><br><span class="line"><span class="comment"> * Creates a new CGLIB &#123;@link Enhancer&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一个增强器，是CGlib核心接口ClassGenerator的实现</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置父类，就是当前@Configuration修饰的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">        <span class="comment">// 给代理类实现一个实际上是BeanFactoryAware接口，用来注入$$beanFactory</span></span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        <span class="comment">// 是否实现Factory接口，一般false</span></span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 生成的beanName策略 xxxBySpringCGLIB</span></span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        <span class="comment">// 自定义CGlib生成策略，里面声明了一个public 的 $$beanFactory用来存放aware注入的bf</span></span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">        <span class="comment">// 设置一个方法调用的过滤器，塞进去了两个：</span></span><br><span class="line">        <span class="comment">//new BeanMethodInterceptor()： </span></span><br><span class="line">        <span class="comment">//拦截@Bean方法,&amp;beanName去BF里面拿一下，判断是否是FactoryBean，是的话对FB里面的getObject进行代理，非inCreation调用时返回引用。容器调用的时候inCreation，才真的getObject</span></span><br><span class="line">        <span class="comment">// 非FactoryBean的代理了@Bean注解方法，非inCreation调用时返回引用。容器调用的时候inCreation，才真的new</span></span><br><span class="line">    <span class="comment">//new BeanFactoryAwareMethodInterceptor(),</span></span><br><span class="line">        <span class="comment">// 代理setBF方法，如果找到$$beanFactory，就在setBF方法里面给bf设置到$$beanFactory上</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Uses enhancer to generate a subclass of superclass,</span></span><br><span class="line"><span class="comment"> * ensuring that callbacks are registered for the new subclass.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createClass(Enhancer enhancer) &#123;</span><br><span class="line">Class&lt;?&gt; subclass = enhancer.createClass();</span><br><span class="line"><span class="comment">// Registering callbacks statically (as opposed to thread-local)</span></span><br><span class="line"><span class="comment">// is critical for usage in an OSGi environment (SPR-5932)...</span></span><br><span class="line">Enhancer.registerStaticCallbacks(subclass, CALLBACKS);</span><br><span class="line"><span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">空接口，只是一个BFAware的子接口，用来标记当前类可以注入BF</span></span><br><span class="line"><span class="comment"> * Marker interface to be implemented by all <span class="doctag">@Configuration</span> CGLIB subclasses.</span></span><br><span class="line"><span class="comment"> * Facilitates idempotent behavior for &#123;<span class="doctag">@link</span> ConfigurationClassEnhancer#enhance&#125;</span></span><br><span class="line"><span class="comment"> * through checking to see if candidate classes are already assignable to it, e.g.</span></span><br><span class="line"><span class="comment"> * have already been enhanced.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Also extends &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, as all enhanced &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span></span><br><span class="line"><span class="comment"> * classes require access to the &#123;<span class="doctag">@link</span> BeanFactory&#125; that created them.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this interface is intended for framework-internal use only, however</span></span><br><span class="line"><span class="comment"> * must remain public in order to allow access to subclasses generated from other</span></span><br><span class="line"><span class="comment"> * packages (i.e. user code).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnhancedConfiguration</span> <span class="keyword">extends</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Conditional &#123;<span class="doctag">@link</span> Callback&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalCallbackFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalCallback</span> <span class="keyword">extends</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> CallbackFilter&#125; that works by interrogating &#123;<span class="doctag">@link</span> Callback Callbacks&#125; in the order</span></span><br><span class="line"><span class="comment"> * that they are defined via &#123;<span class="doctag">@link</span> ConditionalCallback&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callback[] callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt;[] callbackTypes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionalCallbackFilter</span><span class="params">(Callback[] callbacks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.callbacks = callbacks;</span><br><span class="line"><span class="keyword">this</span>.callbackTypes = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.callbackTypes[i] = callbacks[i].getClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.callbacks.length; i++) &#123;</span><br><span class="line">Callback callback = <span class="keyword">this</span>.callbacks[i];</span><br><span class="line"><span class="keyword">if</span> (!(callback <span class="keyword">instanceof</span> ConditionalCallback) || ((ConditionalCallback) callback).isMatch(method)) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No callback available for method "</span> + method.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getCallbackTypes() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.callbackTypes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Custom extension of CGLIB's DefaultGeneratorStrategy, introducing a &#123;<span class="doctag">@link</span> BeanFactory&#125; field.</span></span><br><span class="line"><span class="comment"> * Also exposes the application ClassLoader as thread context ClassLoader for the time of</span></span><br><span class="line"><span class="comment"> * class generation (in order for ASM to pick it up when doing common superclass resolution).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAwareGeneratorStrategy</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class"><span class="title">ClassLoaderAwareGeneratorStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BeanFactoryAwareGeneratorStrategy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClassGenerator <span class="title">transform</span><span class="params">(ClassGenerator cg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ClassEmitterTransformer transformer = <span class="keyword">new</span> ClassEmitterTransformer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end_class</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 给代理类塞进去一个public的$$beanFactory属性，用来BeanFactoryAware接口的setBF的时候拦截注入BF</span></span><br><span class="line">declare_field(Constants.ACC_PUBLIC, BEAN_FACTORY_FIELD, Type.getType(BeanFactory<span class="class">.<span class="keyword">class</span>), <span class="title">null</span>)</span>;</span><br><span class="line"><span class="keyword">super</span>.end_class();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TransformingClassGenerator(cg, transformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts the invocation of any &#123;<span class="doctag">@link</span> BeanFactoryAware#setBeanFactory(BeanFactory)&#125; on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class instances for the purpose of recording the &#123;<span class="doctag">@link</span> BeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnhancedConfiguration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryAwareMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">ConditionalCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Field field = ReflectionUtils.findField(obj.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">Assert.state(field != <span class="keyword">null</span>, <span class="string">"Unable to find generated BeanFactory field"</span>);</span><br><span class="line">field.set(obj, args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?</span></span><br><span class="line"><span class="comment">// If so, call its setBeanFactory() method. If not, just exit.</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">ClassUtils</span>.<span class="title">getUserClass</span>(<span class="title">obj</span>.<span class="title">getClass</span>().<span class="title">getSuperclass</span>()))) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 匹配是否是setBeanFactory方法</span></span><br><span class="line"><span class="keyword">return</span> isSetBeanFactory(candidateMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetBeanFactory</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (candidateMethod.getName().equals(<span class="string">"setBeanFactory"</span>) &amp;&amp;</span><br><span class="line">candidateMethod.getParameterCount() == <span class="number">1</span> &amp;&amp;</span><br><span class="line">BeanFactory<span class="class">.<span class="keyword">class</span> </span>== candidateMethod.getParameterTypes()[<span class="number">0</span>] &amp;&amp;</span><br><span class="line">BeanFactoryAware<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">candidateMethod</span>.<span class="title">getDeclaringClass</span>()))</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts the invocation of any &#123;<span class="doctag">@link</span> Bean&#125;-annotated methods in order to ensure proper</span></span><br><span class="line"><span class="comment"> * handling of bean semantics such as scoping and AOP proxying.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationClassEnhancer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">ConditionalCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enhance a &#123;<span class="doctag">@link</span> Bean <span class="doctag">@Bean</span>&#125; method to check the supplied BeanFactory for the</span></span><br><span class="line"><span class="comment"> * existence of this bean object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable as a catch-all for any exception that may be thrown when invoking the</span></span><br><span class="line"><span class="comment"> * super implementation of the proxied method i.e., the actual &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">MethodProxy cglibMethodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine whether this bean is a scoped-proxy</span></span><br><span class="line"><span class="keyword">if</span> (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">beanName = scopedBeanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To handle the case of an inter-bean method reference, we must explicitly check the</span></span><br><span class="line"><span class="comment">// container for already cached instances.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先检查是不是FactoryBean，是的话就创建一个子类并拦截getObject()方法，调用缓存的对象。</span></span><br><span class="line"><span class="comment">// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span></span><br><span class="line"><span class="comment">// proxy that intercepts calls to getObject() and returns any cached bean instance.</span></span><br><span class="line"><span class="comment">// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span></span><br><span class="line"><span class="comment">// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span></span><br><span class="line">            <span class="comment">// 如果是一个FactoryBean，而且&amp;beanName可以拿到，就去处理FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (factoryBean <span class="keyword">instanceof</span> ScopedProxyFactoryBean) &#123;</span><br><span class="line"><span class="comment">// Scoped proxy factory beans are a special case and should not be further proxied</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It is a candidate FactoryBean - go ahead with enhancement</span></span><br><span class="line"><span class="keyword">return</span> enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// BF在调用的时候，需要真的去创建</span></span><br><span class="line"><span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"><span class="comment">// The factory is calling the bean method in order to instantiate and register the bean</span></span><br><span class="line"><span class="comment">// (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually</span></span><br><span class="line"><span class="comment">// create the bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanMethod</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">logger.info(String.format(<span class="string">"@Bean method %s.%s is non-static and returns an object "</span> +</span><br><span class="line"><span class="string">"assignable to Spring's BeanFactoryPostProcessor interface. This will "</span> +</span><br><span class="line"><span class="string">"result in a failure to process annotations such as @Autowired, "</span> +</span><br><span class="line"><span class="string">"@Resource and @PostConstruct within the method's declaring "</span> +</span><br><span class="line"><span class="string">"@Configuration class. Add the 'static' modifier to this method to avoid "</span> +</span><br><span class="line"><span class="string">"these container lifecycle issues; see @Bean javadoc for complete details."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到bean的引用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">resolveBeanReference</span><span class="params">(Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The user (i.e. not the factory) is requesting this bean through a call to</span></span><br><span class="line"><span class="comment">// the bean method, direct or indirect. The bean may have already been marked</span></span><br><span class="line"><span class="comment">// as 'in creation' in certain autowiring scenarios; if so, temporarily set</span></span><br><span class="line"><span class="comment">// the in-creation status to false in order to avoid an exception.</span></span><br><span class="line"><span class="keyword">boolean</span> alreadyInCreation = beanFactory.isCurrentlyInCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> useArgs = !ObjectUtils.isEmpty(beanMethodArgs);</span><br><span class="line"><span class="keyword">if</span> (useArgs &amp;&amp; beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// Stubbed null arguments just for reference purposes,</span></span><br><span class="line"><span class="comment">// expecting them to be autowired for regular singleton references?</span></span><br><span class="line"><span class="comment">// A safe assumption since @Bean singleton arguments cannot be optional...</span></span><br><span class="line"><span class="keyword">for</span> (Object arg : beanMethodArgs) &#123;</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line">useArgs = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) :</span><br><span class="line">beanFactory.getBean(beanName));</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isAssignableValue(beanMethod.getReturnType(), beanInstance)) &#123;</span><br><span class="line"><span class="comment">// Detect package-protected NullBean instance through equals(null) check</span></span><br><span class="line"><span class="keyword">if</span> (beanInstance.equals(<span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">"@Bean method %s.%s called as bean reference "</span> +</span><br><span class="line"><span class="string">"for type [%s] returned null bean; resolving to null value."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),</span><br><span class="line">beanMethod.getReturnType().getName()));</span><br><span class="line">&#125;</span><br><span class="line">beanInstance = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String msg = String.format(<span class="string">"@Bean method %s.%s called as bean reference "</span> +</span><br><span class="line"><span class="string">"for type [%s] but overridden by non-compatible bean instance of type [%s]."</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName(),</span><br><span class="line">beanMethod.getReturnType().getName(), beanInstance.getClass().getName());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BeanDefinition beanDefinition = beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">msg += <span class="string">" Overriding bean of same name declared in: "</span> + beanDefinition.getResourceDescription();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore - simply no detailed message then.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line"><span class="keyword">if</span> (currentlyInvoked != <span class="keyword">null</span>) &#123;</span><br><span class="line">String outerBeanName = BeanAnnotationHelper.determineBeanNameFor(currentlyInvoked);</span><br><span class="line">beanFactory.registerDependentBean(beanName, outerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (alreadyInCreation) &#123;</span><br><span class="line">beanFactory.setCurrentlyInCreation(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(Method candidateMethod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (candidateMethod.getDeclaringClass() != Object<span class="class">.<span class="keyword">class</span> &amp;&amp;</span></span><br><span class="line"><span class="class">!<span class="title">BeanFactoryAwareMethodInterceptor</span>.<span class="title">isSetBeanFactory</span>(<span class="title">candidateMethod</span>) &amp;&amp;</span></span><br><span class="line"><span class="class"><span class="title">BeanAnnotationHelper</span>.<span class="title">isBeanAnnotated</span>(<span class="title">candidateMethod</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableBeanFactory <span class="title">getBeanFactory</span><span class="params">(Object enhancedConfigInstance)</span> </span>&#123;</span><br><span class="line">Field field = ReflectionUtils.findField(enhancedConfigInstance.getClass(), BEAN_FACTORY_FIELD);</span><br><span class="line">Assert.state(field != <span class="keyword">null</span>, <span class="string">"Unable to find generated bean factory field"</span>);</span><br><span class="line">Object beanFactory = ReflectionUtils.getField(field, enhancedConfigInstance);</span><br><span class="line">Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">"BeanFactory has not been injected into @Configuration class"</span>);</span><br><span class="line">Assert.state(beanFactory <span class="keyword">instanceof</span> ConfigurableBeanFactory,</span><br><span class="line"><span class="string">"Injected BeanFactory is not a ConfigurableBeanFactory"</span>);</span><br><span class="line"><span class="keyword">return</span> (ConfigurableBeanFactory) beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the BeanFactory to see whether the bean named &lt;var&gt;beanName&lt;/var&gt; already</span></span><br><span class="line"><span class="comment"> * exists. Accounts for the fact that the requested bean may be "in creation", i.e.:</span></span><br><span class="line"><span class="comment"> * we're in the middle of servicing the initial request for this bean. From an enhanced</span></span><br><span class="line"><span class="comment"> * factory method's perspective, this means that the bean does not actually yet exist,</span></span><br><span class="line"><span class="comment"> * and that it is now our job to create it for the first time by executing the logic</span></span><br><span class="line"><span class="comment"> * in the corresponding factory method.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Said another way, this check repurposes</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConfigurableBeanFactory#isCurrentlyInCreation(String)&#125; to determine whether</span></span><br><span class="line"><span class="comment"> * the container is calling this method or the user is calling this method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName name of bean to check for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether &lt;var&gt;beanName&lt;/var&gt; already exists in the factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">factoryContainsBean</span><span class="params">(ConfigurableBeanFactory beanFactory, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (beanFactory.containsBean(beanName) &amp;&amp; !beanFactory.isCurrentlyInCreation(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check whether the given method corresponds to the container's currently invoked</span></span><br><span class="line"><span class="comment"> * factory method. Compares method name and parameter types only in order to work</span></span><br><span class="line"><span class="comment"> * around a potential problem with covariant return types (currently only known</span></span><br><span class="line"><span class="comment"> * to happen on Groovy classes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCurrentlyInvokedFactoryMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">Method currentlyInvoked = SimpleInstantiationStrategy.getCurrentlyInvokedFactoryMethod();</span><br><span class="line"><span class="keyword">return</span> (currentlyInvoked != <span class="keyword">null</span> &amp;&amp; method.getName().equals(currentlyInvoked.getName()) &amp;&amp;</span><br><span class="line">Arrays.equals(method.getParameterTypes(), currentlyInvoked.getParameterTypes()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory</span></span><br><span class="line"><span class="comment"> * instead of creating a new instance. These proxies are created only when calling a FactoryBean from</span></span><br><span class="line"><span class="comment"> * within a Bean method, allowing for proper scoping semantics even when working against the FactoryBean</span></span><br><span class="line"><span class="comment"> * instance directly. If a FactoryBean instance is fetched through the container via &amp;-dereferencing,</span></span><br><span class="line"><span class="comment"> * it will not be proxied. This too is aligned with the way XML configuration works.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">enhanceFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean, Class&lt;?&gt; exposedType,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = factoryBean.getClass();</span><br><span class="line"><span class="keyword">boolean</span> finalClass = Modifier.isFinal(clazz.getModifiers());</span><br><span class="line"><span class="keyword">boolean</span> finalMethod = Modifier.isFinal(clazz.getMethod(<span class="string">"getObject"</span>).getModifiers());</span><br><span class="line"><span class="keyword">if</span> (finalClass || finalMethod) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedType.isInterface()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating interface proxy for FactoryBean '"</span> + beanName + <span class="string">"' of type ["</span> +</span><br><span class="line">clazz.getName() + <span class="string">"] for use within another @Bean method because its "</span> +</span><br><span class="line">(finalClass ? <span class="string">"implementation class"</span> : <span class="string">"getObject() method"</span>) +</span><br><span class="line"><span class="string">" is final: Otherwise a getObject() call would not be routed to the factory."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> createInterfaceProxyForFactoryBean(factoryBean, exposedType, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to proxy FactoryBean '"</span> + beanName + <span class="string">"' of type ["</span> +</span><br><span class="line">clazz.getName() + <span class="string">"] for use within another @Bean method because its "</span> +</span><br><span class="line">(finalClass ? <span class="string">"implementation class"</span> : <span class="string">"getObject() method"</span>) +</span><br><span class="line"><span class="string">" is final: A getObject() call will NOT be routed to the factory. "</span> +</span><br><span class="line"><span class="string">"Consider declaring the return type as a FactoryBean interface."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line"><span class="comment">// No getObject() method -&gt; shouldn't happen, but as long as nobody is trying to call it...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> createCglibProxyForFactoryBean(factoryBean, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createInterfaceProxyForFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean, Class&lt;?&gt; interfaceType,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">factoryBean.getClass().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;interfaceType&#125;,</span><br><span class="line">(proxy, method, args) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"getObject"</span>) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ReflectionUtils.invokeMethod(method, factoryBean, args);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createCglibProxyForFactoryBean</span><span class="params">(<span class="keyword">final</span> Object factoryBean,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> ConfigurableBeanFactory beanFactory, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(factoryBean.getClass());</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setCallbackType(MethodInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ideally create enhanced FactoryBean proxy without constructor side effects,</span></span><br><span class="line"><span class="comment">// analogous to AOP proxy creation in ObjenesisCglibAopProxy...</span></span><br><span class="line">Class&lt;?&gt; fbClass = enhancer.createClass();</span><br><span class="line">Object fbProxy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objenesis.isWorthTrying()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fbProxy = objenesis.newInstance(fbClass, enhancer.getUseCache());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ObjenesisException ex) &#123;</span><br><span class="line">logger.debug(<span class="string">"Unable to instantiate enhanced FactoryBean using Objenesis, "</span> +</span><br><span class="line"><span class="string">"falling back to regular construction"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fbProxy == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fbProxy = ReflectionUtils.accessibleConstructor(fbClass).newInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to instantiate enhanced FactoryBean using Objenesis, "</span> +</span><br><span class="line"><span class="string">"and regular FactoryBean instantiation via default constructor fails as well"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((Factory) fbProxy).setCallback(<span class="number">0</span>, (MethodInterceptor) (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (method.getName().equals(<span class="string">"getObject"</span>) &amp;&amp; args.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> proxy.invoke(factoryBean, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fbProxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#aop-mian-xiang-qie-mian-bian-cheng&quot;&gt;AOP 面向切面编程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#aop-sh
      
    
    </summary>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/categories/java/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="Spring" scheme="https://blog.sofunnyai.com/tags/Spring/"/>
    
      <category term="aop" scheme="https://blog.sofunnyai.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>代理模式的一切</title>
    <link href="https://blog.sofunnyai.com/article/proxy.html"/>
    <id>https://blog.sofunnyai.com/article/proxy.html</id>
    <published>2018-03-15T04:43:38.000Z</published>
    <updated>2020-07-19T15:27:29.786Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#dai-li-mo-shi-de-bei-jing">代理模式的背景</a><ul><li><a href="#jing-tai-dai-li">静态代理：</a></li><li><a href="#dong-tai-dai-li">动态代理</a><ul><li><a href="#ren-rou-po-su-si-xiang-de-shou-dong-dai-li">人肉朴素思想的手动代理</a></li><li><a href="#jdk-dong-tai-dai-li">JDK 动态代理</a></li><li><a href="#jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng">JDK动态代理为什是接口不是继承？</a></li><li><a href="#cglib">CGlib</a></li><li><a href="#javassist">Javassist</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="dai-li-mo-shi-de-bei-jing"> 代理模式的背景</span><a href="#dai-li-mo-shi-de-bei-jing" class="header-anchor">#</a></h1><p>假如我们有一个用户实现接口，如<code>UserService</code>，和实现类<code>UserServiceImpl</code>。现在想在<code>UserServiceImpl</code>的某些方法前后打印参数日志，可以选择的方式有：</p><h2><span id="jing-tai-dai-li"> 静态代理：</span><a href="#jing-tai-dai-li" class="header-anchor">#</a></h2><ul><li><p><strong>继承</strong>：写一个子类继承这个<code>UserServiceImpl</code>，然后方法前后加上日志功能。但是如果要再实现另外一个增强需求，就需要再次继承。或者对多个接口的方法同时进行增强，就要链式继承。长此以往产生类爆炸。</p></li><li><p><strong>聚合</strong>：<strong>装饰模式</strong>。实现同一个接口<code>UserService</code>，装饰器的构造方法传入一个同样的类，进行包装。在包装方法里面进行前后的增强，再去调用父类。[Java的IO流使用了大量的装饰模式]。和上面的代理很像，但是装饰模式只能装饰一个特定的对象，在构造方法里面传进来，实现同样的接口进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰模式增强，实现相同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDeractor</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法传入同样的对象进行包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceDeractor</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------------装饰模式增强，传入参数"</span>+name);</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：实现起来简单，但是代理类会比较多，比较复杂。</p></li></ul><h2><span id="dong-tai-dai-li"> 动态代理</span><a href="#dong-tai-dai-li" class="header-anchor">#</a></h2><p>基于以上的静态代理，会产生大量的class，如何改进？最浅显的想法就是</p><p>程序拼装这一段动态代理的java文件代码—&gt;然后生成class字节码—&gt;然后加载到项目中—&gt;创建对象并使用。</p><h3><span id="ren-rou-po-su-si-xiang-de-shou-dong-dai-li"> 人肉朴素思想的手动代理</span><a href="#ren-rou-po-su-si-xiang-de-shou-dong-dai-li" class="header-anchor">#</a></h3><p>基于以上思想我们试着实现一个山寨版</p><p>先来一个函数接口，用于动态封装我们的代理增强功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理增强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标包装对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,Object target, Object... args)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要对某个对象进行增强，就写一个Handler接口的实现，然后在invoke方法中增强。</p><p>将这个invoke传入到我们下面的<code>ProxyUtil</code>中去创建一个代理对象：</p><ul><li><code>public static &lt;T&gt; T getProxy(Object target, MyInvocationHandler handler, Class&lt;T&gt; ... interfaces) throws Exception</code>有三个参数，目标对象、增强实现（或者Lambda）、要实现的接口列表。</li><li>这个方法会把所有target的public方法进行重新生成java，每个方法里面调用<code>handler.invoke</code>进行增强</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人工模拟动态代理， 不用任何第三方jar，也不用JDK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要生成一个代理对象，必然要：</span></span><br><span class="line"><span class="comment">     * 1.先得到java代码</span></span><br><span class="line"><span class="comment">     * 2.然后把java代码变成class</span></span><br><span class="line"><span class="comment">     * 3.然后把class变成对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们动态实现那个装饰模式的静态代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Object target, MyInvocationHandler handler, Class&lt;T&gt; ... interfaces)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Class clazz = target.getClass();</span></span><br><span class="line">        <span class="keyword">if</span>(interfaces == <span class="keyword">null</span> || interfaces.length==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"该对象没有实现接口，无法代理！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Class interfaceClazz = clazz.getInterfaces()[0];</span></span><br><span class="line">        System.out.println(<span class="string">"即将针对接口"</span>+interfaces+<span class="string">"进行动态代理..."</span>);</span><br><span class="line">        <span class="comment">// 拼装java类</span></span><br><span class="line">        StringBuffer java = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String proxyPackage = <span class="string">"com.sam.proxy"</span>;</span><br><span class="line">        java.append(<span class="string">"package "</span>+proxyPackage+<span class="string">";\n\n"</span>);</span><br><span class="line">        <span class="comment">// 引入接口</span></span><br><span class="line">        java.append(Arrays.stream(interfaces).map(c-&gt;<span class="string">"import "</span>+c.getName()).collect(Collectors.joining(<span class="string">";\n"</span>))+<span class="string">";\n"</span>);</span><br><span class="line">        java.append(</span><br><span class="line">                <span class="string">"import "</span>+target.getClass().getName()+<span class="string">";\n"</span> +</span><br><span class="line">                <span class="string">"import java.util.Arrays;\n"</span> +</span><br><span class="line">                "import "+MyInvocationHandler.class.getName()+";\n\n" +  // import MyInvocationHandler</span><br><span class="line">                 <span class="string">"// TODO 这个类是由ProxyUtil自动生成的\n"</span>+</span><br><span class="line">                <span class="comment">// 接口$Myproxy         此处也可以使用</span></span><br><span class="line">                <span class="string">"public class MyProxyOf"</span>+target.getClass().getSimpleName()+<span class="string">" implements "</span>+ Arrays.stream(interfaces).map(Class::getSimpleName).collect(Collectors.joining(<span class="string">","</span>))+<span class="string">" &#123;\n"</span> +</span><br><span class="line">                <span class="comment">// private 接口 target</span></span><br><span class="line">                <span class="string">"    private "</span>+target.getClass().getSimpleName()+<span class="string">" target;\n"</span> +</span><br><span class="line">                "    private "+MyInvocationHandler.class.getSimpleName()+" handler;\n\n" +</span><br><span class="line">                <span class="comment">// 构造方法包装</span></span><br><span class="line">                "    public MyProxyOf"+target.getClass().getSimpleName()+"("+target.getClass().getSimpleName()+" target, "+MyInvocationHandler.class.getSimpleName()+" h)&#123;\n" +</span><br><span class="line">                <span class="string">"        this.target = target;\n"</span> +</span><br><span class="line">                <span class="string">"        this.handler = h;\n"</span> +</span><br><span class="line">                <span class="string">"    &#125;\n"</span>);</span><br><span class="line">        <span class="comment">// 不用在每个方法处理，使用动态处理</span></span><br><span class="line">        <span class="keyword">for</span>(Method method : target.getClass().getDeclaredMethods())&#123;</span><br><span class="line">            <span class="comment">// public com.xx.xx.User getUser(java.lang.String</span></span><br><span class="line">            java.append(<span class="string">"\n\t@Override\n\tpublic "</span>+method.getReturnType().getName()+<span class="string">" "</span>+method.getName()+<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// String name)&#123;</span></span><br><span class="line">            List&lt;String&gt; params = IntStream.range(<span class="number">0</span>,method.getParameterTypes().length).mapToObj(i-&gt;method.getParameterTypes()[i].getName() +<span class="string">" var"</span>+i).collect(Collectors.toList());</span><br><span class="line">            java.append(String.join(<span class="string">", "</span>,params));<span class="comment">// java.lang.String var1, java.lang.Integer var2</span></span><br><span class="line">            java.append(<span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getExceptionTypes().length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                java.append(<span class="string">"thorws "</span>+ Arrays.stream(method.getExceptionTypes()).map(Class::getName).collect(Collectors.joining(<span class="string">", "</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"&#123;\n"</span>);</span><br><span class="line"><span class="comment">// 开始调用invoke或者lambda进行代理增强！</span></span><br><span class="line">            java.append(<span class="string">"\t\tSystem.out.println(\"代理对象中即将调用invoke.....\");\n"</span>);</span><br><span class="line">            <span class="comment">// 调用包装类target的方法，进行增强</span></span><br><span class="line">            java.append(<span class="string">"\t\ttry&#123;\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getParameterTypes().length == <span class="number">0</span>)&#123;</span><br><span class="line">                java.append("\t\t\t"+(method.getReturnType()==void.class?"":("return ("+method.getReturnType().getName()+")"))+"handler.invoke(this, target.getClass().getMethod(\""+method.getName()+"\"), target);\n");</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt;vars = IntStream.range(<span class="number">0</span>,method.getParameterTypes().length).mapToObj(i-&gt;<span class="string">"var"</span>+i).collect(Collectors.toList());</span><br><span class="line">                List&lt;String&gt;paramClazz = Arrays.stream(method.getParameterTypes()).map(c-&gt;c.getName()+<span class="string">".class"</span>).collect(Collectors.toList());</span><br><span class="line">                java.append(<span class="string">"\t\t\tClass[] paramClazz = new Class[]&#123;"</span>+String.join(<span class="string">","</span>,paramClazz)+<span class="string">"&#125;;\n"</span>);</span><br><span class="line">                java.append("\t\t\t"+(method.getReturnType()==void.class?"":("return ("+method.getReturnType().getName()+")"))+"handler.invoke(this, target.getClass().getMethod(\""+method.getName()+"\", paramClazz), target, "+String.join(",",vars)+");\n");</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            java.append(<span class="string">"\t\t&#125;catch(Exception ex)&#123;\n"</span>);</span><br><span class="line">            <span class="comment">//method.getExceptionTypes()</span></span><br><span class="line">            <span class="keyword">if</span>(method.getExceptionTypes().length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                java.append(<span class="string">"\t\tList&lt;Class&gt; methodExs = Arrays.asList("</span>+ String.join(<span class="string">","</span>,Arrays.stream(method.getExceptionTypes()).map(c-&gt;c.getName()+<span class="string">".class"</span>).collect(Collectors.toList()))+<span class="string">");\n"</span>);</span><br><span class="line">                java.append(<span class="string">"\t\t\tif(methodExs.contains(ex.getClass()))&#123;throw ex;&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"\t\t\tex.printStackTrace();\n"</span>);</span><br><span class="line">            <span class="keyword">if</span>(method.getReturnType() != <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span>&#123; <span class="comment">// 异常时候返回null</span></span><br><span class="line">                java.append(<span class="string">"\t\t\treturn null;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            java.append(<span class="string">"\t\t&#125;\n"</span>); <span class="comment">// 结束catch</span></span><br><span class="line">            java.append(<span class="string">"\t&#125;\n"</span>);<span class="comment">// 结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        java.append(<span class="string">"&#125;\n"</span>);</span><br><span class="line">        <span class="comment">//System.out.println(java);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 落盘</span></span><br><span class="line">        String filePath = System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/src/main/java/"</span>+proxyPackage.replaceAll(<span class="string">"\\."</span>,<span class="string">"/"</span>);</span><br><span class="line">        String fileprefix = <span class="string">"MyProxyOf"</span>+target.getClass().getSimpleName();</span><br><span class="line">        File dir = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        File javaFile = <span class="keyword">new</span> File(filePath + <span class="string">"/"</span> +fileprefix +<span class="string">".java"</span>);</span><br><span class="line">        <span class="keyword">if</span>(javaFile.exists())&#123;</span><br><span class="line">            javaFile.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(javaFile);</span><br><span class="line">        fw.write(java.toString());</span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.close();</span><br><span class="line">        <span class="keyword">boolean</span> result = compilerJavaFile(filePath + <span class="string">"/"</span> + fileprefix +<span class="string">".java"</span>,System.getProperty(<span class="string">"user.dir"</span>)+<span class="string">"/target/classes/"</span>);</span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            <span class="comment">// 因为上一步编译到了当前工程的target中，在classpath里面，所以可以Class.forName</span></span><br><span class="line">            <span class="comment">// TODO 如果是线上编译到一个类似/tmp目录，这里需要使用URLClassloader去LoadClass加载进来才行</span></span><br><span class="line">            Class tClass = Class.forName(proxyPackage+<span class="string">".MyProxyOf"</span>+target.getClass().getSimpleName());</span><br><span class="line">            <span class="comment">// 找到装饰模式的那个构造方法，传入装饰器包装的原始对象</span></span><br><span class="line">            <span class="keyword">return</span> (T) tClass.getConstructor(target.getClass(),MyInvocationHandler<span class="class">.<span class="keyword">class</span>).<span class="title">newInstance</span>(<span class="title">target</span>,<span class="title">handler</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态编译java文件到class字节码，需要把JDK/lib/tools.jar加入到环境变量中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFileInputPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classFileOutputPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compilerJavaFile</span><span class="params">(String sourceFileInputPath, String classFileOutputPath)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sourceFileInputPath="</span>+sourceFileInputPath);</span><br><span class="line">        System.out.println(<span class="string">"classFileOutputPath="</span>+classFileOutputPath);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 设置编译选项，配置class文件输出路径</span></span><br><span class="line">            System.out.println(<span class="string">"输出到:"</span>+classFileOutputPath);</span><br><span class="line">            Iterable&lt;String&gt; options = Arrays.asList(<span class="string">"-d"</span>, classFileOutputPath);</span><br><span class="line">            StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Iterable&lt;? extends JavaFileObject&gt; compilationUnits = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(<span class="keyword">new</span> File(sourceFileInputPath)));</span><br><span class="line">            <span class="keyword">boolean</span> flag = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, options, <span class="keyword">null</span>, compilationUnits).call();</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">"动态编译成功！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ClassNotFoundException)&#123;</span><br><span class="line">                System.out.println(<span class="string">"动态编译失败！"</span>);</span><br><span class="line">                System.out.println(<span class="string">"把JDK/lib/tools.jar加入到环境变量中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        UserService instance = getProxy(<span class="keyword">new</span> UserServiceImpl(), (proxy,method,target,params)-&gt;&#123; System.out.println(<span class="string">"在lambda中的增强代理....."</span>);<span class="keyword">return</span> method.invoke(target,params); &#125;, UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"-----------------开始运行"</span>);</span><br><span class="line">        instance.addUser(<span class="keyword">new</span> User(<span class="string">"wangwu"</span>,<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 这个类是由ProxyUtil自动生成的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyOfUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl target;</span><br><span class="line">    <span class="keyword">private</span> MyInvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyOfUserServiceImpl</span><span class="params">(UserServiceImpl target, MyInvocationHandler h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.handler = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> com.sam.bootdemo.model.<span class="function">User <span class="title">getUser</span><span class="params">(java.lang.String var0)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class[] paramClazz = <span class="keyword">new</span> Class[]&#123;java.lang.String<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"><span class="keyword">return</span> (com.sam.bootdemo.model.User)handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"getUser"</span>, paramClazz), target, var0);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(com.sam.bootdemo.model.User var0)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Class[] paramClazz = <span class="keyword">new</span> Class[]&#123;com.sam.bootdemo.model.User<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"addUser"</span>, paramClazz), target, var0);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"代理对象中即将调用invoke....."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">handler.invoke(<span class="keyword">this</span>, target.getClass().getMethod(<span class="string">"initService"</span>), target);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以正常运行并输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动态编译成功！</span><br><span class="line">-----------------开始运行</span><br><span class="line">代理对象中即将调用invoke.....</span><br><span class="line">在lambda中的增强代理.....</span><br><span class="line">UserServiceImpl假装addUser：User(userName&#x3D;wangwu, age&#x3D;20)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="jdk-dong-tai-dai-li"> JDK 动态代理</span><a href="#jdk-dong-tai-dai-li" class="header-anchor">#</a></h3><p>JDK动态代理使用<code>InvocationHandler</code>实现，和我们上面的思想很像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个增强器，来拦截我们包装target的方法，进行业务增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceInvocationHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理方法的增强器</span></span><br><span class="line"><span class="comment">     * 调用代理对象的业务对象的时候会来执行这个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-------UserServiceInvocationHandler.invoke代理增强"</span>);</span><br><span class="line">        <span class="comment">// 此处进行拦截增强</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);  <span class="comment">// 执行target的真正业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试JDK的动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"===================JDKProxy InvocationHandler========================="</span>);</span><br><span class="line"><span class="comment">// jdk动态代理</span></span><br><span class="line"><span class="comment">// 为啥要classloader？因为JVM启动的时候已经加载了project的所有class。</span></span><br><span class="line"><span class="comment">// 但是项目运行过程中动态生成了calss，所以要传入classloader去加载这个class。</span></span><br><span class="line"><span class="comment">// 为啥不是URLClassLoader去远程加载？因为JDK动态代理产生的项目是在classpath下的</span></span><br><span class="line"><span class="comment">// 传入classloader、接口、和要增强的InvocationHandler</span></span><br><span class="line">UserService service3 = (UserService) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                                                            <span class="keyword">new</span> Class[]&#123;UserService<span class="class">.<span class="keyword">class</span>&#125;, <span class="title">new</span> <span class="title">UserServiceInvocationHandler</span>(<span class="title">new</span> <span class="title">UserServiceImpl</span>()))</span>;</span><br><span class="line">service3.getUser(<span class="string">"小马"</span>);</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><ul><li><p>Class使用来描述一个类的，看起来是废话。但是很重要，仔细体会。</p></li><li><p>Class对象如  <code>Class userClazz = Clazz.forname(&quot;com.xxx.User&quot;)</code>就可以拿到User类的详细信息，包括属性、方法、构造方法等等。</p></li><li><p><code>一个java文件---&gt;编译成class文件---&gt;解析成byte[]到JVM中---&gt;构建为类对象Class-----&gt;newInstance变成实例</code></p></li><li><p>判断两个对象是否相等，首先判断类加载器是否同一个，不是的话就不相等。这块动态代理判断了。传进去的接口列表使用用户的ClassLoader先加载一遍forName的结果，看看和传进来的是否相同。</p></li><li><p>默认生成的代理类在<code>com.sun.proxy</code>这个包名下如<code>com.sun.proxy.$Proxy0</code>，除非有interface不是public的，会生成到这个interface同包名下（否则无法外部implements访问到）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.reflect.Proxy中获取到包名后生成class字节流的方法，使用了native方法生成</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><p>JDK上面那一步动态生成的类，我们反编译后看一眼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sam.bootdemo.model.User;</span><br><span class="line"><span class="keyword">import</span> com.sam.bootdemo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了JDK的Proxy，所以不能继承我们的目标对象，只能是实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反射获取了我们UserService接口中需要覆盖的方法，同时反射拿到要覆盖的hashCode、equals、toString方法</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"initService"</span>);</span><br><span class="line">            m5 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"addUser"</span>, Class.forName(<span class="string">"com.sam.bootdemo.model.User"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.sam.bootdemo.service.UserService"</span>).getMethod(<span class="string">"getUser"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法传入了我们写的增强类InvocationHandler，塞到父类Proxy中了</span></span><br><span class="line">    <span class="comment">// 这个handler里面有包装我们的原始userServiceImpl对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 因为实现了同样的UserService接口，这里代理实现</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> User <span class="title">getUser</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用了invocationHandler的invoke方法，传入 代理对象、method、参数。（但是缺少真正的target，target在invocationhandler中，也就是我们要增强的userServiceImpl对象）</span></span><br><span class="line">            <span class="keyword">return</span> (User)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initService</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User var1)</span> <span class="keyword">throws</span> FileNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | FileNotFoundException | SQLException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString、equals、hashCode也调用了invocationHandler的invoke方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现JDK生成代理类的逻辑和我们之前手动山寨版的很像。只是JDK是调用native方法直接生成字节流数组。我们是拼装java，再动态编译为class的。</p><p>虽然是native方法，但JDK也是通过反射生成的，他反射读取了我们接口中的方法列表，逐个实现，然后生成到class流里的。</p><p><strong>缺点：</strong> 必须要有接口，才能生成动态代理。如果对象没有接口就无法进行代理。</p><h3><span id="jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng"> JDK动态代理为什是接口不是继承？</span><a href="#jdk-dong-tai-dai-li-wei-shi-shi-jie-kou-bu-shi-ji-cheng" class="header-anchor">#</a></h3><p>因为Java是单继承的，JDK底层源码已经继承了proxy对象， 里面存放了invocationHandler（invocationHandler里面包装了我们的目标对象）。所以不能再继承我们的目标对象。</p><p>只能去和目标对象实现相同的接口，包装一下，具有相同行为。</p><h3><span id="cglib"> CGlib</span><a href="#cglib" class="header-anchor">#</a></h3><p>使用基于继承的方式，使用ASM进行字节码操作完成代理增强。都是直接操作字节码和JDK比起来性能差异不大。</p><h3><span id="javassist"> Javassist</span><a href="#javassist" class="header-anchor">#</a></h3><p>也可以实现字节码增强的代理，使用不太多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#dai-li-mo-shi-de-bei-jing&quot;&gt;代理模式的背景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#jing-tai-dai-li&quot;&gt;静
      
    
    </summary>
    
    
      <category term="spring" scheme="https://blog.sofunnyai.com/categories/spring/"/>
    
    
      <category term="java" scheme="https://blog.sofunnyai.com/tags/java/"/>
    
      <category term="spring" scheme="https://blog.sofunnyai.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>CacheLine和伪共享</title>
    <link href="https://blog.sofunnyai.com/article/cacheline-contended.html"/>
    <id>https://blog.sofunnyai.com/article/cacheline-contended.html</id>
    <published>2018-03-11T01:44:53.000Z</published>
    <updated>2020-06-15T03:12:53.309Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#cacheline-jian-jie">CacheLine简介</a></li><li><a href="#wei-shi-me-cacheline-bing-fa-man">为什么CacheLine并发慢？</a><ul><li><a href="#mesi-huan-cun-yi-zhi-xing-xie-yi">MESI缓存一致性协议</a></li></ul></li><li><a href="#falsesharing-wei-gong-xiang-wen-ti"><strong>FalseSharing</strong>伪共享问题</a></li><li><a href="#wei-gong-xiang-de-jie-jue-fang-an">伪共享的解决方案</a><ul><li><a href="#yuan-shi-you-huan-cun-xing-jing-zheng-de-wen-ti">原始有缓存行竞争的问题</a></li><li><a href="#jdk8-yi-qian-ren-rou-jie-jue">JDK8以前人肉解决：</a></li><li><a href="#jdk8-yi-hou-contended-jie-jue">JDK8以后@Contended解决：</a></li></ul></li><li><a href="#que-ren-nei-cun-bu-ju">确认内存布局</a></li><li><a href="#xiao-guo-ce-shi">效果测试</a><ul><li><a href="#ce-shi-yuan-shi-wen-ti-ren-rou-you-hua-contended-you-hua">测试原始问题、人肉优化、<code>@Contended</code>优化。</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="cacheline-jian-jie"> CacheLine简介</span><a href="#cacheline-jian-jie" class="header-anchor">#</a></h1><p>CPU缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，目前主流的CPU Cache的Cache Line大小都是64Bytes（和操作系统、CPU有关）。**当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。**缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。</p><p>由于共享变量在CPU缓存中的存储是以缓存行为单位，一个缓存行可以存储多个变量（存满当前缓存行的字节数）；而CPU对缓存的修改又是以缓存行为最小单位的，如果多线程同时修改同一缓存行上的两个变量，那么就会出现上诉的伪共享问题。</p><p>伪共享是无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。对于多线程编程来说，<strong>特别是多线程处理列表和数组的时候</strong>，要非常注意伪共享的问题。否则不仅无法发挥多线程的优势，还可能比单线程性能还差。</p><h1><span id="wei-shi-me-cacheline-bing-fa-man"> 为什么CacheLine并发慢？</span><a href="#wei-shi-me-cacheline-bing-fa-man" class="header-anchor">#</a></h1><ul><li>下面的图中，X和Y在同一缓存行中，读取的时候只能一起从“内存–L3–L2–L1–寄存器”去加载。使用的时候反着从“寄存器-L1-L2-L3-主存”去拿，走得越远越慢。</li><li>所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</li><li>但是当core1修改X的时候，把这个CacheLine读取进来修改完毕，根据MESI缓存一致性协议，缓存行会失效。需要从下级Cache或者其他核心的Cache，甚至主存重新load。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615095526972.png" alt="image-20200615095526972"></p><h2><span id="mesi-huan-cun-yi-zhi-xing-xie-yi"> MESI缓存一致性协议</span><a href="#mesi-huan-cun-yi-zhi-xing-xie-yi" class="header-anchor">#</a></h2><p>是多种一致性协议中的一种实现，规定缓存在同一时间只有一种状态：</p><p>在MESI协议中，每个Cache line有4个状态，可用2个bit表示，它们分别是：<br>M(Modified)：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中；<br>E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中；<br>S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中；<br>I(Invalid)：这行数据无效。</p><p>那么，假设有一个变量i=3（应该是包括变量i的缓存块，块大小为缓存行大小）；</p><p>已经加载到多核（a,b,c）的缓存中，此时该缓存行的状态为S(Share共享有效)；</p><p>此时其中的一个核a改变了变量i的值，那么在核a中的当前缓存行的状态将变为M（有效但修改了，和内存不一致），b,c核中的当前缓存行状态将变为I（无效）。如下图：</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200615104347330.png" alt="image-20200615104347330"></p><h1><span id="falsesharing-wei-gong-xiang-wen-ti"> <strong>FalseSharing</strong>伪共享问题</span><a href="#falsesharing-wei-gong-xiang-wen-ti" class="header-anchor">#</a></h1><p>在上面的情况下a核心修改后缓存状态变为M，b和c核心的缓存变为I无效，去重新load（从其他核心的缓存中同步，或者从主存同步，看CPU实现了）。</p><p>此时在核b上运行的线程，正好想要修改变量Y，那么就会出现相互竞争，相互失效的情况，这就是伪共享啦。</p><h1><span id="wei-gong-xiang-de-jie-jue-fang-an"> 伪共享的解决方案</span><a href="#wei-gong-xiang-de-jie-jue-fang-an" class="header-anchor">#</a></h1><p>下面使用一个带有long类型的简单对象来测试（使用一个long数组测试也行，略不直观）</p><h2><span id="yuan-shi-you-huan-cun-xing-jing-zheng-de-wen-ti"> 原始有缓存行竞争的问题</span><a href="#yuan-shi-you-huan-cun-xing-jing-zheng-de-wen-ti" class="header-anchor">#</a></h2><p>如下，假设一个数组有多个Obj1对象。我们多线程需要对不同位置的Obj1的x进行并发赋值，在修改的时候会因为一次load了多个Obj1到内存中，就会产生缓存行互相失效的竞争问题。这就是原始的伪共享问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象一个父类，为了完成缓存行通用测试，无意义。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通未进行缓存行优化的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj1</span> <span class="keyword">extends</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x;  <span class="comment">// 假设一个数组有多个Obj1对象，我们多线程需要对不同位置的Obj1的x进行赋值，在修改的时候会因为一次load了多个Obj1到内存中，就会产生缓存行竞争</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="jdk8-yi-qian-ren-rou-jie-jue"> JDK8以前人肉解决：</span><a href="#jdk8-yi-qian-ren-rou-jie-jue" class="header-anchor">#</a></h2><p>前后各加8个long（64位）来规避缓存行竞争，在诸如Disruptor等追求极致性能的地方会见到这种代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存行优化对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj2</span> <span class="keyword">extends</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p1,p2,p3,p4,p5,p6,p7;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  因为对象前7个long+x是64个字节，正好一个缓存行。后面也是。</span></span><br><span class="line"><span class="comment">     *  所以多线程写的时候，两个线程永远不在一个缓存行中，效率更高。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">long</span> p8,p9,p10,p11,p12,p13,p14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="jdk8-yi-hou-contended-jie-jue"> JDK8以后@Contended解决：</span><a href="#jdk8-yi-hou-contended-jie-jue" class="header-anchor">#</a></h2><p>使用@Contended注解自动进行缓存行填充，防止多线程竞争缓存行。JVM会给我们前后各加128bit的padding，保证规避了缓存行竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用<span class="doctag">@Contended</span>注解自动进行缓存行填充，防止多线程竞争缓存行</span></span><br><span class="line"><span class="comment"> * 执行时，必须加上虚拟机参数-XX:-RestrictContended，<span class="doctag">@Contended</span>注释才会生效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Obj3</span> <span class="keyword">extends</span> <span class="title">Obj</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="que-ren-nei-cun-bu-ju"> 确认内存布局</span><a href="#que-ren-nei-cun-bu-ju" class="header-anchor">#</a></h1><p>我们的两种优化是不是真的有效呢？JOL看一下这三个对象的内存布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Obj1 obj1 = <span class="keyword">new</span> Obj1();</span><br><span class="line">Obj2 obj2 = <span class="keyword">new</span> Obj2();</span><br><span class="line">Obj3 obj3 = <span class="keyword">new</span> Obj3();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(obj1).toPrintable());</span><br><span class="line">System.out.println(ClassLayout.parseInstance(obj2).toPrintable());</span><br><span class="line">System.out.println(ClassLayout.parseInstance(obj3).toPrintable());</span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>没加缓存行优化的Obj1：我们的核心属性，前后没有缓存行对齐，直接多线程修改它是有伪共享问题的（两个Obj1的x在同一个缓存行中）</li><li>使用人肉8个long进行缓存行优化的Obj2：我们的核心属性，前后都有64位的填充，多线程竞争也不会使得两个Obj2对象的x在同一个缓存行中</li><li>使用JDK自带@Contended修饰的Obj3：前后各有一个长达128字节的填充，多线程竞争也不会使得两个Obj2对象的x在同一个缓存行中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没加缓存行优化的简单extends的Obj1：</span></span><br><span class="line">com.xxxx.Obj1 object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           81 c1 00 f8 (10000001 11000001 00000000 11111000) (-134168191)</span><br><span class="line">     12     4        (alignment/padding gap)                  </span><br><span class="line">     16     8   long Obj.x                                     0</span><br><span class="line">     24     8   long Obj1.x                                    0 <span class="comment"># 我们的核心属性，前后没有缓存行对齐，直接多线程修改它是有伪共享问题的（两个Obj1的x在同一个缓存行中）</span></span><br><span class="line">Instance size: 32 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 人肉使用了一堆long进行占位</span></span><br><span class="line">com.xxxx.Obj2 object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           bf c1 00 f8 (10111111 11000001 00000000 11111000) (-134168129)</span><br><span class="line">     12     4        (alignment/padding gap)                  </span><br><span class="line">     16     8   long Obj.x                                     0 <span class="comment"># 这个是继承的，不用管</span></span><br><span class="line">     24     8   long Obj2.p1                                   0</span><br><span class="line">     32     8   long Obj2.p2                                   0</span><br><span class="line">     40     8   long Obj2.p3                                   0</span><br><span class="line">     48     8   long Obj2.p4                                   0</span><br><span class="line">     56     8   long Obj2.p5                                   0</span><br><span class="line">     64     8   long Obj2.p6                                   0</span><br><span class="line">     72     8   long Obj2.p7                                   0</span><br><span class="line">     80     8   long Obj2.x                                    0 <span class="comment"># 我们的核心属性，前后都有64位的填充，多线程竞争也不会使得两个Obj2对象的x在同一个缓存行中</span></span><br><span class="line">     88     8   long Obj2.p8                                   0</span><br><span class="line">     96     8   long Obj2.p9                                   0</span><br><span class="line">    104     8   long Obj2.p10                                  0</span><br><span class="line">    112     8   long Obj2.p11                                  0</span><br><span class="line">    120     8   long Obj2.p12                                  0</span><br><span class="line">    128     8   long Obj2.p13                                  0</span><br><span class="line">    136     8   long Obj2.p14                                  0</span><br><span class="line">Instance size: 144 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用JDK的@Contended修饰的class</span></span><br><span class="line">com.xxxx.Obj3 object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           05 c2 00 f8 (00000101 11000010 00000000 11111000) (-134168059)</span><br><span class="line">     12     4        (alignment/padding gap)                  </span><br><span class="line">     16     8   long Obj.x                                     0</span><br><span class="line">     24   128        (alignment/padding gap)                  <span class="comment"># 前面有一个长达128字节的填充</span></span><br><span class="line">    152     8   long Obj3.x                                    0 <span class="comment"># 我们的核心对象</span></span><br><span class="line">    160   128        (loss due to the next object alignment) <span class="comment"># 后面也有一个长达128的填充</span></span><br><span class="line">Instance size: 288 bytes</span><br><span class="line">Space losses: 132 bytes internal + 128 bytes external = 260 bytes total</span><br></pre></td></tr></table></figure><h1><span id="xiao-guo-ce-shi"> 效果测试</span><a href="#xiao-guo-ce-shi" class="header-anchor">#</a></h1><p>下面是工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试缓存行工具方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCacheLine</span><span class="params">(Obj[] arr)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        <span class="comment">// 一亿次</span></span><br><span class="line">        <span class="keyword">long</span> times = <span class="number">1_0000_0000l</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 启动2个线程，对数组的两个位置进行竞争修改</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (Long i = <span class="number">0l</span>; i &lt; times; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (Long i = <span class="number">0l</span>; i &lt; times; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 等待两个线程都执行完毕，计时</span></span><br><span class="line">        latch.await();</span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(watch.getTime());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="ce-shi-yuan-shi-wen-ti-ren-rou-you-hua-contended-you-hua"> 测试原始问题、人肉优化、<code>@Contended</code>优化。</span><a href="#ce-shi-yuan-shi-wen-ti-ren-rou-you-hua-contended-you-hua" class="header-anchor">#</a></h3><p>注意<code>@Contended</code>需要运行的时候加上<code>-XX:-RestrictContended</code>参数才生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 结果很慢，因为对象里只有一个long是8个字节，缓存行64个字节。</span></span><br><span class="line"><span class="comment">             * 多个线程并发写的时候，必然需要进行缓存行同步。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Obj [] arr1 = <span class="keyword">new</span> Obj1[<span class="number">2</span>];</span><br><span class="line">            arr1[<span class="number">0</span>] = <span class="keyword">new</span> Obj1();</span><br><span class="line">            arr1[<span class="number">1</span>] = <span class="keyword">new</span> Obj1();</span><br><span class="line">            <span class="comment">// 缓存行伪共享测试</span></span><br><span class="line">            testCacheLine(arr1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 快，因为对象前7个long+x是64个字节，正好一个缓存行。后面也是。</span></span><br><span class="line"><span class="comment">             * 所以多线程写的时候，两个线程永远不在一个缓存行中，效率更高。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Obj [] arr2 = <span class="keyword">new</span> Obj2[<span class="number">2</span>];</span><br><span class="line">            arr2[<span class="number">0</span>] = <span class="keyword">new</span> Obj2();</span><br><span class="line">            arr2[<span class="number">1</span>] = <span class="keyword">new</span> Obj2();</span><br><span class="line">            <span class="comment">// 缓存行伪共享优化测试</span></span><br><span class="line">            testCacheLine(arr2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 快，因为<span class="doctag">@Contended</span>会自动填充，正好一个缓存行。后面也是。</span></span><br><span class="line"><span class="comment">             * 所以多线程写的时候，两个线程永远不在一个缓存行中，效率更高。</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@Contended</span> 需要加上-XX:-RestrictContended才生效</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Obj [] arr3 = <span class="keyword">new</span> Obj3[<span class="number">2</span>];</span><br><span class="line">            arr3[<span class="number">0</span>] = <span class="keyword">new</span> Obj3();</span><br><span class="line">            arr3[<span class="number">1</span>] = <span class="keyword">new</span> Obj3();</span><br><span class="line">            testCacheLine(arr3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多次运行可以发现未优化的速度明显慢于后两者优化后的：</p><p>后两者优化后的差异不大，通常都很接近。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1802</span><br><span class="line">674</span><br><span class="line">874</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cacheline-jian-jie&quot;&gt;CacheLine简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#wei-shi-me-cacheline-
      
    
    </summary>
    
    
      <category term="并发" scheme="https://blog.sofunnyai.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="多线程" scheme="https://blog.sofunnyai.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://blog.sofunnyai.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>spring源码浅析</title>
    <link href="https://blog.sofunnyai.com/article/spring-start.html"/>
    <id>https://blog.sofunnyai.com/article/spring-start.html</id>
    <published>2018-03-07T16:24:39.000Z</published>
    <updated>2020-07-24T18:05:54.204Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#spring">Spring</a><ul><li><a href="#beandefinition">BeanDefinition</a></li><li><a href="#ioc">IOC</a></li><li><a href="#yi-xie-xi-jie">一些细节</a><ul><li><a href="#xml-xi-jie">xml细节</a></li><li><a href="#zhu-jie-xi-jie">注解细节</a></li><li><a href="#qi-ta-xi-jie">其他细节</a></li></ul></li></ul></li><li><a href="#qi-dong-guo-cheng">启动过程</a></li><li><a href="#spring-jie-jue-xun-huan-yi-lai-fang-an">spring解决循环依赖方案</a></li><li><a href="#springframework-de-tuo-zhan-dian">SpringFramework的拓展点</a><ul><li><a href="#tong-guo-beanpostprocesso-ding-zhi-hua-bean">通过 <code>BeanPostProcesso</code>定制化Bean</a></li><li><a href="#tong-guo-tuo-zhan-beanfactorypostprocessor-zi-ding-yi-pei-zhi-xin-xi">通过拓展<code>BeanFactoryPostProcessor</code>自定义配置信息</a></li><li><a href="#beanfactory-he-factorybean">BeanFactory和FactoryBean</a></li></ul><ul><li><a href="#zi-ding-yi-chu-shi-hua-qi-initializer-tuo-zhan">自定义初始化器<strong>initializer</strong>拓展</a></li><li><a href="#zi-ding-yi-jian-ting-qi-listener-tuo-zhan">自定义监听器listener拓展</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="spring"> Spring</span><a href="#spring" class="header-anchor">#</a></h1><p>虽然编码多年，我们再来重新认识Spring这个老朋友：</p><ul><li>spring有一大堆项目，核心的spring framework，以及发展而来的springboot、springcloud，工具类的spring-data、spring-security等</li><li>spring framework通常的误区大家说他有IOC和AOP，然而并不是。<ul><li>他的核心至少有： IoC Container, Events, Resources, i18n, Validation, Data Binding, Type Conversion, SpEL, AOP.</li><li>常用附加的还有：Transactions、JDBC、Spring MVC, WebSocket、JMS</li><li>以及新兴的：Spring WebFlux</li></ul></li></ul><h2><span id="beandefinition"> BeanDefinition</span><a href="#beandefinition" class="header-anchor">#</a></h2><p>用来描述我们的<code>Bean</code>的信息，<code>Bean</code>不是普通的对象。不像Java使用一个XXX.getClass()就能描述这个对象（包括接口、字段、方法等）。Bean的信息更多（是否Singleton、是否是Spring特有的、DependsOn、Lazy）</p><h2><span id="ioc"> IOC</span><a href="#ioc" class="header-anchor">#</a></h2><p><code>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）</code></p><ul><li>我们使用DI完成IOC看起来编码似乎复杂度增加，有啥优势呢：<ul><li>我们推荐面向抽象编程，这样可以更灵活。而面向抽象编程会产生类的依赖（具体使用哪个实现的问题）</li><li>基于抽象编程除了更灵活外，接触耦合可以给我们带来更强大的增强和拓展（如AOP增强）。最经典的基于代理的事务管理就可以实现。</li><li>spring给我们提供一种机制来管理我们的依赖关系，就是IOC容器。</li></ul></li></ul><h2><span id="yi-xie-xi-jie"> 一些细节</span><a href="#yi-xie-xi-jie" class="header-anchor">#</a></h2><ul><li>xml和annotation是可以混用的。如果在<code>XMLApplicationContext</code>中默认是没有开启注解的，此时想要使用<code>annotation-based</code>还是需要一个xml，在里面配置<code>&lt;context:component-scan base-package=&quot;com.xxx&quot;&gt;</code> 。这一行会开启注解+自动扫描两个功能。</li><li><code>JavaConfig</code>使用<code>AnnotationConfigApplicationContext</code>就不需要再次开启，默认是开启的。</li></ul><h3><span id="xml-xi-jie"> xml细节</span><a href="#xml-xi-jie" class="header-anchor">#</a></h3><ul><li><p>可以<code>schema-based</code>的XML方式管理 ，<code>annotaion-based</code>注解方式管理，<code>java-based</code>使用javabean管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring的p、c、contecxt等标签的xsd在jar包里，所以不用写远程xsd地址也会自动提示--/&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!-- https://blog.csdn.net/fox_bert/article/details/80793030 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这一行就可以开启注解自动扫描，此时就是注解+xml混用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sam.bean"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"school"</span> <span class="attr">class</span>=<span class="string">"com.sam.bean.School"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schoolName"</span> <span class="attr">value</span>=<span class="string">"xxx小学"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">ref</span>=<span class="string">"zhangsan"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可以使用p属性完成属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"zhangsan"</span> <span class="attr">class</span>=<span class="string">"com.sam.bean.Student"</span> <span class="attr">p:age</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name="age" value="5"&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dad"</span> <span class="attr">ref</span>=<span class="string">"laozhang"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"laozhang"</span> <span class="attr">class</span>=<span class="string">"com.sam.bean.Person"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"老张"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"company"</span> <span class="attr">ref</span>=<span class="string">"school"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"job"</span> <span class="attr">value</span>=<span class="string">"teacher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 构造器的循环依赖，无法解决 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构造器也可以用c属性实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="school" class="com.sam.bean.School" c:schoolName="xxx小学" c:student-ref="zhangsan"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="school" class="com.sam.bean.School"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="schoolName" value="xxx小学"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="student" ref="zhangsan"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="zhangsan" class="com.sam.bean.Student"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="age" value="5"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="dad" ref="laozhang"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean id="laozhang" class="com.sam.bean.Person"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="company" ref="school"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="name" value="老张"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;constructor-arg name="job" value="teacher"&gt;&lt;/constructor-arg&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/bean&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3><span id="zhu-jie-xi-jie"> 注解细节</span><a href="#zhu-jie-xi-jie" class="header-anchor">#</a></h3><ul><li><code>@Autowired</code>默认使用byType进行配置，重复的话去byName，多个实现的Class驼峰和属性name不一样就不知道哪个会报错。此时可以用<code>@Primary</code>指定优先一个。或者用<code>@Qualifier (&quot;xxxImpl&quot;)</code>去配合使用</li><li><code>@Resource</code>默认使用byName进行配置。</li><li>当一个单例对象引用另一个多例对象的时候，直接<code>@Autowaired</code>或者<code>@Resource</code>会有问题，被引用的多例对象只会创建一次，变成一个单例对象。此时解决方案：<ul><li>给单例对象实现<code>ApplicationContextAware</code>注入context，每次去context里面getBean就会拿到多例对象，但是侵入性太高。</li><li>用<code>Lookup Method Injection</code>方法注入：<code>@Lookup</code>注解放到一个抽象方法上去获取bean，那么spring会直接每次给你一个新的（<strong>必然是代理模式实现的</strong>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个单例对象</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用一个多例对象</span></span><br><span class="line">    <span class="meta">@Lookup</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="qi-ta-xi-jie"> 其他细节</span><a href="#qi-ta-xi-jie" class="header-anchor">#</a></h3><ul><li><code>profile</code>当前生效的配置环境，可以自己起名字，默认是<code>default-profile</code>。可以在@Configuration（或者在单独一个Class，但是很少用）的类名上写上<code>@Profile(&quot;test&quot;)</code>,那么就只有测试环境<code>test</code>的时候才会生效。</li><li><code>profile</code>怎么获取到的呢？他是放在environment里面的，可以从applicatoincontext.xml加载，或者java里面设置<code>context.getEnvirionment().setActiveprofiles(&quot;test&quot;)</code>,但是java设置之后要使用<code>context.resresh()</code>才能生效。</li></ul><h1><span id="qi-dong-guo-cheng"> 启动过程</span><a href="#qi-dong-guo-cheng" class="header-anchor">#</a></h1><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200708002705325.png" alt="image-20200708002705325"></p><p><code>BeanDefinitionRegistryPostProcessor</code>是<code>BeanFactoryPostProcessor</code>的子接口</p><p>注解启动的<code>ConfigurationClassPostProcessor</code>就是典型实现。</p><h1><span id="spring-jie-jue-xun-huan-yi-lai-fang-an"> spring解决循环依赖方案</span><a href="#spring-jie-jue-xun-huan-yi-lai-fang-an" class="header-anchor">#</a></h1><p>首先有两种循环依赖（一般都是说单例的问题），constructor的循环依赖问题无法解决。setter的循环依赖可以解决。</p><p>注册到<code>DefaultSingletonBeanRegistry</code>的对象有三级缓存，<code>getSingleton</code>获取的时候可以提前暴露暂时还没setter完的对象。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200709131933087.png" alt="image-20200709131933087"></p><ul><li>这个<code>DefaultSingletonBeanRegistry</code>是默认Bean工厂<code>DefaultListableBeanFactory</code>的父类。所以beanFactory也是注册中心：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一级缓存，放单例对象</span></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 三级缓存，从factory获取对象</span></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 二级缓存，刚创建好还没setter的对象</span></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经注册好的bean的名字</span></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在创建的bean的名字</span></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans currently excluded from in creation checks. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; inCreationCheckExclusions =</span><br><span class="line">Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of suppressed Exceptions, available for associating related causes. */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Exception&gt; suppressedExceptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag that indicates whether we're currently within destroySingletons. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> singletonsCurrentlyInDestruction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Disposable bean instances: bean name to disposable instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; disposableBeans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between containing bean names: bean name to Set of bean names that the bean contains. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between dependent bean names: bean name to Set of dependent bean names. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between depending bean names: bean name to Set of bean names for the bean's dependencies. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建对象的时候要分别往三个缓存作用域合适的里面put</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解决setter循环依赖的核心代码，使用了三级缓存</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early  允许提前暴露，来解决循环依赖的问题</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);     <span class="comment">// 一级缓存</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);  <span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);  <span class="comment">// 三级缓存，把bean对象提前暴露出出来了</span></span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name,</span></span><br><span class="line"><span class="comment"> * creating and registering a new one if none registered yet.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonFactory the ObjectFactory to lazily create the singleton</span></span><br><span class="line"><span class="comment"> * with, if necessary</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line"><span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">Assert.notNull(singletonObject, <span class="string">"Singleton object must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object oldObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not register object ["</span> + singletonObject +</span><br><span class="line"><span class="string">"] under bean name '"</span> + beanName + <span class="string">"': there is already object ["</span> + oldObject + <span class="string">"] bound"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the given singleton object to the singleton cache of this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To be called for eager registration of singletons.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonObject the singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject); <span class="comment">// 注册到一级缓存singletonObjects中</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);  <span class="comment">// 同时从二级、三级缓存删除这个bean</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);    <span class="comment">// 把bean的名字注册到set中去</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the given singleton factory for building the specified singleton</span></span><br><span class="line"><span class="comment"> * if necessary.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to</span></span><br><span class="line"><span class="comment"> * resolve circular references.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> singletonFactory the factory for the singleton object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="springframework-de-tuo-zhan-dian"> SpringFramework的拓展点</span><a href="#springframework-de-tuo-zhan-dian" class="header-anchor">#</a></h1><p>官网关于拓展点的链接：</p><blockquote><p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-extension" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-factory-extension</a></p></blockquote><p>先说结论：一般来说开发者无需自己去实现一个<code>ApplicationContext</code>进行拓展（虽然在诸如<code>refresh</code>方法中预留了拓展类），而是选用实现spring的插件式接口进行拓展。</p><h3><span id="tong-guo-beanpostprocesso-ding-zhi-hua-bean"> 通过 <code>BeanPostProcesso</code>定制化Bean</span><a href="#tong-guo-beanpostprocesso-ding-zhi-hua-bean" class="header-anchor">#</a></h3><p>如果要更改实际的bean实例（即从配置元数据创建的对象），则需要使用<code>BeanPostProcessor</code>进行拓展。可以插手Bean创建的过程，可以是多个BPP链式执行，可以减轻BF的负担。</p><p>如AOP就是Bean实例化的期间通过BPP织入切面逻辑到代理对象的。</p><ul><li><p><strong>what：</strong><code>BeanPostProcessor</code>接口定义回调方法，可以实现这些回调方法来提供您自己的(或覆盖容器的缺省)<strong>实例化逻辑</strong>、<strong>依赖项解析逻辑</strong>等。 如果希望在Spring容器完成实例化、配置和初始化bean之后实现一些自定义逻辑，可以插入一个或多个自定义<code>BeanPostProcessor</code>实现。</p></li><li><p>后处理器可以对bean实例执行任何操作，如回调接口、包装Bean。比如 一些Spring AOP基础结构类被实现为bean后处理器，以提供代理包装逻辑。</p></li><li><p>**when：**当类被注册为<code>BeanPostProcessor</code>时，对于容器创建的每个bean实例，后处理器都会在容器初始化方法（如InitializingBean.afterPropertiesSet（）或 任何声明的init方法），并在任何bean初始化回调之后被调用。</p></li><li><p><strong>how：</strong> 自动检测。<code>ApplicationContext</code>自动检测实现<code>BeanPostProcessor</code>接口的所有bean。 <code>ApplicationContext</code>将这些bean注册BFPP，以便以后在bean创建时可以调用它们。</p></li><li><p>**other：**可以配置多个<code>BeanPostProcessor</code>实例，通过设置order属性并实现Ordered接口来控制这些<code>BeanPostProcessor</code>实例的执行顺序。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在bean的init方法之前执行（constructor-----此方法-----init方法）</span></span><br><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//constructor-----上面方法-----init方法-----此方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="tong-guo-tuo-zhan-beanfactorypostprocessor-zi-ding-yi-pei-zhi-xin-xi"> 通过拓展<code>BeanFactoryPostProcessor</code>自定义配置信息</span><a href="#tong-guo-tuo-zhan-beanfactorypostprocessor-zi-ding-yi-pei-zhi-xin-xi" class="header-anchor">#</a></h3><ul><li><p><strong>what：</strong><code>BeanFactoryPostProcessor</code>对Bean配置**元数据（METADATA）**进行操作。 也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，并有可能在容器实例化除<code>BeanFactoryPostProcessor</code>实例以外的任何bean之前更改它。（官网原文，说的很严谨）。同样可以使用<code>Orderd</code>进行排序。</p></li><li><p><strong>wheh：</strong><code>BeanFactoryPostProcessor</code>在ApplicationContext中声明后会自动执行，以便将更改<strong>应用于定义容器的配置元数据</strong>。 Spring包含许多预定义的BFPP，例如<code>PropertyOverrideConfigurer</code>和<code>PropertySourcesPlaceholderConfigurer</code>。 我们也可以使用自定义<code>BeanFactoryPostProcessor</code>，例如注册自定义属性编辑器</p></li><li><p>**how：**自动检测，<code>ApplicationContext</code>自动检测实现<code>BeanFactoryPostProcessor</code>接口的Bean。它在适当的时候将这些bean用作<code>BFPP</code>。</p></li></ul><h3><span id="beanfactory-he-factorybean"> BeanFactory和FactoryBean</span><a href="#beanfactory-he-factorybean" class="header-anchor">#</a></h3><ul><li><code>FactoryBean</code>是一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个FactoryBean有三个接口</span></span><br><span class="line"><span class="comment"> * getObject()、getObjectType()、isSingleton()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 此处注册之后，会注册两个对象：</span></span><br><span class="line"><span class="comment">// 1.CarFactoryBean本身在BeanFactory中就是一个&amp;carFactoryBean对象，</span></span><br><span class="line"><span class="comment">// 2.Car在BeanFactory中是carFactoryBean对象</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String carProperties = <span class="string">"audiA6,300000"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的对象是</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是FactoryBean创建对象和核心逻辑</span></span><br><span class="line">        String[] properties = carProperties.split(<span class="string">","</span>);</span><br><span class="line">        log.info(<span class="string">"即将调用CarFactoryBean#getObject创建一个car..........."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(properties[<span class="number">0</span>],Double.parseDouble(properties[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beanFactory.getBeanNamesForType(Car.class)===carFactoryBean</code></p><p><code>beanFactory.getBeanNamesForType(CarFactoryBean.class)===&amp;carFactoryBean</code></p><h2><span id="zi-ding-yi-chu-shi-hua-qi-initializer-tuo-zhan"> 自定义初始化器<strong>initializer</strong>拓展</span><a href="#zi-ding-yi-chu-shi-hua-qi-initializer-tuo-zhan" class="header-anchor">#</a></h2><p>首先实现<code>ApplicationContextInitializer</code>接口，会有一个<code>initialize(context)</code>方法需要重写。会在<code>resresh()</code>之前进行调用，如：<code>ContextIdApplicationContextInitializer</code>给context设置ID。下面自己实现了一个毫无意义的初始化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> &lt;<span class="title">ConfigurableApplicationContext</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"即将调用refresh---------------applicationContext.getBeanDefinitionNames()=\n"</span>);</span><br><span class="line">        Arrays.stream(applicationContext.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册到容器有两种方式：</p><ul><li><p>系统级：</p><ul><li><p>建立<code>META-INF/spring.factories</code>，然后注册，如：</p></li><li><pre class="highlight"><code class="properties"><span class="hljs-comment"># 增加一个自定义初始化器，在new SpringApplication的时候load创建，refresh之前会被调用</span><span class="hljs-meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">com.sam.bootdemo.extend.MyApplicationContextInitializer</span><span class="hljs-attr"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    这种方式将会在系统启动的时候使用&#96;getSpringFactoriesInstances(ApplicationContextInitializer.class)&#96;方式加载到，然后注册到context中去统一执行。</span><br><span class="line"></span><br><span class="line">- 委派级：</span><br><span class="line"></span><br><span class="line">  - 不用创建spring.factories。直接注册到context和系统级的initlitializeri并列，而是委派给另一个&#96;DelegatingApplicationContextInitializer&#96;调用。如：</span><br><span class="line"></span><br><span class="line">  - 在spring的yaml或者propertiers中添加如下的属性（多个逗号分割）：</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;properties</span><br><span class="line">    # 将会被&#96;DelegatingApplicationContextInitializer&#96;解析并反射创建后以一个成员变量list存在。当DelegatingApplicationContextInitializer执行初始化方法的时候，会把这些自定义的初始化器进行排序、然后逐个调用。</span><br><span class="line">    context.initializer.classes&#x3D;com.sam.bootdemo.extend.MyApplicationContextInitializer</span><br></pre></td></tr></table></figure></span></code></pre></li></ul></li></ul><h2><span id="zi-ding-yi-jian-ting-qi-listener-tuo-zhan"> 自定义监听器listener拓展</span><a href="#zi-ding-yi-jian-ting-qi-listener-tuo-zhan" class="header-anchor">#</a></h2><ul><li>实现<code>ApplicationListener</code>接口，有一个<code>onApplicationEvent(ApplicationEvent event)</code>方法需要重写。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;MyApplicationListener监听到一个事件：event source == "</span>+event.getSource());</span><br><span class="line">                <span class="comment">// 可以根据事件类型判断是否处理</span></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationPreparedEvent) &#123;</span><br><span class="line">            <span class="comment">//XXXX xxx = ((ApplicationStartedEvent)event).getApplicationContext().getBean(XXXX.class);</span></span><br><span class="line">            <span class="comment">// 做一些操作，如启动一个调度线程池等等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有一个顶级派发监听器接口叫做<code>SpringApplicationRunListener</code>，他里面有一个实现：<code>EventPublishingRunListener</code></li><li>系统级的<code>EventPublishingRunListener</code>监听器有多拨器<code>SimpleApplicationEventMulticaster</code><ul><li>多拨器里面有我们的所有<code>ApplicationListener</code>列表，可以根据<code>supportsEvent</code>方法判断哪些listener支持这个事件，并在<code>doInvokeListener</code>中调用</li></ul></li><li>所有的系统级监听器里面有一个很特殊的<code>DelegatingApplicationListener</code>，和上面的初始化器很像，也是可以委派分发事件。</li></ul><p>流程：</p><ul><li>容器发生对应的业务场景时调用<code>ApplicationRunListener#starting/environmentPrepared/contextPrepared/contextLoaded/started/running/failed</code></li><li>ApplicationRunListener回去调用多拨器向listener分发事件，如<code>ApplicationStartingEvent、ApplicationEnvironmentPreparedEvent、ApplicationContextInitializedEvent、ApplicationPreparedEvent、ApplicationStartedEvent、ApplicationReadyEvent</code>等等</li><li>多拨器分发到一个特殊的<strong>DelegatingApplicationListener</strong>时候，它又去加载和环境中的&quot;<strong>context.listener.classes</strong>&quot;，然后反射创建、排序后向他们转发RunListener发来的事件。</li></ul><p>注册到容器：</p><p>同上面的初始化器也是两种方式</p><ul><li><code>META-INF/spring.factories</code>里面注册</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#spring&quot;&gt;Spring&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#beandefinition&quot;&gt;BeanDefinition&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="框架" scheme="https://blog.sofunnyai.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="框架" scheme="https://blog.sofunnyai.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="spring" scheme="https://blog.sofunnyai.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>CAS比较并交换的原理和ABA问题</title>
    <link href="https://blog.sofunnyai.com/article/cas-and-aba.html"/>
    <id>https://blog.sofunnyai.com/article/cas-and-aba.html</id>
    <published>2018-03-01T05:05:11.000Z</published>
    <updated>2020-06-15T01:14:54.825Z</updated>
    
    <content type="html"><![CDATA[<!--此处生成目录--><div class="toc"><!-- toc --><ul><li><a href="#bei-jing">背景</a></li><li><a href="#cas-jian-jie">CAS简介</a><ul><li><a href="#atomic-xiu-shi-de-lei-wei-sha-shi-xian-cheng-an-quan-de-ru-atomicinteger">Atomic修饰的类为啥是线程安全的？如AtomicInteger</a></li><li><a href="#unsafe-java-di-ceng-shi-xian">unsafe.java底层实现：</a></li><li><a href="#compareandswapint-de-di-ceng-cpu-yuan-yu-shi-xian-lock-cmpxchg"><code>compareAndSwapInt</code>的底层CPU源语实现—lock cmpxchg：</a></li><li><a href="#cas-que-dian">CAS缺点</a></li><li><a href="#xiao-jie">小结</a><ul><li><a href="#cas-ying-yong">CAS应用</a></li></ul></li></ul></li><li><a href="#aba-wen-ti-shi-shi-me-yuan-zi-geng-xin-yin-yong-shi-shi-me">ABA问题是什么？原子更新引用是什么？</a><ul><li><a href="#cas-dao-zhi-aba-wen-ti">CAS导致ABA问题</a></li><li><a href="#aba-wen-ti">ABA问题</a></li><li><a href="#yuan-zi-yin-yong-atomicreference">原子引用AtomicReference</a></li></ul></li><li><a href="#dai-ban-ben-de-yuan-zi-yin-yong-jie-jue-aba-wen-ti-atomicstampedreference">带版本的原子引用解决ABA问题 AtomicStampedReference</a></li><li><a href="#longadder-cas-ji-zhi-you-hua">LongAdder（CAS机制优化）</a><ul><li><a href="#wei-shi-me-you-liao-atomiclong-huan-yao-xin-zeng-yi-ge-longadder-ni">为什么有了AtomicLong还要新增一个LongAdder呢</a></li></ul><ul><li><a href="#can-kao">参考</a></li></ul></li></ul><!-- tocstop --></div><p><strong>文章主线:</strong></p><p><strong>CAS----&gt;Unsafe----&gt;CAS底层实现和思想----&gt;ABA问题----&gt;原子引用更新----&gt;如何规避ABA问题</strong></p><p>这篇博客还不错</p><blockquote><p><a href="https://blog.csdn.net/javazejian/article/details/72772470" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72772470</a></p></blockquote><h1><span id="bei-jing"> 背景</span><a href="#bei-jing" class="header-anchor">#</a></h1><ul><li>在以前没有CAS的时候，对一个多线程修改i++是有线程安全问题的，因为<code>i++</code>操作底层是三个指令，不是原子的。</li><li>使用AtomicInteger替代Integer即可线程安全。AtomicInteger底层就是CAS支持的。</li></ul><h1><span id="cas-jian-jie"> CAS简介</span><a href="#cas-jian-jie" class="header-anchor">#</a></h1><ul><li>CompareAndSet，比较并交换思想，底层是<strong>CPU并发源语言</strong>。功能是判断某个内存是为是否是预期的值，true则更新，false放弃。过程是原子的（线程安全）。</li><li>CAS是一种轻量级锁，在没有线程阻塞的情况下实现变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁(读多场景被修改后重试或者报错)。</li><li>CPU原语音硬件实现，执行必须连续，所以天生就是原子的。线程安全。</li><li>底层通过<code>Unsafe</code>类实现，Unsafe中的<code>CAS</code>方法JVM会生成汇编指令。</li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601133439289.png" alt="image-20200601133439289"></p><h2><span id="atomic-xiu-shi-de-lei-wei-sha-shi-xian-cheng-an-quan-de-ru-atomicinteger"> Atomic修饰的类为啥是线程安全的？如AtomicInteger</span><a href="#atomic-xiu-shi-de-lei-wei-sha-shi-xian-cheng-an-quan-de-ru-atomicinteger" class="header-anchor">#</a></h2><ul><li><code>AtomicInteger.java</code> 的 <code>getAndIncrement</code>方法，获取值并+1，底层借助了JDK的rt.jar中的<code>unsafe</code>类的native方法。</li><li>unsafe类是<code>sun.misc.Unsafe</code>，使用本地方法帮Java操纵底层。如读写操纵特定内存位置的数据。----直接操纵操作系统执行任务</li><li>下面代码里直接用<strong>unsafe去操纵内存偏移位置上的对象</strong>，是不允许中断的连续的指令，是线程安全的，所以没有并发问题。</li><li>变量value使用volatile修饰，保证多线程的可见性</li></ul><p>AtomicInteger.java 节选：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;  <span class="comment">// 当前AtomicInteger内部使用了一个volatile修饰的int存储值。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);   <span class="comment">// 传入当前AtomicInteger对象，在内存的地址偏移量对应对象，加1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2><span id="unsafe-java-di-ceng-shi-xian"> unsafe.java底层实现：</span><a href="#unsafe-java-di-ceng-shi-xian" class="header-anchor">#</a></h2><p>使用了<code>compareAndSwapInt</code>自旋：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe类的  getAndAddInt 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;            </span><br><span class="line">    <span class="comment">// var1 是上面的this对象，就是当前的那个Integer，var2是unsafe找到的内存地址，var4是要新增的值</span></span><br><span class="line">        <span class="keyword">int</span> var5;  <span class="comment">// var5 是内存快照里面的值</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);   <span class="comment">// 当前这个var1（上面this对象）在内存地址var2上去取到volatile的快照值放到var5中</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    </span><br><span class="line">           <span class="comment">// var1对象在var2内存地址上的值和快照值var5比较，相同就给var5+var4，结束do...while。如果拿出来的快照值不相等，继续do...while，上面去继续</span></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getIntVolatile  和  compareAndSwapInt是当前unsafe类中的native方法，借助CPU源语实现线程安全。（后面有个JVM native方法的源码）</span></span><br></pre></td></tr></table></figure><p>var5：就是我们从主内存volatile中拷贝到工作内存中的值操作的时候，需要比较工作内存中的值，和主内存中的值进行比较</p><p>假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样</p><ul><li>val1：AtomicInteger对象本身</li><li>var2：该对象值的引用内存地址</li><li>var4：需要修改变动的数量</li><li>var5：用var1和var2找到的内存中的真实值<ul><li>用该对象当前的值与var5比较</li><li>如果相同，更新var5 + var4 并返回true，结束循环。</li><li>如果不同，继续取volatile值然后再比较，直到更新完成</li></ul></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601212926046.png" alt="image-20200601212926046"></p><p>这里没有用synchronized，而用CAS，这样提高了并发性，也能够实现一致性，是因为每个线程进来后，进入的do while循环，然后不断的获取内存中的值，判断是否为最新，然后在进行更新操作。</p><p>假设线程A和线程B同时执行getAndAddInt操作（分别跑在不同的CPU上）</p><ol><li>AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存</li><li>线程A通过getIntVolatile(var1 , var2) 拿到value值3，这是线程A被挂起（该线程失去CPU执行权）</li><li>线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK</li><li>这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while</li><li>线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。</li></ol><h2><span id="compareandswapint-de-di-ceng-cpu-yuan-yu-shi-xian-lock-cmpxchg"> <code>compareAndSwapInt</code>的底层CPU源语实现—lock cmpxchg：</span><a href="#compareandswapint-de-di-ceng-cpu-yuan-yu-shi-xian-lock-cmpxchg" class="header-anchor">#</a></h2><p>汇编语言<code>cmpxchg</code>指令，也是compareAndSwapInt的实现。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601214101655.png" alt="image-20200601214101655"></p><p>多核情况下最终的实现：<code>lock cmpxchg</code></p><ul><li>lock指令是锁总线，所以<code>lock cmpxchg</code></li></ul><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200606184153528.png" alt="image-20200606184153528"></p><p>Unsafe类 + CAS思想： 也就是自旋，自我旋转</p><p>CAS这里不需要经过操作系统的线程管理，所以是轻量级的，synchronized是需要操作系统进行线程管理是总量级的。</p><h2><span id="cas-que-dian"> CAS缺点</span><a href="#cas-que-dian" class="header-anchor">#</a></h2><p>和synchronized比较，没有加锁每个线程都可以同时竞争并发计算，但是也有以下缺点：</p><ul><li>循环太多的时候，自旋太多。do…while太多，CPU开销大。（没有锁，需要大量比较）</li><li>只能保证一个变量的原子性，不像synchronized可以对多个变量进行原子性操作。</li><li>引出了ABA问题，两个线程在执行CAS竞争的时候，一个线程T1很慢，另一个T2很快。初始的时候快照变量都是A，在拿到线程内存中后，T2修改为B并CAS写回成功。然后T2再来一次CAS把变量从B改为A，后来T1才回来，一看主内存还是A，CAS成功改成C。但这时候的A和刚才的A虽然值一样，但是可能业务发生了变化。造成问题。具体见下一章。</li></ul><h2><span id="xiao-jie"> 小结</span><a href="#xiao-jie" class="header-anchor">#</a></h2><h3><span id="cas-ying-yong"> CAS应用</span><a href="#cas-ying-yong" class="header-anchor">#</a></h3><p>CAS是compareAndSwap，比较当前工作内存中的值和主物理内存中的值，如果相同则执行规定操作，否者继续比较直到主内存和工作内存的值一致为止。</p><p>CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否者什么都不做。</p><p>适用于在写少读多的时候，使用CAS完成单变量的同步。</p><h1><span id="aba-wen-ti-shi-shi-me-yuan-zi-geng-xin-yin-yong-shi-shi-me"> ABA问题是什么？原子更新引用是什么？</span><a href="#aba-wen-ti-shi-shi-me-yuan-zi-geng-xin-yin-yong-shi-shi-me" class="header-anchor">#</a></h1><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601215404311.png" alt="image-20200601215404311"></p><p>假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。</p><p>所以ABA问题就是：在获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了</p><h2><span id="cas-dao-zhi-aba-wen-ti"> CAS导致ABA问题</span><a href="#cas-dao-zhi-aba-wen-ti" class="header-anchor">#</a></h2><p>CAS算法实现了一个重要的前提，<strong>需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。</strong></p><p>比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</p><p><code>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的，看业务情况。</code></p><h2><span id="aba-wen-ti"> ABA问题</span><a href="#aba-wen-ti" class="header-anchor">#</a></h2><p>如果业务只管最终的数值是无所谓的，最终都是A即可。ABA问题就可以接受。（只看结果）</p><p>但是如果业务要求中间不能被别的线程偷偷改变还不知道（如支付类）。ABA问题就无法被接受。（要求过程）</p><h2><span id="yuan-zi-yin-yong-atomicreference"> 原子引用AtomicReference</span><a href="#yuan-zi-yin-yong-atomicreference" class="header-anchor">#</a></h2><p>原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性。可以完成类似AtomicInteger等同样的原子性效力。</p><p>但是原子引用打来了ABA问题。</p><h1><span id="dai-ban-ben-de-yuan-zi-yin-yong-jie-jue-aba-wen-ti-atomicstampedreference"> 带版本的原子引用解决ABA问题 AtomicStampedReference</span><a href="#dai-ban-ben-de-yuan-zi-yin-yong-jie-jue-aba-wen-ti-atomicstampedreference" class="header-anchor">#</a></h1><p>通过一个版本号stamp来解决ABA问题，内同一致但是版本号不一致还是不能提交修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sam.phoenix.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS虽然可以自旋解决变量竞争的线程安全问题，但是会带来ABA问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CAS算法实现了一个重要的前提：**需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。**</span></span><br><span class="line"><span class="comment"> * 比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * `尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的，看业务情况。`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ## ABA问题</span></span><br><span class="line"><span class="comment"> * 如果业务只管最终的数值是无所谓的，最终都是A即可。ABA问题就可以接受。（只看结果）</span></span><br><span class="line"><span class="comment"> * 但是如果业务要求中间不能被别的线程偷偷改变还不知道（如支付类）。ABA问题就无法被接受。（要求过程）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CAS_ABA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------以下是一个CAS引发的ABA问题的demo-------------------------"</span>);</span><br><span class="line">        casABA();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------以下是一个ABA解决，使用带版本号的stampRefference-------------------------"</span>);</span><br><span class="line">        resolveABA();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 演示CAS带来的ABA问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">casABA</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化原子引用</span></span><br><span class="line">        <span class="comment">// 定义一个原子引用（包装了一个自定义类），初始化值是张三</span></span><br><span class="line">        AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">"z3"</span>, <span class="number">33</span>);</span><br><span class="line">        atomicUser.set(z3);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 完成一次ABA</span></span><br><span class="line">            User l4 = <span class="keyword">new</span> User(<span class="string">"l4"</span>, <span class="number">44</span>);</span><br><span class="line">            atomicUser.compareAndSet(z3, l4);  <span class="comment">// 对比主内存，如果是张三，就修改为李四</span></span><br><span class="line">            atomicUser.compareAndSet(l4,z3);   <span class="comment">// 对比主内存，如果是李四，就修改为张三</span></span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 睡眠1秒，等待上面ABA完成(上面偷梁换柱，偷偷改过一次)</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                User w5 = <span class="keyword">new</span> User(<span class="string">"w5"</span>, <span class="number">55</span>);</span><br><span class="line">                <span class="keyword">boolean</span> result = atomicUser.compareAndSet(z3, w5); <span class="comment">// 虽然更新成功，但是其实里面的z3已经被修改过一次了</span></span><br><span class="line">                System.out.println(<span class="string">"最终t2"</span>+result+<span class="string">",atomicUser中的user："</span>+atomicUser.get());</span><br><span class="line">                System.out.println(<span class="string">"虽然更新成功，但是其实里面的z3已经被修改过一次了,某些业务场景会出错!!!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时使用版本号解决ABA问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveABA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User z3 = <span class="keyword">new</span> User(<span class="string">"z3"</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="comment">// 初始化一个张三进去，版本号是1</span></span><br><span class="line">        AtomicStampedReference&lt;User&gt; stampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(z3, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            User l4 = <span class="keyword">new</span> User(<span class="string">"l4"</span>, <span class="number">44</span>);</span><br><span class="line">            <span class="comment">// 期待是张三，相等的话就改成李四，同时期待版本号是1</span></span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            <span class="comment">// 休眠1秒，等待下面的线程获取同样的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = stampedReference.compareAndSet(z3, l4, stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"尝试更新版本号"</span>+stamp+<span class="string">"，结果："</span>+result+<span class="string">",stampedReference中最新的数据："</span>+stampedReference.getReference()+<span class="string">"最新版本号"</span>+stampedReference.getStamp());</span><br><span class="line">            stamp = stampedReference.getStamp();</span><br><span class="line">            result = stampedReference.compareAndSet(l4, z3, stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"尝试更新版本号"</span>+stamp+<span class="string">"，结果："</span>+result+<span class="string">",stampedReference中最新的数据："</span>+stampedReference.getReference()+<span class="string">"最新版本号"</span>+stampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">"t3"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为持有的版本号是老的，会更新失败！</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            User w5 = <span class="keyword">new</span> User(<span class="string">"w5"</span>, <span class="number">55</span>);</span><br><span class="line">            <span class="keyword">int</span> stamp = stampedReference.getStamp();</span><br><span class="line">            <span class="comment">// 睡3秒，等上面完成sleep和CAS</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> result = stampedReference.compareAndSet(z3, w5, stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"尝试更新版本号"</span>+stamp+<span class="string">"，结果："</span>+result+<span class="string">",stampedReference中最新的数据："</span>+stampedReference.getReference()+<span class="string">"最新版本号"</span>+stampedReference.getStamp());</span><br><span class="line">        &#125;,<span class="string">"t4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="longadder-cas-ji-zhi-you-hua"> LongAdder（CAS机制优化）</span><a href="#longadder-cas-ji-zhi-you-hua" class="header-anchor">#</a></h1><p>LongAdder是java8在atomic包里为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化</p><p>类似的还有一个DoubleAdder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAdder：</span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LongAdder count = <span class="keyword">new</span> LongAdder();</span><br><span class="line"><span class="comment">//变量操作</span></span><br><span class="line">count.increment();</span><br><span class="line"><span class="comment">//变量取值</span></span><br><span class="line">count</span><br></pre></td></tr></table></figure><h3><span id="wei-shi-me-you-liao-atomiclong-huan-yao-xin-zeng-yi-ge-longadder-ni"> 为什么有了AtomicLong还要新增一个LongAdder呢</span><a href="#wei-shi-me-you-liao-atomiclong-huan-yao-xin-zeng-yi-ge-longadder-ni" class="header-anchor">#</a></h3><p>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的<strong>自旋</strong>，进入一个无限重复的循环中）</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601235736890.png" alt="image-20200601235736890"></p><p><strong>核心思想：将热点数据分离。</strong></p><p>比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    add(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123; <span class="comment">//cas失败一次</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))) <span class="comment">// 给cell数组里面找一个线程的格子添加一个，然后下面再accumulate累加</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有<strong>很多线程会不停的自旋</strong>，进入一个无限重复的循环中。</p><p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p><p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p><p>于是，当当当当，Java 8推出了一个新的类，<strong>LongAdder</strong>，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601235815152.png" alt="image-20200601235815152"></p><p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p><p>接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行<strong>分段CAS的机制</strong>，也就是内部会搞一个Cell数组，每个数组是一个数值分段。</p><p>这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！</p><p>这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p><p>而且他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。</p><p>这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p><p>最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601235850232.png" alt="image-20200601235850232"></p><p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p><p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p><p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p><p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是<strong>伪共享</strong>。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失）<br><strong>LongAdder的add操作图</strong></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601235924711.png" alt="image-20200601235924711"></p><p>可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。<br>如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。<br><strong>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</strong></p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200601235953395.png" alt="image-20200601235953395"></p><p>如上图代码：<br>例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注<code>@sun.misc.Contended</code>解用于解决这个问题,由JVM去插入这些变量，<a href="http://xn--openjdk-hc5k25at0ntqhnpa7548b.java.net/jeps/142" target="_blank" rel="noopener">具体可以参考openjdk.java.net/jeps/142</a> ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。</p><p>为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p><p><img src="https://gitee.com/radio/pics/raw/master/img/image-20200602000026847.png" alt="image-20200602000026847"></p><p>可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p><p>在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中<br>从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。</p><p>由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。</p><p>数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。<br>我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？</p><h2><span id="can-kao"> 参考</span><a href="#can-kao" class="header-anchor">#</a></h2><blockquote><p><a href="https://blog.csdn.net/eluanshi12/article/details/84871879" target="_blank" rel="noopener">AtomicLong与LongAdder（CAS机制的优化）</a></p></blockquote><blockquote><p><a href="https://mp.weixin.qq.com/s/KFsqsCVgyiiTDXMR-Hu1-Q" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/wolf_love666/article/details/87693771" target="_blank" rel="noopener">https://blog.csdn.net/wolf_love666/article/details/87693771</a></p></blockquote><blockquote><p><a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">https://gitee.com/moxi159753/LearningNotes</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--此处生成目录--&gt;
&lt;div class=&quot;toc&quot;&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#bei-jing&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cas-jian-jie&quot;&gt;CAS简介&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="多线程" scheme="https://blog.sofunnyai.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://blog.sofunnyai.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="jdk" scheme="https://blog.sofunnyai.com/tags/jdk/"/>
    
      <category term="源码" scheme="https://blog.sofunnyai.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="https://blog.sofunnyai.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
